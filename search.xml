<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot2-Hikari数据源配置]]></title>
    <url>%2FendBlogs%2F2019%2F07%2F01%2FSpringBoot2-Hikari%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用方式在pom.xml中引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 然后SpringBoot application.properties中配置数据源参数： 1234567891011121314#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/ak_blog?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=truespring.datasource.username=rootspring.datasource.password=spring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle=5spring.datasource.hikari.maximum-pool-size=15spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=30000spring.datasource.hikari.pool-name=DatebookHikariCPspring.datasource.hikari.max-lifetime=1800000spring.datasource.hikari.connection-timeout=30000spring.datasource.hikari.connection-test-query=SELECT 1 或者增加HikariCP配置文件，设置连接池配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package pub.lichao.test.config;import com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;/** * HikariCP连接池配置 */@Configurationpublic class DataSourceConfig &#123; @Value("$&#123;spring.datasource.url&#125;") private String dataSourceUrl; @Value("$&#123;spring.datasource.username&#125;") private String user; @Value("$&#123;spring.datasource.password&#125;") private String password; @Bean public DataSource primaryDataSource() &#123; HikariConfig config = new HikariConfig(); //数据源 config.setJdbcUrl(dataSourceUrl); //用户名 config.setUsername(user); //密码 config.setPassword(password); //是否自定义配置，为true时下面两个参数才生效 config.addDataSourceProperty("cachePrepStmts", "true"); //连接池大小默认25，官方推荐250-500 config.addDataSourceProperty("prepStmtCacheSize", "250"); //单条语句最大长度默认256，官方推荐2048 config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048"); //新版本MySQL支持服务器端准备，开启能够得到显著性能提升 config.addDataSourceProperty("useServerPrepStmts", "true"); config.addDataSourceProperty("useLocalSessionState", "true"); config.addDataSourceProperty("useLocalTransactionState", "true"); config.addDataSourceProperty("rewriteBatchedStatements", "true"); config.addDataSourceProperty("cacheResultSetMetadata", "true"); config.addDataSourceProperty("cacheServerConfiguration", "true"); config.addDataSourceProperty("elideSetAutoCommits", "true"); config.addDataSourceProperty("maintainTimeStats", "false"); HikariDataSource ds = new HikariDataSource(config); return ds; &#125;&#125; 自定义配置自定义数据源官网给出了两种方式： 先看官网给的配置文件： 1234app.datasource.jdbc-url=jdbc:mysql://localhost/testapp.datasource.username=dbuserapp.datasource.password=dbpassapp.datasource.maximum-pool-size=30 1）第一种是使用DataSourceBuilder来构造数据源： 12345@Bean@ConfigurationProperties("app.datasource")public HikariDataSource dataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build();&#125; 2）第二种是使用DataSourceProperties来构造数据源： 123456789101112@Bean@Primary@ConfigurationProperties("app.datasource")public DataSourceProperties dataSourceProperties() &#123; return new DataSourceProperties();&#125;@Bean@ConfigurationProperties("app.datasource")public HikariDataSource dataSource(DataSourceProperties properties) &#123; return properties.initializeDataSourceBuilder().type(HikariDataSource.class).build();&#125; 双数据源配置1234567app.datasource.first.type=com.zaxxer.hikari.HikariDataSourceapp.datasource.first.maximum-pool-size=30app.datasource.second.url=jdbc:mysql://localhost/testapp.datasource.second.username=dbuserapp.datasource.second.password=dbpassapp.datasource.second.max-total=30 采用DataSourceProperties构造： 12345678910111213141516171819202122232425@Bean@Primary@ConfigurationProperties("app.datasource.first")public DataSourceProperties firstDataSourceProperties() &#123; return new DataSourceProperties();&#125;@Bean@Primary@ConfigurationProperties("app.datasource.first")public DataSource firstDataSource() &#123; return firstDataSourceProperties().initializeDataSourceBuilder().build();&#125;@Bean@ConfigurationProperties("app.datasource.second")public DataSourceProperties secondDataSourceProperties() &#123; return new DataSourceProperties();&#125;@Bean@ConfigurationProperties("app.datasource.second")public DataSource secondDataSource() &#123; return secondDataSourceProperties().initializeDataSourceBuilder().build();&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Hikari</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-jdbc]]></title>
    <url>%2FendBlogs%2F2019%2F07%2F01%2Fjava-jdbc%2F</url>
    <content type="text"><![CDATA[JDBC基础什么是JDBC？Java 数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。它JDBC是面向关系型数据库的。 JDBC操作步骤1234567891011第1步：注冊驱动 (仅仅做一次)第2步：建立连接(Connection)第3步：创建运行SQL的语句(Statement)第4步：运行语句第5步：处理运行结果(ResultSet)第6步：释放资源 DriverManager：这个类管理数据库驱动程序的列表，查看加载的驱动是否符合JAVA Driver API的规范。 Connection：用于联系数据库的所有方法。与数据库中的所有的通信是通过唯一的连接对象。 Statement：把创建的SQL对象，转而存储到数据库当中。 ResultSet：它是一个迭代器，用于检索查询数据。 SQLException：此类处理数据库应用程序中发生的任何错误。 1、载入驱动12345678910注冊驱动有三种方式： 1.Class.forName(“com.mysql.jdbc.Driver”); 推荐这样的方式，不会对详细的驱动类产生依赖 2. DriverManager.registerDriver(com.mysql.jdbc.Driver); 会对详细的驱动类产生依赖 3. System.setProperty(“jdbc.drivers”, “driver1:driver2”); 尽管不会对详细的驱动类产生依赖；但注冊不太方便。所以非常少使用 2、建立连接12345678910111213通过Connection建立连接，Connection是一个接口类。其功能是与数据库进行连接（会话）。建立Connection接口类对象： Connection conn =DriverManager.getConnection(url, user, password); 当中URL的格式要求为：JDBC:子协议:子名称//主机名:port/数据库名？属性名=属性值&amp;… 如：&quot;jdbc:mysql://localhost:3306/test“ user即为登录数据库的username，如root password即为登录数据库的密码，为空就填”” 3、创建运行对象12345678910111213141516171819202122232425262728293031 运行对象Statement负责运行SQL语句。由Connection对象产生。 Statement st = connection.createStatement(); Statement接口类还派生出两个接口类PreparedStatement和CallableStatement，这两个接口类对象为我们提供了更加强大的数据訪问功能。 PreparedStatement能够对SQL语句进行预编译，这样防止了SQL注入 提高了安全性。 PreparedStatement ps=connection.prepareStatement( &quot;update user set id=? where username=?”); ————sql语句中用“?”作为通配符，变量值通过参数设入：ps.setObject(1, object); 而且预编译结果能够存储在PreparedStatement对象中。当多次运行SQL语句时能够提高效率。 作为Statement的子类，PreparedStatement继承了Statement的全部函数。 CallableStatement接口 CallableStatement类继承了PreparedStatement类，他主要用于运行SQL存储过程。 在JDBC中运行SQL存储过程须要转义。 JDBC API提供了一个SQL存储过程的转义语法： &#123;call&lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, ...]&#125; procedure-name：是所要运行的SQL存储过程的名字 [&lt;arg1&gt;,&lt;arg2&gt;, ...]：是相相应的SQL存储过程所须要的參数 4、运行SQL语句12345678910运行对象Statement 或 PreparedStatement 提供两个经常使用的方法来运行SQL语句。executeQuery(Stringsql),该方法用于运行实现查询功能的sql语句。返回类型为ResultSet（结果集）。如：ResultSet rs =st.executeQuery(sql);executeUpdate(Stringsql),该方法用于运行实现增、删、改功能的sql语句，返回类型为int，即受影响的行数。如：int flag = st.executeUpdate(sql); 123456String sql = "insert into user(sno,name,age)values(?,?,?)"; //定义一个要执行的SQL语句PreparedStatement ps = (PreparedStatement) conn.prepareStatement(sql);ps.setString(1, student.getSno()); //设置SQL语句的第一个参数ps.setString(2, student.getName()); //设置SQL语句的第二个参数ps.setInt(3, student.getAge()); //设置SQL语句的第三个参数int i = ps.executeUpdate(); //执行SQL语句 5、处理运行结果1234567ResultSet对象负责保存Statement运行后所产生的查询结果，通过游标来操作。游标就是一个可控制的、能够指向随意一条记录的指针。有了这个指针我们就能轻易地指出我们要对结果集中的哪一条记录进行改动、删除，或者要在哪一条记录之前插入数据。一个结果集对象中仅仅包括一个游标。另外，借助ResultSetMetaData ，可以将数据表的结构信息都查出来。ResultSetMetaData rsmd= resultSet.getMetaData(); 12345678910String sql = "SELECT * FROM user";Statement statement = conn.createStatement(sql); //sql语句的执行对象ResultSet row = statement.executeQuery(); //执行SQL语句while (row.next()) &#123; String loginName = row.getString("loginName"); String userName = row.getString("userName"); String password = row.getString("password"); int sex = resultSet.getInt("sex"); System.out.println(loginName + "-" + userName + "-" + password + "-" + sex);&#125; 6、释放资源1数据库资源不关闭，其占用的内存不会被释放，徒耗资源，影响系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.runoob.test; import java.sql.*; public class MySQLDemo &#123; // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = "com.mysql.jdbc.Driver"; static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB"; // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL //static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver"; //static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC"; // 数据库的用户名与密码，需要根据自己的设置 static final String USER = "root"; static final String PASS = "123456"; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try&#123; // 注册 JDBC 驱动 Class.forName(JDBC_DRIVER); // 打开链接 System.out.println("连接数据库..."); conn = DriverManager.getConnection(DB_URL,USER,PASS); // 执行查询 System.out.println(" 实例化Statement对象..."); stmt = conn.createStatement(); String sql; sql = "SELECT id, name, url FROM websites"; ResultSet rs = stmt.executeQuery(sql); // 展开结果集数据库 while(rs.next())&#123; // 通过字段检索 int id = rs.getInt("id"); String name = rs.getString("name"); String url = rs.getString("url"); // 输出数据 System.out.print("ID: " + id); System.out.print(", 站点名称: " + name); System.out.print(", 站点 URL: " + url); System.out.print("\n"); &#125; // 完成后关闭 rs.close(); stmt.close(); conn.close(); &#125;catch(SQLException se)&#123; // 处理 JDBC 错误 se.printStackTrace(); &#125;catch(Exception e)&#123; // 处理 Class.forName 错误 e.printStackTrace(); &#125;finally&#123; // 关闭资源 try&#123; if(stmt!=null) stmt.close(); &#125;catch(SQLException se2)&#123; &#125;// 什么都不做 try&#123; if(conn!=null) conn.close(); &#125;catch(SQLException se)&#123; se.printStackTrace(); &#125; &#125; System.out.println("Goodbye!"); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F29%2Fmysql%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[一、原理索引一般以文件形式存在磁盘中（也可以存于内存中），存储的索引的原理大致概括为以空间换时间。数据库在未添加索引的时候进行查询默认的是进行全量搜索，也就是进行全局扫描，有多少条数据就要进行多少次查询，然后找到相匹配的数据就把他放到结果集中，直到全表扫描完。而建立索引之后，会将建立索引的KEY值放在一个n叉树上（BTree）。因为B树的特点就是适合在磁盘等直接存储设备上组织动态查找表，每次以索引进行条件查询时，会去树上根据key值直接进行搜索。 二、优点1建立索引的目的是加快对表中记录的查找或排序！ ① 建立索引的列可以保证行的唯一性，生成唯一的rowId ② 建立索引可以有效缩短数据的检索时间 ③ 建立索引可以加快表与表之间的连接 ④ 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序 三、缺点① 创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大 ② 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间 ③ 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长 四、创建创建12CREATE TABLE table_name[col_name data type][unique|fulltext][index|key][index_name](col_name[length])[asc|desc] unique|fulltext为可选参数，分别表示唯一索引、全文索引 index和key为同义词，两者作用相同，用来指定创建索引 col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择 index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值 length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 asc或desc指定升序或降序的索引值存储 直接创建索引1CREATE INDEX index_name ON table_name(col_name); 修改表结构的方式添加索引1ALTER TABLE table_name ADD INDEX index_name(col_name); 创建表的时候同时创建索引12345678CREATE TABLE `news` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` varchar(255) NOT NULL , `content` varchar(255) NULL , `time` varchar(20) NULL DEFAULT NULL , PRIMARY KEY (`id`), INDEX index_name (title(255))) 删除索引123DROP INDEX index_name ON table_name;alter table `表名` drop index 索引名;]]></content>
      <tags>
        <tag>sql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java编程规范]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F29%2Fjava%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、编程规约(一) 命名规约 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / DTO / VO / DAO 等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分，数组定义如下：String[] args; 反例：请勿使用String args[]的方式来定义 【强制】POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.mpp.util、类名为 MessageUtils（此规则参考 spring的框架结构） 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。 正例： 123public class OrderFactory;public class LoginProxy;public class ResourceObserver; 接口和实现类的命名有两套规则： 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。 正例：CacheServiceImpl 实现 CacheService 接口。 推荐】 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。 正例：AbstractTranslator 实现 Translatable。 【参考】各层命名规约： A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。 2） 获取多个对象的方法用 list 做前缀。 3） 获取统计值的方法用 count 做前缀。 4） 插入的方法用 save（推荐）或 insert 做前缀。 5） 删除的方法用 remove（推荐）或 delete 做前缀。 6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象：xxxDO，xxx 即为数据表名。 2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 3） 展示对象：xxxVO，xxx 一般为网页名称。 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 (二) 常量定义 【强制】不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。 反例： 12String key="Id#taobao_"+tradeId；cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1混淆，造成误解。 说明：Long a = 2l;写的是数字的 21，还是 Long 型的 2? (三) OOP 规约 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例：&quot;test&quot;.equals(object); 反例： object.equals(&quot;test&quot;); 说明：推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。 说明：对于 Integer var=?在-128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter 方法中，尽量不要增加业务逻辑，增加排查问题难度。 反例： 1234567public Integer getData()&#123; if(true) &#123; return data + 100; &#125; else &#123; return data - 100; &#125;&#125; 【推荐】循环体内，字符串的联接方式，使用 StringBuilder 的 append 方法进行扩展。 反例： 1234String str = "start";for(int i=0; i&lt;100; i++)&#123; str = str + "hello";&#125; 说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。 (四) 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行复杂的语句，以提高可读性。 正例： 12345//伪代码如下InputStream stream = file.open(fileName, "w"); if (stream != null) &#123; …&#125; 反例： 123if (file.open(fileName, "w") != null)) &#123; …&#125; 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 (五) 注释规约 【强制】所有的类都必须添加创建者信息。 【强制】所有的抽象方法（包括接口中的方法）必须要用 javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：如有实现和调用注意事项，请一并说明。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释，注意与代码对齐。 (六) 其它 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 【强制】获取当前毫秒数：System.currentTimeMillis();而不是 new Date().getTime(); 说明：如果想获取更加精确的纳秒级时间值，用 System.nanoTime。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。 二、异常日志(一) 异常处理 【强制】不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。 正例：if(obj != null) {...} 反例：try { obj.method() } catch(NullPointerException e){…} 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。说明：如果 JDK7，可以使用 try-with-resources 方法。 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 (二) 日志规约 .【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 123import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常、或者重要的错误信息。如非必要，请不要在此场景打出 error 级别，避免频繁报警。 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。纪录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 三、MYSQL 规约(一) 建表规约 【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 【强制】唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：uk_ 即 unique key；idx_ 即 index的简称。 【强制】小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【强制】表必备三字段：id, gmt_create, gmt_modified。 说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1；分表时改为从TDDL Sequence 取值，确保分表之间的全局唯一。gmt_create, gmt_modified 的类型均为date_time 类型。 【推荐】单表行数超过500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。反例：某业务三年总数据量才 2 万行，却分成 1024 张表，问：你为什么这么设计？答：分 1024张表，不是标配吗？ 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 正例：人的年龄用 unsigned tinyint（表示范围 0-255，人的寿命不会超过 255 岁）；海龟就必须是 smallint，但如果是太阳的年龄，就必须是 int；如果是所有恒星的年龄都加起来，那么就必须使用 bigint。 (二) SQL 规约 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 【强制】count(distinct col) 计算该列除 NULL 之外的不重复数量。注意 count(distinct col1, col2)如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为NULL，因此使用 sum()时需注意 NPE 问题。 正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 【强制】使用 ISNULL()来判断是否为 NULL 值。 注意：NULL 与任何值的直接比较都为 NULL。 说明： 1231） NULL&lt;&gt;NULL 的返回结果是 NULL，不是 false。2） NULL=NULL 的返回结果是 NULL，不是 true。3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】IDB 数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能提交执行。 【参考】所有的字符存储与表示，均以 utf-8 编码，那么字符计数方法注意： 说明： 123SELECT LENGTH(&quot;阿里巴巴&quot;)； 返回为 12SELECT CHARACTER_LENGTH(&quot;阿里巴巴&quot;)； 返回为 4如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码。 (三) 服务器规约 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。 正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）： 1net.ipv4.tcp_fin_timeout = 30 四、安全规约 【强制】用户敏感数据禁止直接展示，必须对展示数据脱敏。 说明：支付宝中查看个人手机号码会显示成：158****9119，隐藏中间 4 位，防止隐私泄露。 【强制】可被用户直接访问的功能必须进行权限控制校验。 说明：防止没有做权限控制就可随意访问、操作别人的数据，比如查看、修改别人的订单。 【强制】用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致： page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 正则输入源串拒绝服务 ReDOS 任意重定向 SQL 注入 Shell 注入 反序列化注入 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 【强制】Web 应用必须正确配置 Robots 文件，非 SEO URL 必须配置为禁止爬虫访问。 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup获取节点方法]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F24%2FJsoup%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JSoup应用的主要类123456781、org.jsoup.Jsoup类 Jsoup类是任何Jsoup程序的入口点，并将提供从各种来源加载和解析HTML文档的方法。2、org.jsoup.nodes.Document类 该类表示通过Jsoup库加载HTML文档。可以使用此类执行适用于整个HTML文档的操作。 3、org.jsoup.nodes.Element类HTML元素是由标签名称，属性和子节点组成。 使用Element类，您可以提取数据，遍历节点和操作HTML。 Jsoup类重要方法1234567891011static Connection connect(String url)创建并返回URL的连接static Document parse(File in, String charsetName)将指定的字符集文件解析成文档static Document parse(String html)将给定的html代码解析成文档static String clean(String bodyHtml, Whitelist whitelist)从输入HTML返回安全的HTML，通过解析输入HTML并通过允许的标签和属性的白名单进行过滤 获取兄弟节点123456789101112131415firstElementSibling()这个方法是获取节点的第一个兄弟节点，这个方法返回的是Element类型lastElementSibling():这个方法是获取节点的最后一个兄弟节点，返回的是Element类型previousElementSibling():这个方法是获取节点的上一个兄弟节点，返回的是Element类型previousSibling():这个方法也是获取节点的上一个兄弟节点，不过返回数据是Node类型nextElementSibling():这个方法是获取节点的下一个兄弟节点，返回的是Element类型nextSibling():这个方法同样是获取节点的下一个兄弟节点，返回数据是Node类型siblingElements():这个方法是获取节点的所有兄弟节点。返回的是List&lt;Element&gt;类型siblingNodes():这个方法也是获取节点的所有兄弟节点，但返回的是List&lt;Node&gt;类型 应用实例1234567// 从URL加载文档，使用Jsoup.connect()方法从URL加载HTMLtry &#123; Document document = Jsoup.connect("http://www.yiibai.com").get(); System.out.println(document.title());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 1234567// 使用Jsoup.parse()方法从文件加载HTMLtry &#123; Document document = Jsoup.parse(new File("D:/temp/index.html"), "utf-8"); System.out.println(document.title());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 123456789// 使用Jsoup.parse()方法从字符串加载HTMLtry &#123; String html = "&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;" + "&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"; Document document = Jsoup.parse(html); System.out.println(document.title());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 1234567891011// 要获取网页中的所有链接try &#123; Document document = Jsoup.parse(new File("D:/temp/index.html"), "utf-8"); Elements links = document.select("a[href]"); for (Element link: links) &#123; System.out.println("link : " + link.attr("href")); System.out.println("text : " + link.text()); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125;]]></content>
      <tags>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-GZIPOutputStream和GZIPInputStream]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F24%2Fjava-GZIPOutputStream%E5%92%8CGZIPInputStream%2F</url>
    <content type="text"><![CDATA[GZIPOutputStream类：压缩1public GZIPOutputStream(OutputStream out) throws IOException &#123;&#125; GZIPOutputStream只有一个方法用于压缩，就是带定长的write方法 1234567891011121314public static void compress(InputStream is, OutputStream os) throws Exception &#123; GZIPOutputStream gos = new GZIPOutputStream(os); int count; byte data[] = new byte[BUFFER]; while ((count = is.read(data, 0, BUFFER)) != -1) &#123; gos.write(data, 0, count); &#125; gos.finish(); gos.flush(); gos.close();&#125; 注：操作完成后，调用finish方法和flush方法 GZIPInputStream类：解压缩1public GZIPInputStream(InputStream in) throws IOException &#123;&#125; GZIPInputStream提供了一个带定长的read方法 123456789101112public static void decompress(InputStream is, OutputStream os) throws Exception &#123; GZIPInputStream gis = new GZIPInputStream(is); int count; byte data[] = new byte[BUFFER]; while ((count = gis.read(data, 0, BUFFER)) != -1) &#123; os.write(data, 0, count); &#125; gis.close();&#125; IO的体系1234567891011121.流的分类： 按照数据流向的不同：输入流 输出流 按照处理数据的单位的不同：字节流 字符流（处理的文本文件） 按照角色的不同：节点流（直接作用于文件的） 处理流 2.IO的体系 抽象基类 节点流（文件流） 缓冲流（处理流的一种） InputStream FileInputStream BufferedInputStream OutputStream FileOutputStream BufferedOutputStream Reader FileReader BufferedReader Writer FileWriter BufferedWriter]]></content>
      <tags>
        <tag>java</tag>
        <tag>GZIPOutputStream</tag>
        <tag>GZIPInputStream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-FileInputStream和FileOutputStream]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F24%2Fjava-FileInputStream%E5%92%8CFileOutputStream%2F</url>
    <content type="text"><![CDATA[FileInputStreamFileInputStream流被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等。 123456// 打开与File类对象代表的实际文件的链接来创建FileInputStream流对象public FileInputStream(File file) throws FileNotFoundException&#123;&#125;// 指定的字符串参数来创建File类对象，// 再与File对象所代表的实际路径建立链接创建FileInputStream流对象public FileInputStream(String name) throws FileNotFoundException 注：若File类对象的所代表的文件不存在、不是文件是目录、或者其他原因不能打开的话，则会抛出异常。 FileInputStream.read12345// 从输入流中读取一个字节返回int型变量，若到达文件末尾，则返回-1public int read() throws IOException// 从输入流中读取b.length个字节到字节数组中，返回读入缓冲区的总字节数，若到达文件末尾，则返回-1public int read(byte[] b) throws IOException FileOutputStream FileOutputStream流是指文件字节输出流，专用于输出原始字节流如图像数据等，其继承OutputStream类，拥有输出流的基本特性。 12345678// 创建FileOutputStream流以写入数据到File对象所代表的文件public FileOutputStream(File file) throws FileNotFoundException&#123;&#125;// 第二个参数为true，则字节将写入文件的末尾而不是开头public FileOutputStream(File file,boolean append) throws FileNotFoundException&#123;&#125;// 创建FileOutputStream流以写入数据到指定路径所代表的文件public FileOutputStream(String name) throws FileNotFoundException&#123;&#125; 注：若文件存在，但是是目录而不是文件，则会抛出FileNotFoundException异常 FileOutputStream.write12345678// 将指定的一个字节写入文件的输出流中，所以是一次写入一个字节public void write(int b) throws IOException// 将指定字节数组中的b.length个字节写入到输出流中public void write(byte[] b) throws IOException &#123;&#125;// 将从偏移量off开始的指定字节数组中的len个字节写入输出流中public void write(byte[] b,int off,int len) throws IOException&#123;&#125; 文件复制12345678910111213141516171819202122232425262728293031323334353637383940// 实现文件复制的方法public void copyFile(String src, String dest) &#123; // 1.提供读入、写出的文件 File file1 = new File(src); File file2 = new File(dest); // 2.提供相应的流 FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(file1); fos = new FileOutputStream(file2); // 3.实现文件的复制 byte[] b = new byte[1024]; int len; while ((len = fis.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>FileInputStream</tag>
        <tag>FileOutputStream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-File类]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F21%2Fjava-File%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[File文件类Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等。File对象代表磁盘中实际存在的文件和目录。通过以下构造方法创建一个File对象。 1234567891011# 通过给定的父抽象路径名和子路径名字符串创建一个新的File实例File(File parent, String child);# 通过将给定路径名字符串转换成抽象路径名来创建一个新 File 实例File(String pathname)# 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例File(String parent, String child) # 通过将给定的 file: URI 转换成一个抽象路径名来创建一个新的 File 实例File(URI uri) 实例方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public String getName()返回由此抽象路径名表示的文件或目录的名称public String getParent()返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 nullpublic File getParentFile()返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 nullpublic String getPath()将此抽象路径名转换为一个路径名字符串public boolean isAbsolute()测试此抽象路径名是否为绝对路径名public String getAbsolutePath()返回抽象路径名的绝对路径名字符串public boolean canRead()测试应用程序是否可以读取此抽象路径名表示的文件public boolean canWrite()测试应用程序是否可以修改此抽象路径名表示的文件public boolean exists()测试此抽象路径名表示的文件或目录是否存在public boolean isDirectory()测试此抽象路径名表示的文件是否是一个目录public boolean isFile()测试此抽象路径名表示的文件是否是一个标准文件public long lastModified()返回此抽象路径名表示的文件最后一次被修改的时间public long length()返回由此抽象路径名表示的文件的长度public boolean createNewFile() throws IOException当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件public boolean delete()删除此抽象路径名表示的文件或目录public void deleteOnExit()在虚拟机终止时，请求删除此抽象路径名表示的文件或目录public String[] list()返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组public String[] list(FilenameFilter filter)返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的public File[] listFiles()返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件public File[] listFiles(FileFilter filter)返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器public boolean mkdir()创建此抽象路径名指定的目录public boolean mkdirs()创建此抽象路径名指定的目录，包括创建必需但不存在的父目录public boolean renameTo(File dest)重新命名此抽象路径名表示的文件public boolean setLastModified(long time)设置由此抽象路径名所指定的文件或目录的最后一次修改时间public boolean setReadOnly()标记此抽象路径名指定的文件或目录，以便只可对其进行读操作public static File createTempFile(String prefix, String suffix, File directory) throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称public static File createTempFile(String prefix, String suffix) throws IOException在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称public int compareTo(File pathname)按字母顺序比较两个抽象路径名public int compareTo(Object o)按字母顺序比较抽象路径名与给定对象public boolean equals(Object obj)测试此抽象路径名与给定对象是否相等public String toString()返回此抽象路径名的路径名字符串 12345678910111213141516171819202122import java.io.File; public class DirList &#123; public static void main(String args[]) &#123; String dirname = "/java"; File f1 = new File(dirname); if (f1.isDirectory()) &#123; System.out.println("Directory of " + dirname); String s[] = f1.list(); for (int i = 0; i &lt; s.length; i++) &#123; File f = new File(dirname + "/" + s[i]); if (f.isDirectory()) &#123; System.out.println(s[i] + " is a directory"); &#125; else &#123; System.out.println(s[i] + " is a file"); &#125; &#125; &#125; else &#123; System.out.println(dirname + " is not a directory"); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java泛型]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F14%2Fjava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型 泛型的类型参数声明部分(&lt;T&gt; )可以包含一个或多个类型参数，参数间用逗号隔开。 类型参数只能代表引用型类型，不能是原始类型。 泛型方法 类型参数声明部分在方法返回类型之前 123456789// a 包含 bpublic static &lt;T&gt; Boolean arrayIncludes(T[] a, T[] b) &#123; for (T type : b) &#123; if (!Arrays.asList(a).contains(type)) &#123; return false; &#125; &#125; return true;&#125; 泛型类 类型参数声明部分在类名之后 123456public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125;&#125; 泛型接口 类型参数声明部分在接口名之后 123public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型通配符 ?通配符只有在修饰一个变量时会用到，使用它可方便地引用包含了多种类型的泛型 &lt;? extends T&gt;类型的上界，表示类型参数(?)可能是T或是T的子类 &lt;? super T&gt;类型下界，表示类型参数(?)是T的超类型（父类型），直至Object 12345678910111213141516// 无限定通配符// List&lt;?&gt;等同于 List&lt;? extends Object&gt;public static void getData(List&lt;?&gt; data) &#123; System.out.println("data :" + data.get(0));&#125;// 子类限定通配符public static void getNumberData(List&lt;? extends Number&gt; data) &#123; System.out.println("data :" + data.get(0));&#125;// 父类限定通配符// 只能接受Number及其三层父类类型public static void getNumberData(List&lt;? super Number&gt; data) &#123; System.out.println("data :" + data.get(0));&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-ElasticSearch增删改查]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F05%2FJava-ElasticSearch%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[Index(增加）12345678910111213141516171819202122232425262728public class IndexTest &#123; public static void main(String[] argv) &#123; Settings settings = ImmutableSettings.settingsBuilder() //指定集群名称 .put("cluster.name", "elasticsearch") //探测集群中机器状态 .put("client.transport.sniff", true).build(); /* * 创建客户端，所有的操作都由客户端开始，这个就好像是JDBC的Connection对象 * 用完记得要关闭 */ Client client = new TransportClient(settings) .addTransportAddress(new InetSocketTransportAddress("192.168.1.106", 9300)); String json = ESUtils.toJson(new LogModel()); //在这里创建我们要索引的对象 IndexResponse response = client.prepareIndex("twitter", "tweet") //必须为对象单独指定ID .setId("1") .setSource(json) .execute() .actionGet(); //多次index这个版本号会变 System.out.println("response.version():" + response.version()); client.close(); &#125;&#125; delete(删除）1234567891011121314151617181920212223public class DeleteTest &#123; public static void main(String[] argv) &#123; Settings settings = ImmutableSettings.settingsBuilder() //指定集群名称 .put("cluster.name", "elasticsearch") //探测集群中机器状态 .put("client.transport.sniff", true).build(); /* * 创建客户端，所有的操作都由客户端开始，这个就好像是JDBC的Connection对象 * 用完记得要关闭 */ Client client = new TransportClient(settings) .addTransportAddress(new InetSocketTransportAddress("192.168.1.106", 9300)); //在这里创建我们要索引的对象 DeleteResponse response = client.prepareDelete("twitter", "tweet", "1") .execute() .actionGet(); System.out.println(response.getId()); System.out.println(ESUtils.toJson(response.getHeaders())); &#125;&#125; GET(查询）1234567891011121314151617181920212223public class GetTest &#123; public static void main(String[] argv) &#123; Settings settings = ImmutableSettings.settingsBuilder() //指定集群名称 .put("cluster.name", "elasticsearch") //探测集群中机器状态 .put("client.transport.sniff", true).build(); /* * 创建客户端，所有的操作都由客户端开始，这个就好像是JDBC的Connection对象 * 用完记得要关闭 */ Client client = new TransportClient(settings) .addTransportAddress(new InetSocketTransportAddress("192.168.1.106", 9300)); //在这里创建我们要索引的对象 GetResponse response = client.prepareGet("twitter", "tweet", "1") .execute() .actionGet(); System.out.println("response.getId():" + response.getId()); System.out.println("response.getSourceAsString():" + response.getSourceAsString()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-PostConstruct和PreConstruct]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F05%2FJava-PostConstruct%E5%92%8CPreConstruct%2F</url>
    <content type="text"><![CDATA[从Java EE5规范开始，Servlet增加了两个影响Servlet生命周期的注解（Annotation）：@PostConstruct和@PreConstruct。这两个注解被用来修饰一个非静态的void()方法，而且这个方法不能有抛出异常声明。 1234@PostConstructpublic void someMethod()&#123; ...&#125; 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法。被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。 被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>PostConstruct</tag>
        <tag>PreConstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Scope注解]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F05%2FSpring-Scope%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring中scope是一个非常关键的概念，简单说就是对象在spring容器（IOC容器）中的生命周期，也可以理解为对象在spring容器中的创建方式。scope有5种取值：singleton、prototype、request、session 和 global session。 singleton单例模式，全局有且仅有一个实例 prototype原型模式，每次获取Bean的时候会有一个新的实例 request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session类似于标准的HTTP Session作用域]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Bean注解]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F05%2FSpring-Bean%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[管理BeanSpring帮助我们管理Bean分为两个部分，一个是注册Bean，一个装配Bean。完成这两个动作有三种方式，一种是使用自动配置的方式、一种是使用JavaConfig的方式，一种就是使用XML配置的方式。 @Bean 的用法 - JavaConfig@Bean是一个方法级别上的注解，主要用在@Configuration注解的类里，也可以用在@Component注解的类里。 下面是@Configuration里的一个例子 1234567@Configurationpublic class AppConfig &#123; @Bean public TransferService transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 这个配置就等同于之前在xml里的配置 123&lt;beans&gt; &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;&lt;/beans&gt; 接受生命周期的回调任何使用@Bean定义的bean，也可以执行生命周期的回调函数，类似@PostConstructand @PreDestroy的方法。用法如下 123456789101112131415161718192021222324public class Foo &#123; public void init() &#123; // initialization logic &#125;&#125;public class Bar &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean(initMethod = "init") public Foo foo() &#123; return new Foo(); &#125; @Bean(destroyMethod = "cleanup") public Bar bar() &#123; return new Bar(); &#125;&#125; 默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法，如果你不想执行该方法，则添加@Bean(destroyMethod=””)来防止出发销毁方法 指定bean的scope你能够使用@Scope注解来指定使用@Bean定义的bean 12345678@Configurationpublic class MyConfiguration &#123; @Bean @Scope("prototype") public Encryptor encryptor() &#123; // ... &#125;&#125; 自定义bean的命名默认情况下bean的名称和方法名称相同，你也可以使用name属性来指定 12345678910111213141516@Configurationpublic class AppConfig &#123; @Bean(name = "myFoo") public Foo foo() &#123; return new Foo(); &#125;&#125;@Configurationpublic class AppConfig &#123; // 别名 @Bean(name = &#123; "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" &#125;) public DataSource dataSource() &#123; // instantiate, configure and return DataSource bean... &#125;&#125; @component - 自动配置@Component（和@Service和@Repository）用于自动检测和使用类路径扫描自动配置bean。注释类和bean之间存在隐式的一对一映射（即每个类一个bean）。这种方法对需要进行逻辑处理的控制非常有限，因为它纯粹是声明性的。 12345678910111213@Componentpublic class Student &#123; private String name = "lkm"; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 注：@component相当于配置文件中的&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;。 @Component、@Bean都可以通过@Resource和@Autowired装配。如果你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component注解的，因此就不能使用自动化装配的方案了，但是我们可以使用@Bean，当然也可以使用XML配置。]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Autowired和Resource]]></title>
    <url>%2FendBlogs%2F2019%2F06%2F05%2FSpring-Autowired%E5%92%8CResource%2F</url>
    <content type="text"><![CDATA[@Resource和@Autowired@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。 @Autowired@Autowired为Spring提供的注解，需要导入org.springframework.beans.factory.annotation.Autowired，只按照byType注入。 12345678910public class TestServiceImpl &#123; // 下面两种@Autowired只要使用一种即可 @Autowired private UserDao userDao; // 用于字段上 @Autowired(required = false) public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上 this.userDao = userDao; &#125;&#125; @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。 @Resource@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type。 如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 12345678910public class TestServiceImpl &#123; // 下面两种@Resource只要使用一种即可 @Resource(name="userDao") private UserDao userDao; // 用于字段上 @Resource(name="userDao") public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上 this.userDao = userDao; &#125;&#125;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Autowired</tag>
        <tag>Resource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC-forward和redirect]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F31%2FspringMVC-forward%E5%92%8Credirect%2F</url>
    <content type="text"><![CDATA[一、跳转1234567891011121314151617181920212223242526272829303132import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class Login&#123; /**转发**/ @RequestMapping("/login.do") public String login(HttpServletRequest request, HttpServletResponse response)&#123; request.setAttribute("message", "hello"); return "forward:/index.do"; // forward在跳转后可以取到message值 &#125; @RequestMapping("/index.do") public String index(HttpServletRequest request, HttpServletResponse response)&#123; return "welcome"; &#125; /**重定向**/ @RequestMapping("/logout.do") public String logout(HttpServletRequest request, HttpServletResponse response)&#123; request.setAttribute("message", "hello"); return "redirect:/register.do"; // redirect在跳转后无法取到message值 &#125; @RequestMapping("/register.do") public String register(HttpServletRequest request, HttpServletResponse response)&#123; return "register"; &#125;&#125; 注：forward跳转后地址栏URL不会改变而redirect会改变 二、区别redirect方式相当于”response.sendRedirect()”. 这种方式浏览器地址栏最后显示的路径是转发后的新的路径。工作方式是这样的, 服务器端会首先发一个response给浏览器, 然后浏览器收到这个response后再发一个requeset给服务器, 然后服务器发新的response给浏览器. 这时页面收到的request对象是重新从浏览器发来的。这种方式的特点： 在转发前后有两个不同的request对象,转发前后的两个控制器在request上的参数(request.getParameter())和request属性(request.getAttribute())不能共享; 如果转发前后的两个控制器都配置在spring 拦截器范围内,这样拦截器会拦截前后两个request,即会拦截两次; 最后返回到浏览器后,因为地址栏显示的是转发后的url,所以刷新页面时只会执行后面的url映射的控制器. forward方式相当于request.getRequestDispatcher().forward(request,response)，这种方式的外部特征是浏览器地址显示的路径是转发前的路径。工作方式是这样,forward 发生在服务器内部,在前一个控制器处理完毕后,直接进入下一个控制器处理, 并将最后的response发给浏览器. 这种方式的特点： 转发前后是同一个request,后一个控制器可共享前一个控制器的参数与属性; 因为是同一个request,拦截器只会拦截前一个url,如果前一个url在映射时未配置到拦截器拦截，则拦截后一个url，即只拦截一次; 最后返回到浏览器后,因为地址栏显示的是转发前的url,所以刷新页面时会依次执行前后两个控制器.]]></content>
      <tags>
        <tag>spring</tag>
        <tag>forward</tag>
        <tag>redirect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux分区与目录]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F29%2Flinux%E5%88%86%E5%8C%BA%E4%B8%8E%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[分区和目录Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区）。 Linux的文件结构是单个的树状结构。 每次安装系统的时候我们都会进行分区，Linux下磁盘分区和目录的关系如下： 任何一个分区都必须挂载到某个目录上 目录是逻辑上的区分，分区是物理上的区分 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区 123456[root@localhost ~]# df -lhFilesystem 容量 已用 可用 已用% 挂载点/dev/sda3 6.4G 4.8G 1.3G 80% //dev/sda1 99M 8.4M 86M 9% /bootnone 494M 0 494M 0% /dev/shm/dev/hdc 105M 105M 0 100% /media/cdrom ①左边的信息代表了磁盘文件系统分区：/dev/sda1, /dev/sda3等 ②右边的信息分别代表了容量，已用空间，可用空间，百分比，挂载点 磁盘占满磁盘占满，会导致nginx无法缓存文件，报net::ERR_CONTENT_LENGTH_MISMATCH错误。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-HandlerMethodArgumentResolver]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F28%2Fspringboot-HandlerMethodArgumentResolver%2F</url>
    <content type="text"><![CDATA[自定义参数注解（解析）在controller的请求方法中，有自定义的参数注解@UserInfo 123456@RequestMapping(value = "/filter/test2")public String test2 (@RequestBody String o, @UserInfo UserInfoVo userInfoVo) &#123; System.out.println("Controller中获取的请求数据：" + o); System.out.println("自定义注解UserInfo的值：" + userInfoVo); return "OK";&#125; 实现参数解析器如下：12345678910111213141516171819202122232425public class UserInfoMethodArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; System.out.println("login" + parameter.hasParameterAnnotation(UserInfo.class)); return parameter.hasParameterAnnotation(UserInfo.class); &#125; @Override public Object resolveArgument( MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory ) throws Exception &#123; HttpServletRequest request = null; request = webRequest.getNativeRequest(HttpServletRequest.class); String str = HttpHelper.getBodyString(request); System.out.println("参数解析器login获取的请求数据：" + str); UserInfoVo u = new UserInfoVo(); u.setName("tom"); u.setAge(18); return u; &#125;&#125; WebMvcConfigurerAdapter中实现顺序如下：12345@Overridepublic void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123; super.addArgumentResolvers(argumentResolvers); argumentResolvers.add(new UserInfoMethodArgumentResolver());&#125; 自定义转换器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.datastory.epsm;import com.datastory.epsm.utils.JsonUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.BeanUtils;import org.springframework.core.MethodParameter;import org.springframework.util.StringUtils;import org.springframework.web.bind.support.WebDataBinderFactory;import org.springframework.web.context.request.NativeWebRequest;import org.springframework.web.context.request.ServletWebRequest;import org.springframework.web.method.support.HandlerMethodArgumentResolver;import org.springframework.web.method.support.ModelAndViewContainer;import org.springframework.web.servlet.HandlerMapping;import javax.servlet.http.HttpServletRequest;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Map;/** * 自定义转换器 */public class JsonMethodHandleResolver implements HandlerMethodArgumentResolver &#123; private static final Logger LOGGER = LoggerFactory.getLogger(JsonMethodHandleResolver.class); public boolean supportsParameter(MethodParameter methodParameter) &#123; LOGGER.info("请求类型：" + methodParameter.getParameterType()); return true; &#125; public Object resolveArgument ( MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory ) throws Exception &#123; LOGGER.info("--------------------resolveArgument----------------------"); return this.handleResolver(methodParameter, nativeWebRequest); &#125; private Object handleResolver( MethodParameter methodParameter, NativeWebRequest nativeWebRequest ) &#123; String requestBody = this.getParameter(methodParameter, nativeWebRequest); //如果是简单类型 if (BeanUtils.isSimpleProperty(methodParameter.getParameterType())) &#123; return requestBody; &#125; //如果是json格式 return JsonUtils.toObject(requestBody, methodParameter.getParameterType()); &#125; private Map&lt;String, String&gt; getPathVariables(NativeWebRequest webRequest) &#123; HttpServletRequest httpServletRequest = webRequest.getNativeRequest(HttpServletRequest.class); return (Map&lt;String, String&gt;) httpServletRequest.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE); &#125; private String getParameter( MethodParameter methodParameter, NativeWebRequest nativeWebRequest ) &#123; //判断类型是否是简单类型 String requestBody; if (BeanUtils.isSimpleProperty(methodParameter.getParameterType())) &#123; requestBody = nativeWebRequest.getParameter(methodParameter.getParameterName()); if (StringUtils.isEmpty(requestBody)) &#123; requestBody = getPathVariables(nativeWebRequest).get(methodParameter.getParameterName()); &#125; LOGGER.info("传入参数:&#123;&#125;=&#123;&#125;", methodParameter.getParameterName(), requestBody); &#125; else &#123; String pathInfo = ((ServletWebRequest) nativeWebRequest).getRequest().getPathInfo(); requestBody = this.getRequestBody(nativeWebRequest); LOGGER.info("传入参数:&#123;&#125;", requestBody); &#125; return requestBody; &#125; private String getRequestBody(NativeWebRequest webRequest) &#123; HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); StringBuilder out = new StringBuilder(); String y; try &#123; BufferedReader in = new BufferedReader(new InputStreamReader(servletRequest.getInputStream(), "UTF-8")); while ((y = in.readLine()) != null) &#123; out.append(y); &#125; in.close(); &#125; catch (IOException e) &#123; LOGGER.error(e.getMessage()); &#125; return out.toString(); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
        <tag>HandlerMethodArgumentResolver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chkconfig]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F27%2Flinux-chkconfig%2F</url>
    <content type="text"><![CDATA[chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息，谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号（ln）连接。 12chkconfig [--add][--del][--list][系统服务]chkconfig [--level &lt;等级代号&gt;][系统服务][on/off/reset] 参数用法–add：增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。 –del：删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。 –level&lt;等级代号&gt;：指定读系统服务要在哪一个执行等级中开启或关毕。 12345678910111213等级0表示：表示关机等级1表示：单用户模式等级2表示：无网络连接的多用户命令行模式等级3表示：有网络连接的多用户命令行模式等级4表示：不可用等级5表示：带图形界面的多用户模式等级6表示：重新启动 注： 对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init不会重新启动已经启动的服务，也不会再次去停止已经停止的服务 on和off开 关，系统默认只对运行级3，4，5有效，但是reset可以对所有运行级有效 由于现在的Linux系统安装完后就运行在第5个级别，即系统启动后直接进入图形界面，而不用在字符模式下登录后用startx或者xinit 来起动图形界面]]></content>
      <tags>
        <tag>linux</tag>
        <tag>chkconfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-开机自启动服务]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F27%2Flinux-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[创建脚本测试1[root@anuo ~]# vim anuo.sh --创建个脚本 1234# !/bin/bash# chkconfig: 35 53 88 --35是指定3和5级别启动、53是启动的顺序、88是关闭的顺序# description: is anuo --可以随便说点啥， 最好的说明这个脚本的用途啥的。echo Anuo Come on --脚本的内容 1234[root@anuo ~]# mv anuo.sh /etc/init.d/ --必须将脚本放到/etc/init.d/目录下[root@anuo ~]# chmod +x /etc/init.d/anuo.sh --别忘记给脚本加执行权限[root@anuo ~]# chkconfig --add anuo.sh --添加开机自启动[root@anuo ~]# chkconfig --list | grep anuo.sh --可以看到开启级别的启动 1anuo.sh 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭 小测试12[root@anuo ~]# ll /etc/rc.d/rc3.d/|grep anuo.shlrwxrwxrwx 1 root root 17 5月 12 19:10 S53anuo.sh -&gt; ../init.d/anuo.sh 查看到3级别启动的文件里一个S53anuo.sh的链接文件 （S表示开启，53也就对应了配置文件里的53的启动的顺序） 123[root@anuo ~]# chkconfig anuo.sh off --设置开机不启动[root@anuo ~]# ll /etc/rc.d/rc3.d/|grep anuo.sh lrwxrwxrwx 1 root root 17 5月 12 19:30 K88anuo.sh -&gt; ../init.d/anuo.sh 再次查看发现S53anuo.sh的链接文件没有了，却多了个K88anuo.sh的链接文件 （K表示不开启 88对应的是配置文件里的88关闭的顺序） 小结： 要把脚本放到/etc/init.d/目录下并给执行权限。 当chkconfig设置开机自启动时候会在相应的启动级别的文件里创建S开头的链接文件，同时会删除以K开头的对应的链接文件，反之也亦然。 nginx开机启动脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0nginx="/usr/sbin/nginx"prog=$(basename $nginx)NGINX_CONF_FILE="/etc/nginx/nginx.conf"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep "configure arguments:.*--user=" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -` if [ -n "$user" ]; then if [ -z "`grep $user /etc/passwd`" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac]]></content>
      <tags>
        <tag>linux</tag>
        <tag>chkconfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaMail]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F27%2FJavaMail%2F</url>
    <content type="text"><![CDATA[一、RFC882文档简单说明RFC882文档规定了如何编写一封简单的邮件(纯文本邮件)，一封简单的邮件包含邮件头和邮件体两个部分，邮件头和邮件体之间使用空行分隔。 邮件头包含的内容有： from字段：用于指明发件人 to字段：用于指明收件人 subject字段：用于说明邮件主题 cc字段：抄送，将邮件发送给收件人的同时抄送给另一个收件人，收件人可以看到邮件抄送给了谁 bcc字段：密送，将邮件发送给收件人的同时将邮件秘密发送给另一个收件人，收件人无法看到邮件密送给了谁 邮件体指的就是邮件的具体内容 二、MIME协议简单介绍MIME协议是对RFC822文档的升级和补充，它描述了如何生产一封复杂的邮件。通常我们把MIME协议描述的邮件称之为MIME邮件。MIME协议描述的数据称之为MIME消息。对于一封复杂邮件，如果包含了多个不同的数据，MIME协议规定了要使用分隔线对多段数据进行分隔，并使用Content-Type头字段对数据的类型、以及多个数据之间的关系进行描述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.FileOutputStream;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Message;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;public class Sendmail &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Properties prop = new Properties(); prop.setProperty("mail.host", "smtp.sohu.com"); prop.setProperty("mail.transport.protocol", "smtp"); prop.setProperty("mail.smtp.auth", "true"); //1、创建session Session session = Session.getInstance(prop); //开启Session的debug模式，这样就可以查看到程序发送Email的运行状态 session.setDebug(true); //2、通过session得到transport对象 Transport ts = session.getTransport(); //3、连上邮件服务器 ts.connect("smtp.sohu.com", "gacl", "邮箱密码"); //4、创建邮件 Message message = createMixedMail(session); //5、发送邮件 ts.sendMessage(message, message.getAllRecipients()); ts.close(); &#125; /** * @param session * @return * @throws Exception */ public static MimeMessage createMixedMail(Session session) throws Exception &#123; //创建邮件 MimeMessage message = new MimeMessage(session); //设置邮件的基本信息 message.setFrom(new InternetAddress("gacl@sohu.com")); message.setRecipient( Message.RecipientType.TO, new InternetAddress("xdp_gacl@sina.cn") ); message.setSubject("带附件和带图片的的邮件"); //正文 MimeBodyPart text = new MimeBodyPart(); text.setContent("图片&lt;img src='cid:aaa.jpg'&gt;","text/html;charset=UTF-8"); //图片 MimeBodyPart image = new MimeBodyPart(); image.setDataHandler(new DataHandler(new FileDataSource("src\\3.jpg"))); image.setContentID("aaa.jpg"); //附件1 MimeBodyPart attach = new MimeBodyPart(); DataHandler dh = new DataHandler(new FileDataSource("src\\4.zip")); attach.setDataHandler(dh); attach.setFileName(dh.getName()); //附件2 MimeBodyPart attach2 = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource("src\\波子.zip")); attach2.setDataHandler(dh2); attach2.setFileName(MimeUtility.encodeText(dh2.getName())); // 中文乱码 //描述关系:正文和图片 MimeMultipart mp1 = new MimeMultipart(); mp1.addBodyPart(text); mp1.addBodyPart(image); mp1.setSubType("related"); //描述关系:正文和附件 MimeMultipart mp2 = new MimeMultipart(); mp2.addBodyPart(attach); mp2.addBodyPart(attach2); //代表正文的bodypart MimeBodyPart content = new MimeBodyPart(); content.setContent(mp1); mp2.addBodyPart(content); mp2.setSubType("mixed"); message.setContent(mp2); message.saveChanges(); message.writeTo(new FileOutputStream("E:\\MixedMail.eml")); //返回创建好的的邮件 return message; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch聚合]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E8%81%9A%E5%90%88%2F</url>
    <content type="text"><![CDATA[Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。 普通嵌套 123456789101112131415161718192021222324GET /cars/transactions/_search&#123; "aggs": &#123; "colors": &#123; "terms": &#123; "field": "color" &#125;, "aggs": &#123; // avg_price桶 "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, // 与avg_price桶并列 "make": &#123; "terms": &#123; "field": "make" &#125; &#125; &#125; &#125; &#125;&#125; nested嵌套 1234567891011121314151617181920212223242526272829POST ds-epsm-all/post/_search&#123; "aggs": &#123; // 情感 "sentiment": &#123; "nested": &#123; "path": "obj_info" &#125;, "aggs": &#123; // 情感-对象（专题） "name": &#123; "terms": &#123; "field": "obj_info.obj_name", "size": 1 &#125;, "aggs": &#123; // 情感-类型（正中负） "sentiment": &#123; "terms": &#123; "field": "obj_info.obj_sentiment", "size": 10 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 过滤功能 123456789101112131415161718192021GET /cars/transactions/_search&#123; "aggs":&#123; "recent_sales": &#123; "filter": &#123; "range": &#123; "sold": &#123; "from": "now-1M" &#125; &#125; &#125;, "aggs": &#123; "average_price":&#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; 指定聚合值 1234567891011121314GET ds-epsm-all/post/_search&#123; "aggs": &#123; "subject": &#123; "terms": &#123; "field": "category_tags", // 包括 "include": ["母品牌", "伊利股份"], // 排除 "exclude": ["蒙牛"], &#125; &#125; &#125;&#125; top_hits 1234567891011121314151617GET ds - epsm - all / post / _search &#123; "aggs": &#123; "similar": &#123; "top_hits": &#123; "size": 3, "sort": [ &#123; "similar_doc_count": &#123; "order": "desc" &#125; &#125; ] &#125; &#125; &#125;&#125; 按时间统计 123456789101112GET /cars/transactions/_search&#123; "aggs": &#123; "sales": &#123; "date_histogram": &#123; "field": "sold", "interval": "month", "format": "yyyy-MM-dd" &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch排序]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在 Elasticsearch 中， 相关性得分 由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。 简单指定字段排序 1&quot;sort&quot;: &quot;number_of_children&quot; 字段将会默认升序排序 ，而按照 _score 的值进行降序排序 按照字段的值排序 123456789GET /_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 1 &#125;&#125; &#125; &#125;, &quot;sort&quot;: &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;&#125; 多级排序 12345678910111213GET /_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;manage text search&quot; &#125;&#125;, &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 2 &#125;&#125; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;, &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125; ]&#125; 排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 sort 值完全相同时才会按照第二个条件进行排序，以此类推。 多值（数组）字段排序 123456&quot;sort&quot;: &#123; &quot;dates&quot;: &#123; &quot;order&quot;: &quot;asc&quot;, &quot;mode&quot;: &quot;min&quot; &#125;&#125; 字段有多个值的排序，这些值并没有固有的顺序。对于数字或日期，你可以将多值字段减为单值，这可以通过使用 min 、 max 、 avg 或是 sum 排序模式。]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch字段类型]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字段类型 简单域类型： 字符串: string 整数 : byte, short, integer, long 浮点数: float, double 布尔型: boolean 日期: date 对象类型 12345678910111213&#123; &quot;tweet&quot;: &quot;Elasticsearch is very flexible&quot;, &quot;user&quot;: &#123; &quot;id&quot;: &quot;@johnsmith&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;age&quot;: 26, &quot;name&quot;: &#123; &quot;full&quot;: &quot;John Smith&quot;, &quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Smith&quot; &#125; &#125;&#125; 12345678910111213141516171819202122232425&#123; &quot;gb&quot;: &#123; &quot;tweet&quot;: &#123; &quot;properties&quot;: &#123; &quot;tweet&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;gender&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;full&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;first&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;last&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 数组类型 在ElasticSearch中，没有专门的数组（Array）数据类型。但是，在默认情况下，任意一个字段都可以包含0或多个值，这意味着每个字段默认都是数组类型。不过，数组类型的各个元素值的数据类型必须相同。 在ElasticSearch中，数组是开箱即用的（out of box），不需要进行任何配置，就可以直接使用。 详细类型]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>字段类型</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-FastJson]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F13%2Fjava-FastJson%2F</url>
    <content type="text"><![CDATA[####简单说明 FastJson对于json格式字符串的解析主要用到了下面三个类： JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换 JSONObject：fastJson提供的json对象 JSONArray：fastJson提供json数组对象 用法首先定义三个json格式的字符串 12345678//json字符串-简单对象型private static final String JSON_OBJ_STR = "&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;";//json字符串-数组类型private static final String JSON_ARRAY_STR = "[&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;,&#123;\"studentName\":\"lucy\",\"studentAge\":15&#125;]";//复杂格式json字符串private static final String COMPLEX_JSON_STR = "&#123;\"teacherName\":\"crystall\",\"teacherAge\":27,\"course\":&#123;\"courseName\":\"english\",\"code\":1270&#125;,\"students\":[&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;,&#123;\"studentName\":\"lucy\",\"studentAge\":15&#125;]&#125;"; json字符串-简单对象型与JSONObject之间的转换123456789101112131415161718192021222324252627282930/** * json字符串-简单对象型到JSONObject的转换 */@Testpublic void testJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") );&#125;/** * JSONObject到json字符串-简单对象型的转换 */@Testpublic void testJSONObjectToJSONStr() &#123; //已知JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); // 第一种方式 String jsonString = JSONObject.toJSONString(jsonObject); // 第二种方式 //String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; json字符串(数组类型)与JSONArray之间的转换1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * json字符串-数组类型到JSONArray的转换 */@Testpublic void testJSONStrToJSONArray() &#123; JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历方式1 int size = jsonArray.size(); for (int i = 0; i &lt; size; i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") ); &#125; //遍历方式2 for (Object obj: jsonArray) &#123; JSONObject jsonObject = (JSONObject) obj; System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") ); &#125;&#125;/** * JSONArray到json字符串-数组类型的转换 */@Testpublic void testJSONArrayToJSONStr() &#123; //已知JSONArray,目标要转换为json字符串 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式 String jsonString = JSONArray.toJSONString(jsonArray); // 第二种方式 //String jsonString = jsonArray.toJSONString(jsonArray); System.out.println(jsonString);&#125; 复杂json格式字符串与JSONObject之间的转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 复杂json格式字符串到JSONObject的转换 */@Testpublic void testComplexJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); String teacherName = jsonObject.getString("teacherName"); Integer teacherAge = jsonObject.getInteger("teacherAge"); System.out.println( "teacherName: " + teacherName + " teacherAge: " + teacherAge ); JSONObject jsonObjectcourse = jsonObject.getJSONObject("course"); //获取JSONObject中的数据 String courseName = jsonObjectcourse.getString("courseName"); Integer code = jsonObjectcourse.getInteger("code"); System.out.println("courseName: " + courseName + " code: " + code); JSONArray jsonArraystudents = jsonObject.getJSONArray("students"); //遍历JSONArray for (Object object: jsonArraystudents) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString("studentName"); Integer studentAge = jsonObjectone.getInteger("studentAge"); System.out.println( "studentName: " + studentName + " studentAge: " + studentAge ); &#125;&#125;/** * 复杂JSONObject到json格式字符串的转换 */@Testpublic void testJSONObjectToComplexJSONStr() &#123; //复杂JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式 //String jsonString = JSONObject.toJSONString(jsonObject); //第二种方式 String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125;]]></content>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Scheduled]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F12%2FSpring-Scheduled%2F</url>
    <content type="text"><![CDATA[@Scheduled注解参数fixedDelay上一次执行完毕时间点之后多长时间再执行 12 //上一次执行完毕时间点之后5秒再执行@Scheduled(fixedDelay = 5000) fixedRate上一次开始执行时间点之后多长时间再执行 12//上一次开始执行时间点之后5秒再执行@Scheduled(fixedRate = 5000) initialDelay第一次延迟多长时间后再执行 12//第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次@Scheduled(initialDelay=1000, fixedRate=5000) cron该参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。cron表达式语法： 1[秒] [分] [时] [日] [月] [周] [年] 注：[年]不是必须的域，可以省略[年] 序号 说明 必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 / JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 1970-2099 , - * / 通配符说明: * 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ? - 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。 , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份， 如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。 如果在”L”前加上数字，则表示该数据的最后一个。 例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五” W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。 如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。 # 序号，表示每月的第几个周几。 例如在周字段上设置”6#3”表示在每月的第三个周六 注意如果指定”#5”，正好第五周没有周六，则不会触发该配置 如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发 1234567891011121314151617181920212223242526// 每隔5秒执行一次*/5 * * * * ?// 每隔1分钟执行一次0 */1 * * * ?// 每天23点执行一次0 0 23 * * ?// 每天凌晨1点执行一次0 0 1 * * ?// 每月1号凌晨1点执行一次0 0 1 1 * ?// 每月最后一天23点执行一次0 0 23 L * ?// 每周星期天凌晨1点实行一次0 0 1 ? * L// 在26分、29分、33分执行一次0 26,29,33 * * * ?// 每天的0点、13点、18点、21点都执行一次0 0 0,13,18,21 * * ?]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Scheduled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遍历]]></title>
    <url>%2FendBlogs%2F2019%2F04%2F10%2Fjava%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Collection对象-遍历器1234567/* 建立一个Collection */String[] strings = &#123; "A"， "B"， "C"， "D" &#125;;Collection stringList = java.util.Arrays.asList(strings);for (Iterator itr = stringList.iterator(); itr.hasNext();) &#123; Object str = itr.next(); System.out.println(str);&#125; for(:)循环1234String[] strings = &#123; "A"， "B"， "C"， "D" &#125;;Collection list = java.util.Arrays.asList(strings);for (String str: list) &#123; System.out.println(str);&#125;// for (String str: strings) &#123; System.out.println(str);&#125; 遍历Map1234567891011Map &lt; Integer, Integer &gt; map = new HashMap &lt; Integer, Integer &gt; ();//遍历map中的键 for (Integer key: map.keySet()) &#123; System.out.println("Key = " + key);&#125;//遍历map中的值 for (Integer value: map.values()) &#123; System.out.println("Value = " + value);&#125; 数组转Set或List123456789101112// CollectionUtils.addAll()import org.apache.commons.collections.CollectionUtils; String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = new ArrayList();Set strSet = new HashSet();CollectionUtils.addAll(strList, strArray); CollectionUtils.addAll(strSet, strArray);// Arrays.asList()import java.util.Arrays;String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = Arrays.asList(strArray); Set和List转数组12345678910// Collection的toArray()方法// Object[] toArray();String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = Arrays.asList(strArray);Object[] obj = strList.toArray();for (int i = 0; i &lt; obj.length; i++) &#123; String str = (String) obj[i]; System.out.println(str);&#125;]]></content>
      <tags>
        <tag>for</tag>
        <tag>Collection</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F29%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12Runnable noArguments = () -&gt; System.out.println("Hello World");// Runnable 12ActionListener oneArgument = event -&gt; System.out.println("button clicked");// ActionListener 12345Runnable multiStatement = () -&gt; &#123; System.out.print("Hello"); System.out.println(" World");&#125;;// Runnable 12BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;// BinaryOperator 12BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;// BinaryOperator 注：Lambda 表达式都可以扩写为原始的匿名类形式]]></content>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java匿名内部类]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F29%2Fjava%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[匿名内部类123new 父类构造器（参数列表）| 实现接口（）&#123; //匿名内部类的类体部分 &#125; 12345button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("button clicked"); &#125;&#125;); 使用匿名内部类时，我们必须且只能继承一个类或者实现一个接口 匿名内部类中是不能定义构造函数的 匿名内部类中不能存在任何的静态成员变量和静态方法 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 匿名内部类初始化利用构造代码块能够达到为匿名内部类创建一个构造器的效果 123456789101112131415161718return new InnerClass() &#123; int age_; String name_; //构造代码块完成初始化工作 &#123; if (0 &lt; age &amp;&amp; age &lt; 200) &#123; age_ = age; name_ = name; &#125; &#125; public String getName() &#123; return name_; &#125; public int getAge() &#123; return age_; &#125;&#125;; 注：内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。]]></content>
      <tags>
        <tag>java</tag>
        <tag>内部类</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch搜索]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F28%2FElasticsearch%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[有两种形式的 搜索 API：一种是轻量的查询字符串版本，要求在查询字符串中传递所有的参数，另一种是更完整的请求体版本，要求使用 JSON 格式和更丰富的查询表达式作为搜索语言。 查询字符串12GET /_all/tweet/_search?q=+name:john+tweet:mary# 查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档 + 前缀表示必须与查询条件匹配 - 前缀表示一定不与查询条件匹配 没有 + 或者 - 的所有其他条件都是可选的 匹配的越多，文档就越相关 取所有字段的值拼接成一个大的字符串，作为 _all 字段进行索引 1234+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)# name 字段中包含 mary 或者 john# date 值大于 2014-09-10# _all 字段包含 aggregations 或者 geo 注：查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。 请求体查询请求体查询，不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 你是不是想找的建议。 match_all 查询match_all 查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询： 1&#123; "match_all": &#123;&#125;&#125; match 查询无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。 如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串： 1234&#123; "match": &#123; "tweet": "About Search" &#125;&#125;// 如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串// 如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段// 那么它将会精确匹配给定的值 multi_match 查询multi_match 查询可以在多个字段上执行相同的 match 查询： 123456&#123; "multi_match": &#123; "query": "full text search", "fields": [ "title", "body" ] &#125;&#125; range 查询range 查询找出那些落在指定区间内的数字或者时间： 123456789101112&#123; "range": &#123; "age": &#123; "gte": 20, "lt": 30 &#125; &#125;&#125;// gt 大于// gte 大于等于// lt 小于// lte 小于等于 term 查询term 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串： 1234&#123; "term": &#123; "age": 26 &#125;&#125;&#123; "term": &#123; "date": "2014-09-01" &#125;&#125;&#123; "term": &#123; "public": true &#125;&#125;&#123; "term": &#123; "tag": "full_text" &#125;&#125; terms 查询terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 1&#123; "terms": &#123; "tag": [ "search", "full_text", "nosql" ] &#125;&#125; exists 查询和 missing 查询exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性： 12345&#123; "exists": &#123; "field": "title" &#125;&#125; 组合多查询 bool bool 查询将多个查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数： must：文档 必须 匹配这些条件才能被包含进来 must_not：文档 必须不匹配这些条件才能被包含进来 should：如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响 filter：必须匹配，但它以不评分、过滤模式来进行 一条复合语句可以合并 任何 其它查询语句，包括复合语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;:&#123; &quot;about&quot;:&quot;rock climbing&quot; &#125;, &quot;match&quot;:&#123; &quot;last_name&quot;:&quot;Smith&quot; &#125;, &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;tweet&quot;:&quot;elasticsearch&quot; &#125; &#125;, &quot;must_not&quot;:&#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;mary&quot; &#125; &#125;, &quot;should&quot;:[ &#123; &quot;match&quot;:&#123; &quot;starred&quot;:true &#125; &#125;, &#123; &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;folder&quot;:&quot;inbox&quot; &#125; &#125;, &quot;must_not&quot;:&#123; &quot;match&quot;:&#123; &quot;spam&quot;:true &#125; &#125; &#125; &#125; ], &quot;filter&quot;:&#123; &quot;range&quot;:&#123; &quot;age&quot;:&#123; &quot;gt&quot;:30 &#125; &#125; &#125; &#125;, &quot;minimum_should_match&quot;:1 &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; &quot;about&quot;:&#123; &#125; &#125; &#125;, &quot;aggs&quot;:&#123; &quot;all_interests&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;:&quot;interests&quot; &#125;, &quot;aggs&quot;:&#123; &quot;avg_age&quot;:&#123; &quot;avg&quot;:&#123; &quot;field&quot;:&quot;age&quot; &#125; &#125; &#125; &#125; &#125;&#125; 多索引、多类型 /_search：在所有的索引中搜索所有的类型 /gb/_search：在 gb 索引中搜索所有的类型 /gb,us/_search：在 gb 和 us 索引中搜索所有的文档 /g*,u*/_search：在任何以 g 或者 u 开头的索引中搜索所有的类型 /gb/user/_search：在 gb 索引中搜索 user 类型 /gb,us/user,tweet/_search：在 gb 和 us 索引中搜索 user 和 tweet 类型 /_all/user,tweet/_search：在所有的索引中搜索 user 和 tweet 类型]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-static块]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F26%2Fjava-static%E5%9D%97%2F</url>
    <content type="text"><![CDATA[static块static{}，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法 1234567891011121314151617public class TestStatic &#123; static &#123; System.out.println(1); &#125; static &#123; System.out.println(2); &#125; public static void main(String args[]) &#123; System.out.println(4); &#125; static &#123; System.out.println(3); &#125;&#125; 类加载特性 在虚拟机的生命周期中一个类只被加载一次 类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的 类加载的时机 第一次创建对象要加载类 调用静态方法时要加载类,访问静态属性时会加载类 加载子类时必定会先加载父类 创建对象引用不加载类 子类调用父类的静态方法时 当子类没有覆盖父类的静态方法时，只加载父类，不加载子类 当子类有覆盖父类的静态方法时，既加载父类，又加载子类 访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。]]></content>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis入门]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F22%2Fredis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redis 配置服务端：redis-server 客户端：redis-cli 通过 CONFIG命令查看或设置配置项 123# 查看：CONFIG GET CONFIG_SETTING_NAMECONFIG GET loglevelCONFIG GET * # 使用 * 号获取所有配置项 12# 配置：CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUECONFIG SET loglevel "notice" Redis 数据类型123456789101112131415161718192021222324# String（字符串）# string 类型是二进制安全的，可以包含jpg图片或者序列化的对象# 一个键最大能存储512MBSET name "runoob" # SET key valueGET name # GET key# Hash（哈希）HMSET myhash field1 "Hello" field2 "World"HGET myhash field1HGET myhash field2# List（列表）lpush runoob redislpush runoob mongodblpush runoob rabitmqlrange runoob 0 10# Set（集合）# 成功返回1，如果元素已经在集合中返回 0sadd runoob redissadd runoob mongodbsadd runoob rabitmqsadd runoob rabitmq # 重复smembers runoob Java 使用 RedisRedis Java String(字符串) 实例123456789101112131415import redis.clients.jedis.Jedis; public class RedisStringJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); //设置 redis 字符串数据 jedis.set("runoobkey", "www.runoob.com"); // 获取存储的数据并输出 System.out.println("redis 存储的字符串为: "+ jedis.get("runoobkey")); &#125;&#125; Redis Java List(列表) 实例123456789101112131415161718192021import java.util.List;import redis.clients.jedis.Jedis; public class RedisListJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); //存储数据到列表中 jedis.lpush("site-list", "Runoob"); jedis.lpush("site-list", "Google"); jedis.lpush("site-list", "Taobao"); // 获取存储的数据并输出 List&lt;String&gt; list = jedis.lrange("site-list", 0 ,2); for(int i=0; i&lt;list.size(); i++) &#123; System.out.println("列表项为: "+list.get(i)); &#125; &#125;&#125; Redis Java Keys 实例12345678910111213141516171819import java.util.Iterator;import java.util.Set;import redis.clients.jedis.Jedis; public class RedisKeyJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); // 获取数据并输出 Set&lt;String&gt; keys = jedis.keys("*"); Iterator&lt;String&gt; it=keys.iterator() ; while(it.hasNext())&#123; String key = it.next(); System.out.println(key); &#125; &#125;&#125; 参数说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379 port 63794. 绑定的主机地址 bind 127.0.0.15. 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折中，默认值） appendfsync everysec21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库表格设计与范式]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%A0%BC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、表设计 数据库实体间是一对多、多对多关系时，如何进行表设计： 一对多：添加外键 多对多 ：建立关系表 注： 添加外键时，尽量只记录外键，不创建外键约束 推荐业务层级的约束，慎重使用数据库层级的约束，为表结构的重构提供可能性 12# 慎重foreign key(member_id) references member (id); 业务层级约束 物理删除 删除数据时，手动查看当前数据主键被引用的情况 存在引用，不能删除 不存在引用，可以删除 注：主键可能会被新增的表引用，因此每新增一个引用，都需要添加一种查看引用情况的逻辑 非物理删除 123456# 使用status字段，表示数据的可用状态# 被其他表引用时，不添加外键约束# 删除数据时，不用考虑被其他表引用，从而导致数据不一致的情况status = 1： 可用。可执行操作包括，删、查、改status = 0： 不可用。可执行操作包括，删、查、改status = -1： 已删除。执行操作包括，查、改(只允许修改status字段) 二、范式第一范式：如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式 1地址：可以拆分为省、市、区、详细地址 第二范式：第二范式在第一范式的基础之上更进一层。 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关，主要针对联合主键而言。 也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 第三范式：第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 12# 通过a不能直接获取ca--&gt; b --&gt; c]]></content>
      <tags>
        <tag>范式</tag>
        <tag>多对多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA-JpaRepository方法]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2FSpringDataJPA-JpaRepository%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[解析方法名创建查询12find + 全局修饰 + By + 实体的属性名称 + 限定词 + 连接词 + …(其它实体属性) + OrderBy + 排序属性 + 排序方向 12// 分页查询出符合姓名的记录,同理Sort也可以直接加上public List&lt;User&gt; findByName(String name, Pageable pageable); 12345678910111213141516171819202122232425262728293031323334353637全局修饰： Distinct， Top， First关键词： IsNull， IsNotNull， Like， NotLike， Containing， In， NotIn，IgnoreCase， Between， Equals， LessThan， GreaterThan， After， Before…排序方向： Asc， Desc连接词： And， OrAnd — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；NotNull — 与 IsNotNull 等价；Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA-Query注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2FSpringDataJPA-Query%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Query注解查询适用于所查询的数据无法通过关键字查询得到结果的查询。这种查询可以摆脱像关键字查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是Spring Data的特有实现。 一、索引参数索引参数：索引值从1开始，查询中?X个数需要与方法定义的参数个数相一致，并且顺序也要一致。 12@Query("SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2")List&lt;Person&gt; testQueryAnnotationParams1(String lastName, String email); 注释：上面代码中的?1 、?2表示参数的占位符，需要和方法中所传递的参数顺序一致。X是从1开始。 二、命名参数命名参数：可以定义好参数名，赋值时使用@Param(&quot;参数名&quot;)，而不用管顺序-推荐使用 12345// 为@Query注解传递参数的方式1：命名参数@Query("SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email")List&lt;Person&gt; testQueryAnnotationParams2( @Param("email") String email, @Param("lastName") String lastName); 注释：:lastName 、:email表示为参数命名，方法中所传递的参数使用@Param注解标识命名参数。这种方式不用管参数的顺序。 三、原生SQL进行查询12@Query(value = "SELECT count(id) FROM jpa_persons", nativeQuery = true)long getTotalCount(); 123 @Query(nativeQuery = true, value = "select * from user where name LIKE CONCAT('%', :file_name, '%')")List&lt;User&gt; findByFileName(@Param("file_name") String file_name); 12 @Query(nativeQuery = true, value = "select * from user where name LIKE %:file_name%")List&lt;User&gt; findByFileName(@Param("file_name") String file_name); 注释： 当设置nativeQuery=true即可以使用原生SQL进行查询 like查询：LIKE CONCAT(&#39;%&#39;, :file_name, &#39;%&#39;) 四、@Modifying注解 在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data这是一个DELETE或UPDATE操作。 UPDATE或者DELETE操作需要使用事务，此时需要定义Service层，在Service层的方法上添加@Transactional。 注意JPQL不支持INSERT操作。 1234@Transactional@Modifying@Query("UPDATE Person p SET p.email = :email WHERE p.id = :id")void updatePersonEmail(@Param("id") Integer id, @Param("email") String email); 五、EntityManager1234567891011121314151617181920212223242526272829303132333435363738394041424344public class EpsmSubjectRepositoryImpl &#123; @PersistenceContext EntityManager entityManager; public List &lt; EpsmSubject &gt; findEpsmSubjectList( Long catalogId, String subjectName, Long start, Long pageSize) &#123; // 构造sql语句 StringBuffer sql = new StringBuffer("SELECT * FROM t_epsm_subject where 1 = 1 "); if (catalogId != null) &#123; sql.append(" and catalog_id = :catalogId "); &#125; if (StringUtils.isNotBlank(subjectName)) &#123; sql.append(" and subject_name like CONCAT('%', :subjectName, '%')"); &#125; sql.append(" order by created_time DESC"); if (start != null &amp;&amp; pageSize != null) &#123; sql.append(" limit :start , :pageSize"); &#125; Query query = entityManager.createNativeQuery(sql.toString(), EpsmSubject.class); // 填充查询参数 if (catalogId != null) &#123; query.setParameter("catalogId", catalogId); &#125; if (StringUtils.isNotBlank(subjectName)) &#123; query.setParameter("subjectName", subjectName); &#125; if (start != null &amp;&amp; pageSize != null) &#123; query.setParameter("start", start); query.setParameter("pageSize", pageSize); &#125; return query.getResultList(); &#125;&#125;]]></content>
      <tags>
        <tag>Query</tag>
        <tag>Modifying</tag>
        <tag>Transactional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[beans标签与属性]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2Fbeans%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[####&lt;beans&gt;标签 12345&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; xmls xmlns是XMLnameSpace的缩写，xml的标签名称是自定义的，可能会和其他人的标签重名，而功能却不一样，所以需要加一个namespace来区分，类似Java中package 。 xmlns:xsi 是指xml文件遵守xml规范，xsi全名：xml schema instance ，是指具体用到schema资源文件里定义的规范所遵守的规范。即/spring-beans-2.0.xsd这个文件里定义的元素遵守什么标准 xsi:schemaLaction schemalLaction属性来引用（schema）模式文档，解析器可以在需要的情况下使用这个文档对xml实例文档进行校验。它的值（URL）是成对出现的，第一个值表示命名空间，第二个值则表示描述该命名空间的模式文档的具体位置，两个值之间以空格分隔。 &lt;bean&gt;标签12345678910111213141516171819202122232425262728&lt;!-- 空参构造创建 --&gt;&lt;bean id="logDao" name="logDaoName" class="com.sjtu.bean.LogDao" /&gt;&lt;bean id="dataSource" class="com.sjtu.bean.dataSource"&gt; &lt;!-- 值类型注入：为dataSource对象中名为user的属性注入root作为值 --&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean class="com.sjtu.bean..LogonService"&gt; &lt;!-- 引用类型注入：为logDao属性注入logDao对象 --&gt; &lt;property name="logDao" ref="logDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 准备带有参数的构造 --&gt;&lt;bean name="user" class="com.sjtu.bean.User"&gt; &lt;!-- name属性：构造函数参数名 --&gt; &lt;!-- index属性：构造函数参数索引 --&gt; &lt;!-- type属性：构造函数参数类型 --&gt; &lt;!-- 上述三个属性不必全部出现，根据情况选择即可 --&gt; &lt;constructor-arg name="name" value="Jerry" index="0" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="car" ref="car"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; id是bean的标识符，必须唯一。如果没有配置id，name默认为标识符 如果配置了id和name，那么name为别名。 name可以设置多个别名，分隔符可以是空格、逗号、分号 class是bean的全限定名，即包名+类名。如果不配置id和name，那么可以根据applicationContext.getbean(Class)获取对象 autowire 自动装配 用于简化spring的配置 123byname: 根据名称去查找相应的bean,发现了则装载上bytype: 根据类型自动装配,不用去管id,但同一种类型的bean只能有一个,否则报错constructor：当通过构造器注入实例化bean时,装配构造方法 scope作用域 12345singleton: 单例的,整个容器只产生一个对象,默认是单例prototype: 原型,每次获取bean都创建一个新对象request: 每次请求时创建一个新的对象session: 在一个会话范围内只产生一个对象application: 在应用范围内是一个对象 分层次程序严格来讲分为四个层次： 显示层：VO类 控制层：Controller类 业务层：Service类 数据层： 表：Entity类 || PO类 CURD：DAO类）]]></content>
      <tags>
        <tag>spring</tag>
        <tag>beans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、java 的反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 注：反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。 二、获取类的信息123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 123456789101112131415161718192021222324private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3. 遍历变量并输出变量信息 for (Field field : fields) &#123; //获取访问权限(修饰符)并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用getDeclaredFields()， 输出 SonClass 类的所有成员变量，不问访问权限 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 注： 获取变量信息：getFields() 、getDeclaredFields()、getField() 、getDeclaredField() 获取方法信息：getMethods()、getDeclaredMethods()、getMethod()、getDeclaredMethod() 三、私有变量和方法123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 12345678910111213141516171819202122232425private static void getPrivateMethod() throws Exception&#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用 invoke 反射调用私有方法 //privateMethod 是获取到的私有方法 //testClass 要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 123456789101112131415161718192021222324private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 注： setAccessible(true) 方法，是获取私有方法或变量的访问权限 用 invoke() 方法来调用方法 四、获得 Class 对象1、使用 Class 类的 forName 静态方法1Class&lt;?&gt; cls = Class.forName("java.lang.String"); 2、直接获取某一个类的 class1Class&lt;?&gt; klass = int.class; 3、调用某个对象的 getClass() 方法12StringBuilder str = new StringBuilder("123");Class&lt;?&gt; klass = str.getClass(); 注： Class&lt;T&gt;在实例化的时候，T要替换成具体类 Class&lt;?&gt;它是个通配泛型，?可以代表任何类型 五、创建实例 使用Class对象的newInstance()方法来创建Class对象对应类的实例 12Class&lt;?&gt; c = String.class;Object str = c.newInstance(); 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法 123456789//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance("23333");System.out.println(obj); 注：getConstructor() 获取构造器对象]]></content>
      <tags>
        <tag>java</tag>
        <tag>Reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、认识注解JDK1.5之后内部提供的三个注解 @Deprecated 意思是废弃的，过时的 @Override 意思是重写、覆盖 @SuppressWarnings 意思是“压缩警告 12345678910111213141516171819202122public class AnnotationTest &#123; // 这里就是注解，称为压缩警告，这是JDK内部自带的一个注解 // 一个注解就是一个类，在这里使用了这个注解就是创建了SuppressWarnings类的一个实例对象 @SuppressWarnings(":deprecation") public static void main(String[] args) &#123; System.runFinalizersOnExit(true); //这里的runFinalizersOnExit()方法画了一条横线表示此方法已经过时了，不建议使用了 &#125; //这也是JDK内部自带的一个注解，意思就是说这个方法已经废弃了，不建议使用了 @Deprecated public static void sayHello()&#123; System.out.println("hello world"); &#125; //这也是JDK1.5之后内部提供的一个注解，意思就是要重写(覆盖)JDK内部的toString()方法 @Override public String toString()&#123; return "hello world"; &#125;&#125; 注：注解就相当于一个你的源程序要调用一个类，在源程序中应用某个注解，得事先准备好这个注解类 二、自定义注解及其应用1234567891011121314151617181920212223242526272829303132import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * 这是一个自定义的注解(Annotation)类，在定义注解(Annotation)类时使用了另一个注解类Retention * 在注解类上使用另一个注解类，那么被使用的注解类就称为元注解 */@Retention(RetentionPolicy.RUNTIME)//Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)//Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类、属性、方法身上等成分/* * @Retention(RetentionPolicy.SOURCE) * 这个注解的意思是让MyAnnotation注解只在java源文件中存在，编译成.class文件后注解就不存在了 * @Retention(RetentionPolicy.CLASS) * 这个注解的意思是让MyAnnotation注解在java源文件(.java文件)中存在， * 编译成.class文件后注解也还存在，被MyAnnotation注解类标识的类被类加载器加载到内存中后 * MyAnnotation注解就不存在了 *//* * 这里是在注解类MyAnnotation上使用另一个注解类，这里的Retention称为元注解。 * Retention注解括号中的"RetentionPolicy.RUNTIME"意思是让MyAnnotation这个注解的 * 生命周期一直程序运行时都存在 */public @interface MyAnnotation &#123;&#125; 把自定义的注解加到某个类上：12@ MyAnnotation public class AnnotationUse&#123;&#125; 用反射测试进行测试AnnotationUse的定义上是否有@MyAnnotation12345678910111213141516171819202122// 这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上@MyAnnotationpublic class AnnotationUse &#123; public static void main(String[] args) &#123; // 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查 if (AnnotationUse.class.isAnnotationPresent(MyAnnotation.class)) &#123; /* * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的 * 一旦在某个类上使用了@MyAnnotation，那么 * 这个MyAnnotation类的实例对象annotation就会被创建出来了 */ MyAnnotation annotation = (MyAnnotation) AnnotationUse.class .getAnnotation(MyAnnotation.class); // 打印MyAnnotation对象，这里输出的结果为：@cn.itcast.day2.MyAnnotation() System.out.println(annotation); &#125; &#125;&#125; 三、元注解（meta-annotation）Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 @Target @Retention @Documented @Inherited 1、@Target@Target说明了Annotation所修饰的对象范围（被描述的注解可以用在什么地方） CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 12@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)// @Target(ElementType.FIELD) 2、@Retention@Retention定义了该Annotation被保留的时间长短。 SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 1@Retention(RetentionPolicy.RUNTIME) 2.1 声明周期一个注解的生命周期有三个阶段：java源文件是一个阶段，class文件是一个阶段，内存中的字节码是一个阶段。javac把源文件编译成.class文件时，有可能去掉里面的注解，类加载器把.class文件加载到内存时也有可能去掉里面的注解。 2.2 Java API中是这样定义的@Deprecated的123@Documented@Retention(value=RUNTIME)public @interface Deprecated 2.3 Java API中是这样定义的@Override的123@Target(value=METHOD)@Retention(value=SOURCE)public @interface Override @Override是给javac看的，编译完以后就@Override注解就没有价值了 2.4 Java API中是这样定义的@SuppressWarnings的123@Target(value=&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)@Retention(value=SOURCE)public @interface SuppressWarnings @SuppressWarnings也是给javac看的 3、@Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; 4、@Inherited@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 四、为注解增加属性注解可以看成是一种特殊的类，既然是类，那自然可以为类添加属性 1、添加属性语法：类型 属性名() default 默认值; || 类型 属性名(); 1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)// Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)public @interface MyAnnotation &#123; // String color(); String color() default "blue"; // 为属性指定缺省值 String value(); // 定义一个名称为value的属性&#125; 2、应用属性123456789@MyAnnotation(color = "red") //应用MyAnnotation注解的color属性public class MyAnnotationTest &#123; public static void main(String[] args) &#123; // 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法 MyAnnotation annotation = (MyAnnotation) MyAnnotationTest.class .getAnnotation(MyAnnotation.class); System.out.println(annotation.color()); //输出red &#125;&#125; 3、value属性如果一个注解中有一个名称为value的属性，且你只想设置value属性，那么可以省略掉“value=”部分 12@SuppressWarnings("deprecation")@MyAnnotation("hello world")]]></content>
      <tags>
        <tag>java</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F17%2FSpring%20MVC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解类型handler method参数绑定常用的注解，根据处理的Request内容部分不同分为四类： 处理requet uri 部分的注解：@PathVariable 注：指uri template中variable，不含queryString部分 处理request header部分的注解： @RequestHeader、@CookieValue 处理request body部分的注解：@RequestParam、@RequestBody 处理attribute类型是注解： @SessionAttributes、 @ModelAttribute @PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定传过来的值到方法的参数上。 12345678@RequestMapping("/owners/&#123;ownerId&#125;")public class RelativePathUriTemplateController &#123; // @RequestMapping("/pets/&#123;petId&#125;") @RequestMapping(value = "/pets/&#123;petId&#125;", method = RequestMethod.POST) public void findPet(@PathVariable String ownerId, @PathVariable String petId) &#123; // implementation omitted &#125;&#125; 注：若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(&quot;name&quot;)指定uri template中的名称。 1@PathVariable("ownerId") String owner_id @RequestHeader@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 123456@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo( @RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) &#123; //...&#125; @CookieValue@CookieValue可以把Request header中关于cookie的值绑定到方法的参数上 1JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 1234@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; //...&#125; @RequestParam 常用来处理简单类型的绑定，通过Request.getParameter()获取的String可直接转换为简单类型的情况 可以处理get 方式中queryString的值 可以处理post方式中body data的值 用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST 该注解有两个属性： value、required value用来指定要传入值的id名称 required用来指示参数是否必须绑定 12345678@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm( @RequestParam(value = "petId", required = false) int petId) &#123; // ... &#125;&#125; 注：可以不使用@RequestParam，直接接收。此时要求controller方法中的参数名称要一致 1234567@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm(int petId) &#123; // ... &#125;&#125; @RequestBody常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容 application/json application/xml 使用HandlerAdapter配置的HttpMessageConverters来解析post data body，然后绑定到bean上 字符串解析： 123456789$.ajax(&#123; url: "/login", type: "POST", data: '&#123;"userName":"admin","pwd","admin123"&#125;', content - type: "application/json charset=utf-8", success: function(data) &#123; alert("request success ! "); &#125;&#125;); 12345@requestMapping("/login")public void login(@requestBody String userName, @requestBody String pwd) &#123; System.out.println(userName + " ：" + pwd);&#125;// 将JSON字符串中的两个变量的值分别赋予了两个字符串 对象解析： 12345@RequestMapping(value = "/something", method = RequestMethod.PUT)public void handle(@RequestBody User user) &#123; System.out.println(user.userName + " ：" + user.pwd);&#125;// 将JSON字符串中的值赋予user中对应的属性上 注： JSON字符串中的key必须对应user中的属性名，否则是请求不过去的 @RequestBody最多只能有一个，而@RequestParam()可以有多个 @SessionAttributes用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象。 123456@RequestMapping("/editPet.do")// @SessionAttributes("pet")@SessionAttributes(value = &#123; "pet" &#125;, types = &#123; Integer.class &#125;)public class EditPetForm &#123; // ...&#125; 注：@SessionAttributes注解只能在类上使用，不能在方法上使用 @ModelAttribute、@RequestAttribute123456789@ModelAttributevoid beforeInvokingHandlerMethod(HttpServletRequest request) &#123; request.setAttribute("foo", "hello world");&#125;@RequestMapping(value = "/data/custom", method = RequestMethod.GET)public @ResponseBody String custom(@RequestAttribute("foo") String foo) &#123; return "Got 'foo' request attribute value '" + foo + "'";&#125; 1234&lt;div id="customArgs"&gt; &lt;h3&gt;Custom Resolvable Web Arguments&lt;/h3&gt; &lt;a id="customArg" class="textLink" href="/data/custom"&gt;Custom&lt;/a&gt;&lt;/div&gt; 12345678910$("a.textLink").click(function() &#123; var link = $(this); $.ajax(&#123; url: link.attr("href"), dataType: "text", success: function(text) &#123; alert(text) &#125; &#125;);&#125;); 1Got &apos;foo&apos; request attribute value &apos;hello world&apos;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar-MANIFEST.MF文件]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar-MANIFEST-MF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容： 1234567891011Manifest-Version: 1.0Created-By: Apache Ant 1.5.1Extension-Name: Struts FrameworkSpecification-Title: Struts FrameworkSpecification-Vendor: Apache Software FoundationSpecification-Version: 1.1Implementation-Title: Struts FrameworkImplementation-Vendor: Apache Software FoundationImplementation-Vendor-Id: org.apacheImplementation-Version: 1.1Class-Path: commons-beanutils.jar commons-collections.jar commons-digester.jar 一般属性 Manifest-Version 用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version ：定义jar文件的签名版本 Class-Path ：应用程序或者类装载器使用该值来构建内部的类搜索路径 应用程序相关属性 Main-Class 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过java -jar x.jar来运行该jar文件。]]></content>
      <tags>
        <tag>jar</tag>
        <tag>MANIFEST.MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 修改默认的本地仓库Maven 本地仓库默认被创建在 %USER_HOME%目录下。要修改默认位置，在 %M2_HOME%\conf目录中的 Maven 的 settings.xml文件中定义另一个路径 123456&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;&lt;/settings&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven-pom配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven-pom%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[POM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件。 maven的协作相关属性一个pom.xml的定义必须包含modelVersion、groupId、artifactId和version这四个元素，当然这其中的元素也是可以从它的父项目中继承的。使用groupdId:artifactId:version`的形式来唯一确定一个项目。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 含义：组织标识，定义了项目属于哪个组 用途：此名称则是本地仓库中的路径 例如：otowa.user.dao，在M2_REPO目录下，将是: otowa/user/dao目录 命名规范:项目名称，模块，子模块 --&gt; &lt;groupId&gt;otowa.user.dao&lt;/groupId&gt; &lt;!-- 含义：项目名称，定义当前Maven项目在组中唯一的ID 用途：例如：user-dao，在M2_REPO目录下，将是：otowa/user/dao/user-dao目录 命名规范:唯一就好 --&gt; &lt;artifactId&gt;user-dao&lt;/artifactId&gt; &lt;!-- 含义：项目当前的版本号 用途：例如：0.0.1-SNAPSHOT 在M2_REPO目录下，将是：otowa/user/dao/user-dao/0.0.1-SNAPSHOT目录 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt; &lt;name&gt;maven&lt;/name&gt;&lt;/project&gt; 引入依赖12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化 所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!-- scope包含如下的取值：compile（编译范围）、provided（已提供范围） runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true 则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版， libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 定义常量123456&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt;&lt;/properties&gt; 多环境配置12345678910111213141516171819&lt;profiles&gt; &lt;!-- 开发环境 --&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;conf.dir&gt;profile/dev/&lt;/conf.dir&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;!-- 生成环境 --&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;conf.dir&gt;profile/prod/&lt;/conf.dir&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;]]></content>
      <tags>
        <tag>maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar包]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一、制作只含有字节码文件的jar包我们先来看只含有字节码文件，即只含有.class文件的jar包怎么制作，这是最简单的形式 1、最简单的jar包——直接输出hello最终生成的jar包结构 META-INF Hello.class 方法步骤 （1）用记事本写一个Hello.java的文件 12345class Hello&#123; public static void main(String[] agrs)&#123; System.out.println("hello"); &#125;&#125; （2）用命令行进入到该目录下，编译这个文件 1javac Hello.java （3）将编译后的Hello.class文件打成jar包 1jar -cvf hello.jar Hello.class c 表示要创建一个新的jar包 v 表示创建的过程中在控制台输出创建过程的一些信息 f 表示给生成的jar包命名 （4）运行jar包 12java -jar hello.jar# 这时会报如下错误 hello.jar中没有主清单属性 （5）添加Main-Class属性 用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件 12Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation) 添加Main-Class: Hello ，再次运行java -jar hello.jar ，此时成功在控制台看到 hello 2、含有两个类的jar包——通过调用输出hello最终生成的jar包结构 META-INF Tom.class Hello.class （1）用记事本写一个Hello.java和一个Tom.java的文件 12345class Hello &#123; public static void main(String[] agrs) &#123; System.out.println("hello"); &#125;&#125; 12345class Tom &#123; public static void speak() &#123; System.out.println("hello"); &#125;&#125; （2）编译 1javac Hello.java 此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom （3）打jar包，这次我们换一种方式直接定义Main-Class 123Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation)Main-Class: Hello 事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下 1jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class 该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件 （4）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 3、有目录结构的jar包——通过引包并调用输出hello最终生成的jar包结构 META-INF com ​ Tom.class Hello.class 我们将上一个稍稍变化一下，将Tom类放在com包下。 12package com;# Tom.java需要在第一行声明自己的包名 12import com.Tom;# Hello.java需要引入Tom这个类 （1）编译Hello.java （2）打jar包，同样准备好MENIFEST文件 12jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com # 最后一个com表示把文件夹下的所有文件都打进jar包 （3）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 （4）优化过程 我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。 在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令 12javac Hello.java -d target# 将所有编译后的文件，都放到target文件夹下 将META-INF文件夹也复制到target目录下，进入这个目录，输入如下命令 12jar -cvfm hello.jar META-INF\MENIFEST.MF * # 最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里 原文]]></content>
      <tags>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类加载器]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器类加载器负责将.class文件加载到内存中，并为类生成一个java.lang.Class实例。 一旦一个类被加载入JVM中，同一个类就不会被再次加入了。在JVM中用来判断类的唯一性标识是：类名、类所在的包名和类加载器。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构： BootStrap ClassLoader：根类加载器 Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 根类加载器 （bootstrap class loader）：它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，并不继承自java.lang.ClassLoader。没有父加载器 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 父加载器为根类加载器 扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。父加载器为扩展类加载器 系统类加载器是纯Java类，是java.lang.ClassLoader类的子类 自定义类加载器（custom class loader）：除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 类加载的父委托机制从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。 在父委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器，各个加载器按照父子关系形成了树形结构。 当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由loader1本身加载Sample类。 注： 这里的父加载器概念并不是指类的继承关系，子加载器不一定继承了父加载器（其实是组合的关系） 每个加载器都优先尝试用父类加载，若父类不能加载则自己尝试加载；若成功则返回Class对象给子类，若失败则告诉子类让子类自己加载。所有都失败则抛出ClassNotFoundException异常]]></content>
      <tags>
        <tag>java</tag>
        <tag>ClassLoader</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch使用]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F11%2FElasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文档 面向文档通常，应用程序中的对象拥有复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。如果要把这些对象存储在关系型数据库中，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将对象扁平化来适应表结构，而且又不得不在每次查询时重新构造对象： 一个简单字段对应一列 一个对象字段需要新建表、引用主键 一个数组字段需要新建表、引用主键、每个数组元素对应一行 Elasticsearch使用JavaScript Object Notation或者JSON作为文档的序列化格式。JSON序列化被大多数编程语言所支持，并且已经成为 NoSQL领域的标准格式。 注：文档 =》对象 请求格式一个Elasticsearch请求和任何HTTP请求一样由若干相同的部件组成： 1curl -X &lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; 被 &lt; &gt; 标记的部件： 参数 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE PROTOCOL http 或者 https HOST Elasticsearch 集群中任意节点的主机名 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径，由index、type、id 等组成 QUERY_STRING 任意可选的查询字符串参数，?pretty 将格式化地输出 JSON 返回值 BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个： 123456curl -X GET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 搜索格式 搜索所有type 1GET /megacorp/employee/_search 注：使用 _search代替具体的id 参数搜索 12# 查询字符串GET /megacorp/employee/_search?q=last_name:Smith 123456789# match 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;Smith&quot; &#125; &#125;&#125; 123456789101112131415161718# filter 过滤器GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;smith&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &#125; &#125; &#125; &#125;&#125; 123456789# match_phrase 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;about&quot; : &quot;rock climbing&quot; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java知识]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F07%2Fjava%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类名与文件名 一个Java文件中只能有一个public类 如果文件中存在public类，文件名必须与public类名一致 如果文件中没有public类，文件名与类名可以不一致 注：一个源文件中，用class关键字定义了几个类，编译的时候就会产生几个字节码文件 包名与文件名.java文件中的包名必须与物理文件夹对应 123// Something.java 文件package net.java.util;public class Something&#123;&#125; 物理存储位置应该是：net/java/util/Something.java 注： 同一个包中的类名字不能相同 同级包下的类引用不需要import，可以直接调用 Java编译器默认导入java.lang包 主入口方法1public static void main(String[] args) &#123;&#125; 该java类由java虚拟机调用，所以java类应把该方法暴露，故用public 既然由JVM调用该方法，肯定不能new 一个对象再由对象调用该方法，应直接由JVM调用故用static 给JVM返回东西是无意义的 ，故用void 括号里的参数是由JVM传给该方法的，具体可为： 从cmd控制台传入 从开发环境IDE配置参数传入 装箱与拆箱所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型 。 12345678910public class Test &#123; public static void main(String args[]) &#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱// 然后，为了使x能进行加运算，所以要对x进行拆箱 创建数组1dataType[] arrayRefVar = new dataType[arraySize]; 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 重写与重载重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
