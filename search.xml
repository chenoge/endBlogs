<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jar-MANIFEST.MF文件]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar-MANIFEST-MF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容： 1234567891011Manifest-Version: 1.0Created-By: Apache Ant 1.5.1Extension-Name: Struts FrameworkSpecification-Title: Struts FrameworkSpecification-Vendor: Apache Software FoundationSpecification-Version: 1.1Implementation-Title: Struts FrameworkImplementation-Vendor: Apache Software FoundationImplementation-Vendor-Id: org.apacheImplementation-Version: 1.1Class-Path: commons-beanutils.jar commons-collections.jar commons-digester.jar 一般属性 Manifest-Version 用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version ：定义jar文件的签名版本 Class-Path ：应用程序或者类装载器使用该值来构建内部的类搜索路径 应用程序相关属性 Main-Class 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过java -jar x.jar来运行该jar文件。]]></content>
      <tags>
        <tag>jar</tag>
        <tag>MANIFEST.MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 修改默认的本地仓库Maven 本地仓库默认被创建在 %USER_HOME%目录下。要修改默认位置，在 %M2_HOME%\conf目录中的 Maven 的 settings.xml文件中定义另一个路径 123456&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;&lt;/settings&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven-pom配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven-pom%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[POM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件。 maven的协作相关属性一个pom.xml的定义必须包含modelVersion、groupId、artifactId和version这四个元素，当然这其中的元素也是可以从它的父项目中继承的。使用groupdId:artifactId:version`的形式来唯一确定一个项目。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 含义：组织标识，定义了项目属于哪个组 用途：此名称则是本地仓库中的路径 例如：otowa.user.dao，在M2_REPO目录下，将是: otowa/user/dao目录 命名规范:项目名称，模块，子模块 --&gt; &lt;groupId&gt;otowa.user.dao&lt;/groupId&gt; &lt;!-- 含义：项目名称，定义当前Maven项目在组中唯一的ID 用途：例如：user-dao，在M2_REPO目录下，将是：otowa/user/dao/user-dao目录 命名规范:唯一就好 --&gt; &lt;artifactId&gt;user-dao&lt;/artifactId&gt; &lt;!-- 含义：项目当前的版本号 用途：例如：0.0.1-SNAPSHOT 在M2_REPO目录下，将是：otowa/user/dao/user-dao/0.0.1-SNAPSHOT目录 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt; &lt;name&gt;maven&lt;/name&gt;&lt;/project&gt; 引入依赖123456789101112131415161718192021222324252627&lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 定义常量123456&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt; &lt;/properties&gt;]]></content>
      <tags>
        <tag>maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-生成jar包]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava-%E7%94%9F%E6%88%90jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一、制作只含有字节码文件的jar包我们先来看只含有字节码文件，即只含有.class文件的jar包怎么制作，这是最简单的形式 1、最简单的jar包——直接输出hello最终生成的jar包结构 META-INF Hello.class 方法步骤 （1）用记事本写一个Hello.java的文件 12345class Hello&#123; public static void main(String[] agrs)&#123; System.out.println("hello"); &#125;&#125; （2）用命令行进入到该目录下，编译这个文件 1javac Hello.java （3）将编译后的Hello.class文件打成jar包 1jar -cvf hello.jar Hello.class c 表示要创建一个新的jar包 v 表示创建的过程中在控制台输出创建过程的一些信息 f 表示给生成的jar包命名 （4）运行jar包 12java -jar hello.jar# 这时会报如下错误 hello.jar中没有主清单属性 （5）添加Main-Class属性 用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件 12Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation) 添加Main-Class: Hello ，再次运行java -jar hello.jar ，此时成功在控制台看到 hello 2、含有两个类的jar包——通过调用输出hello最终生成的jar包结构 META-INF Tom.class Hello.class （1）用记事本写一个Hello.java和一个Tom.java的文件 12345class Hello &#123; public static void main(String[] agrs) &#123; System.out.println("hello"); &#125;&#125; 12345class Tom &#123; public static void speak() &#123; System.out.println("hello"); &#125;&#125; （2）编译 1javac Hello.java 此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom （3）打jar包，这次我们换一种方式直接定义Main-Class 123Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation)Main-Class: Hello 事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下 1jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class 该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件 （4）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 3、有目录结构的jar包——通过引包并调用输出hello最终生成的jar包结构 META-INF com ​ Tom.class Hello.class 我们将上一个稍稍变化一下，将Tom类放在com包下。 12package com;# Tom.java需要在第一行声明自己的包名 12import com.Tom;# Hello.java需要引入Tom这个类 （1）编译Hello.java （2）打jar包，同样准备好MENIFEST文件 12jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com # 最后一个com表示把文件夹下的所有文件都打进jar包 （3）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 （4）优化过程 我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。 在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令 12javac Hello.java -d target# 将所有编译后的文件，都放到target文件夹下 将META-INF文件夹也复制到target目录下，进入这个目录，输入如下命令 12jar -cvfm hello.jar META-INF\MENIFEST.MF * # 最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里 原文]]></content>
      <tags>
        <tag>jar</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类加载器]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器类加载器负责将.class文件加载到内存中，并为类生成一个java.lang.Class实例。 一旦一个类被加载入JVM中，同一个类就不会被再次加入了。在JVM中用来判断类的唯一性标识是：类名、类所在的包名和类加载器。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构： BootStrap ClassLoader：根类加载器 Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 根类加载器 （bootstrap class loader）：它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，并不继承自java.lang.ClassLoader。没有父加载器 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 父加载器为根类加载器 扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。父加载器为扩展类加载器 系统类加载器是纯Java类，是java.lang.ClassLoader类的子类 自定义类加载器（custom class loader）：除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 类加载的父委托机制从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。 在父委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器，各个加载器按照父子关系形成了树形结构。 当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由loader1本身加载Sample类。 注： 这里的父加载器概念并不是指类的继承关系，子加载器不一定继承了父加载器（其实是组合的关系） 每个加载器都优先尝试用父类加载，若父类不能加载则自己尝试加载；若成功则返回Class对象给子类，若失败则告诉子类让子类自己加载。所有都失败则抛出ClassNotFoundException异常]]></content>
      <tags>
        <tag>java</tag>
        <tag>ClassLoader</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch基本使用]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F11%2FElasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面向文档通常，应用程序中的对象拥有复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。如果要把这些对象存储在关系型数据库中，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将对象扁平化来适应表结构，而且又不得不在每次查询时重新构造对象： 一个简单字段对应一列 一个对象字段需要新建表、引用主键 一个数组字段需要新建表、引用主键、每个数组元素对应一行 Elasticsearch使用JavaScript Object Notation或者JSON作为文档的序列化格式。JSON序列化被大多数编程语言所支持，并且已经成为 NoSQL领域的标准格式。 注：文档 =》对象 请求格式一个Elasticsearch请求和任何HTTP请求一样由若干相同的部件组成： 1curl -X &lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; 被 &lt; &gt; 标记的部件： 参数 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE PROTOCOL http 或者 https HOST Elasticsearch 集群中任意节点的主机名 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径，由index、type、id 等组成 QUERY_STRING 任意可选的查询字符串参数，?pretty 将格式化地输出 JSON 返回值 BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个： 123456curl -X GET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 搜索格式 搜索所有type 1GET /megacorp/employee/_search 注：使用 _search代替具体的id 参数搜索 12# 查询字符串GET /megacorp/employee/_search?q=last_name:Smith 123456789# match 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;Smith&quot; &#125; &#125;&#125; 123456789101112131415161718# filter 过滤器GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;smith&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &#125; &#125; &#125; &#125;&#125; 123456789# match_phrase 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;about&quot; : &quot;rock climbing&quot; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本知识]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类名与文件名 一个Java文件中只能有一个public类 如果文件中存在public类，文件名必须与public类名一致 如果文件中没有public类，文件名与类名可以不一致 注：一个源文件中，用class关键字定义了几个类，编译的时候就会产生几个字节码文件 包名与文件名.java文件中的包名必须与物理文件夹对应 123// Something.java 文件package net.java.util;public class Something&#123;&#125; 物理存储位置应该是：net/java/util/Something.java 注： 同一个包中的类名字不能相同 同级包下的类引用不需要import，可以直接调用 Java编译器默认导入java.lang包 主入口方法1public static void main(String[] args) &#123;&#125; 该java类由java虚拟机调用，所以java类应把该方法暴露，故用public 既然由JVM调用该方法，肯定不能new 一个对象再由对象调用该方法，应直接由JVM调用故用static 给JVM返回东西是无意义的 ，故用void 括号里的参数是由JVM传给该方法的，具体可为： 从cmd控制台传入 从开发环境IDE配置参数传入 装箱与拆箱所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型 。 12345678910public class Test &#123; public static void main(String args[]) &#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱// 然后，为了使x能进行加运算，所以要对x进行拆箱 创建数组1dataType[] arrayRefVar = new dataType[arraySize]; 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 重写与重载重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
