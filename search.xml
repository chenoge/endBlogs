<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、java 的反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 注：反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。 二、获取类的信息123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 123456789101112131415161718192021222324private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3. 遍历变量并输出变量信息 for (Field field : fields) &#123; //获取访问权限(修饰符)并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用getDeclaredFields()， 输出 SonClass 类的所有成员变量，不问访问权限 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 注： 获取变量信息：getFields() 、getDeclaredFields()、getField() 、getDeclaredField() 获取方法信息：getMethods()、getDeclaredMethods()、getMethod()、getDeclaredMethod() 三、私有变量和方法123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 12345678910111213141516171819202122232425private static void getPrivateMethod() throws Exception&#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用 invoke 反射调用私有方法 //privateMethod 是获取到的私有方法 //testClass 要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 123456789101112131415161718192021222324private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 注： setAccessible(true) 方法，是获取私有方法或变量的访问权限 用 invoke() 方法来调用方法 四、获得 Class 对象1、使用 Class 类的 forName 静态方法1Class&lt;?&gt; cls = Class.forName("java.lang.String"); 2、直接获取某一个类的 class1Class&lt;?&gt; klass = int.class; 3、调用某个对象的 getClass() 方法12StringBuilder str = new StringBuilder("123");Class&lt;?&gt; klass = str.getClass(); 注： Class&lt;T&gt;在实例化的时候，T要替换成具体类 Class&lt;?&gt;它是个通配泛型，?可以代表任何类型 五、创建实例 使用Class对象的newInstance()方法来创建Class对象对应类的实例 12Class&lt;?&gt; c = String.class;Object str = c.newInstance(); 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法 123456789//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance("23333");System.out.println(obj); 注：getConstructor() 获取构造器对象]]></content>
      <tags>
        <tag>java</tag>
        <tag>Reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、认识注解JDK1.5之后内部提供的三个注解 @Deprecated 意思是废弃的，过时的 @Override 意思是重写、覆盖 @SuppressWarnings 意思是“压缩警告 12345678910111213141516171819202122public class AnnotationTest &#123; // 这里就是注解，称为压缩警告，这是JDK内部自带的一个注解 // 一个注解就是一个类，在这里使用了这个注解就是创建了SuppressWarnings类的一个实例对象 @SuppressWarnings(":deprecation") public static void main(String[] args) &#123; System.runFinalizersOnExit(true); //这里的runFinalizersOnExit()方法画了一条横线表示此方法已经过时了，不建议使用了 &#125; //这也是JDK内部自带的一个注解，意思就是说这个方法已经废弃了，不建议使用了 @Deprecated public static void sayHello()&#123; System.out.println("hello world"); &#125; //这也是JDK1.5之后内部提供的一个注解，意思就是要重写(覆盖)JDK内部的toString()方法 @Override public String toString()&#123; return "hello world"; &#125;&#125; 注：注解就相当于一个你的源程序要调用一个类，在源程序中应用某个注解，得事先准备好这个注解类 二、自定义注解及其应用1234567891011121314151617181920212223242526272829303132import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * 这是一个自定义的注解(Annotation)类，在定义注解(Annotation)类时使用了另一个注解类Retention * 在注解类上使用另一个注解类，那么被使用的注解类就称为元注解 */@Retention(RetentionPolicy.RUNTIME)//Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)//Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类、属性、方法身上等成分/* * @Retention(RetentionPolicy.SOURCE) * 这个注解的意思是让MyAnnotation注解只在java源文件中存在，编译成.class文件后注解就不存在了 * @Retention(RetentionPolicy.CLASS) * 这个注解的意思是让MyAnnotation注解在java源文件(.java文件)中存在， * 编译成.class文件后注解也还存在，被MyAnnotation注解类标识的类被类加载器加载到内存中后 * MyAnnotation注解就不存在了 *//* * 这里是在注解类MyAnnotation上使用另一个注解类，这里的Retention称为元注解。 * Retention注解括号中的"RetentionPolicy.RUNTIME"意思是让MyAnnotation这个注解的 * 生命周期一直程序运行时都存在 */public @interface MyAnnotation &#123;&#125; 把自定义的注解加到某个类上：12@ MyAnnotation public class AnnotationUse&#123;&#125; 用反射测试进行测试AnnotationUse的定义上是否有@MyAnnotation12345678910111213141516171819202122// 这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上@MyAnnotationpublic class AnnotationUse &#123; public static void main(String[] args) &#123; // 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查 if (AnnotationUse.class.isAnnotationPresent(MyAnnotation.class)) &#123; /* * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的 * 一旦在某个类上使用了@MyAnnotation，那么 * 这个MyAnnotation类的实例对象annotation就会被创建出来了 */ MyAnnotation annotation = (MyAnnotation) AnnotationUse.class .getAnnotation(MyAnnotation.class); // 打印MyAnnotation对象，这里输出的结果为：@cn.itcast.day2.MyAnnotation() System.out.println(annotation); &#125; &#125;&#125; 三、元注解（meta-annotation）Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 @Target @Retention @Documented @Inherited 1、@Target@Target说明了Annotation所修饰的对象范围（被描述的注解可以用在什么地方） CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 12@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)// @Target(ElementType.FIELD) 2、@Retention@Retention定义了该Annotation被保留的时间长短。 SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 1@Retention(RetentionPolicy.RUNTIME) 2.1 声明周期一个注解的生命周期有三个阶段：java源文件是一个阶段，class文件是一个阶段，内存中的字节码是一个阶段。javac把源文件编译成.class文件时，有可能去掉里面的注解，类加载器把.class文件加载到内存时也有可能去掉里面的注解。 2.2 Java API中是这样定义的@Deprecated的123@Documented@Retention(value=RUNTIME)public @interface Deprecated 2.3 Java API中是这样定义的@Override的123@Target(value=METHOD)@Retention(value=SOURCE)public @interface Override @Override是给javac看的，编译完以后就@Override注解就没有价值了 2.4 Java API中是这样定义的@SuppressWarnings的123@Target(value=&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)@Retention(value=SOURCE)public @interface SuppressWarnings @SuppressWarnings也是给javac看的 3、@Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; 4、@Inherited@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 四、为注解增加属性注解可以看成是一种特殊的类，既然是类，那自然可以为类添加属性 1、添加属性语法：类型 属性名() default 默认值; || 类型 属性名(); 1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)// Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)public @interface MyAnnotation &#123; // String color(); String color() default "blue"; // 为属性指定缺省值 String value(); // 定义一个名称为value的属性&#125; 2、应用属性123456789@MyAnnotation(color = "red") //应用MyAnnotation注解的color属性public class MyAnnotationTest &#123; public static void main(String[] args) &#123; // 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法 MyAnnotation annotation = (MyAnnotation) MyAnnotationTest.class .getAnnotation(MyAnnotation.class); System.out.println(annotation.color()); //输出red &#125;&#125; 3、value属性如果一个注解中有一个名称为value的属性，且你只想设置value属性，那么可以省略掉“value=”部分 12@SuppressWarnings("deprecation")@MyAnnotation("hello world")]]></content>
      <tags>
        <tag>java</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequestParam等注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F17%2FRequestParam%E7%AD%89%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解类型handler method参数绑定常用的注解，根据处理的Request内容部分不同分为四类： 处理requet uri 部分的注解：@PathVariable ​ 注：指uri template中variable，不含queryString部分 处理request header部分的注解： @RequestHeader、@CookieValue 处理request body部分的注解：@RequestParam、@RequestBody 处理attribute类型是注解： @SessionAttributes、 @ModelAttribute @PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定传过来的值到方法的参数上。 123456789@RequestMapping("/owners/&#123;ownerId&#125;")public class RelativePathUriTemplateController &#123; // @RequestMapping("/pets/&#123;petId&#125;") @RequestMapping(value = "/pets/&#123;petId&#125;", method = RequestMethod.POST) public void findPet(@PathVariable String ownerId, @PathVariable String petId) &#123; // implementation omitted &#125;&#125; 注： 若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(&quot;name&quot;)指定uri template中的名称。 1@PathVariable("ownerId") String owner_id @RequestHeader@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 123456@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo( @RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) &#123; //...&#125; @CookieValue@CookieValue可以把Request header中关于cookie的值绑定到方法的参数上 1JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 1234@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; //...&#125; @RequestParam 常用来处理简单类型的绑定，通过Request.getParameter()获取的String可直接转换为简单类型的情况 可以处理get 方式中queryString的值 可以处理post方式中body data的值 用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST 该注解有两个属性： value、required value用来指定要传入值的id名称 required用来指示参数是否必须绑定 12345678@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm( @RequestParam(value = "petId", required = false) int petId) &#123; // ... &#125;&#125; 注： 可以不使用@RequestParam，直接接收。此时要求controller方法中的参数名称要一致 1234567@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm(int petId) &#123; // ... &#125;&#125; @RequestBody常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容 application/json application/xml 通过使用HandlerAdapter配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 字符串解析： 123456789$.ajax(&#123; url: "/login", type: "POST", data: '&#123;"userName":"admin","pwd","admin123"&#125;', content - type: "application/json charset=utf-8", success: function(data) &#123; alert("request success ! "); &#125;&#125;); 12345@requestMapping("/login")public void login(@requestBody String userName, @requestBody String pwd) &#123; System.out.println(userName + " ：" + pwd);&#125;// 将JSON字符串中的两个变量的值分别赋予了两个字符串 对象解析： 12345@RequestMapping(value = "/something", method = RequestMethod.PUT)public void handle(@RequestBody User user) &#123; System.out.println(user.userName + " ：" + user.pwd);&#125;// 将JSON字符串中的值赋予user中对应的属性上 注： JSON字符串中的key必须对应user中的属性名，否则是请求不过去的 @RequestBody最多只能有一个，而@RequestParam()可以有多个 @SessionAttributes用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象。 123456@RequestMapping("/editPet.do")// @SessionAttributes("pet")@SessionAttributes(value = &#123; "pet" &#125;, types = &#123; Integer.class &#125;)public class EditPetForm &#123; // ...&#125; 注：@SessionAttributes注解只能在类上使用，不能在方法上使用 @ModelAttribute、@RequestAttribute123456789@ModelAttributevoid beforeInvokingHandlerMethod(HttpServletRequest request) &#123; request.setAttribute("foo", "hello world");&#125;@RequestMapping(value = "/data/custom", method = RequestMethod.GET)public @ResponseBody String custom(@RequestAttribute("foo") String foo) &#123; return "Got 'foo' request attribute value '" + foo + "'";&#125; 1234&lt;div id="customArgs"&gt; &lt;h3&gt;Custom Resolvable Web Arguments&lt;/h3&gt; &lt;a id="customArg" class="textLink" href="/data/custom"&gt;Custom&lt;/a&gt;&lt;/div&gt; 12345678910$("a.textLink").click(function() &#123; var link = $(this); $.ajax(&#123; url: link.attr("href"), dataType: "text", success: function(text) &#123; alert(text) &#125; &#125;);&#125;); 1Got &apos;foo&apos; request attribute value &apos;hello world&apos;]]></content>
      <tags>
        <tag>RequestParam</tag>
        <tag>RequestBody</tag>
        <tag>PathVariable</tag>
        <tag>RequestAttribute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar-MANIFEST.MF文件]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar-MANIFEST-MF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容： 1234567891011Manifest-Version: 1.0Created-By: Apache Ant 1.5.1Extension-Name: Struts FrameworkSpecification-Title: Struts FrameworkSpecification-Vendor: Apache Software FoundationSpecification-Version: 1.1Implementation-Title: Struts FrameworkImplementation-Vendor: Apache Software FoundationImplementation-Vendor-Id: org.apacheImplementation-Version: 1.1Class-Path: commons-beanutils.jar commons-collections.jar commons-digester.jar 一般属性 Manifest-Version 用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version ：定义jar文件的签名版本 Class-Path ：应用程序或者类装载器使用该值来构建内部的类搜索路径 应用程序相关属性 Main-Class 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过java -jar x.jar来运行该jar文件。]]></content>
      <tags>
        <tag>jar</tag>
        <tag>MANIFEST.MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 修改默认的本地仓库Maven 本地仓库默认被创建在 %USER_HOME%目录下。要修改默认位置，在 %M2_HOME%\conf目录中的 Maven 的 settings.xml文件中定义另一个路径 123456&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;&lt;/settings&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven-pom配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven-pom%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[POM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件。 maven的协作相关属性一个pom.xml的定义必须包含modelVersion、groupId、artifactId和version这四个元素，当然这其中的元素也是可以从它的父项目中继承的。使用groupdId:artifactId:version`的形式来唯一确定一个项目。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 含义：组织标识，定义了项目属于哪个组 用途：此名称则是本地仓库中的路径 例如：otowa.user.dao，在M2_REPO目录下，将是: otowa/user/dao目录 命名规范:项目名称，模块，子模块 --&gt; &lt;groupId&gt;otowa.user.dao&lt;/groupId&gt; &lt;!-- 含义：项目名称，定义当前Maven项目在组中唯一的ID 用途：例如：user-dao，在M2_REPO目录下，将是：otowa/user/dao/user-dao目录 命名规范:唯一就好 --&gt; &lt;artifactId&gt;user-dao&lt;/artifactId&gt; &lt;!-- 含义：项目当前的版本号 用途：例如：0.0.1-SNAPSHOT 在M2_REPO目录下，将是：otowa/user/dao/user-dao/0.0.1-SNAPSHOT目录 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt; &lt;name&gt;maven&lt;/name&gt;&lt;/project&gt; 引入依赖123456789101112131415161718192021222324252627&lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 定义常量123456&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt; &lt;/properties&gt;]]></content>
      <tags>
        <tag>maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-生成jar包]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava-%E7%94%9F%E6%88%90jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一、制作只含有字节码文件的jar包我们先来看只含有字节码文件，即只含有.class文件的jar包怎么制作，这是最简单的形式 1、最简单的jar包——直接输出hello最终生成的jar包结构 META-INF Hello.class 方法步骤 （1）用记事本写一个Hello.java的文件 12345class Hello&#123; public static void main(String[] agrs)&#123; System.out.println("hello"); &#125;&#125; （2）用命令行进入到该目录下，编译这个文件 1javac Hello.java （3）将编译后的Hello.class文件打成jar包 1jar -cvf hello.jar Hello.class c 表示要创建一个新的jar包 v 表示创建的过程中在控制台输出创建过程的一些信息 f 表示给生成的jar包命名 （4）运行jar包 12java -jar hello.jar# 这时会报如下错误 hello.jar中没有主清单属性 （5）添加Main-Class属性 用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件 12Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation) 添加Main-Class: Hello ，再次运行java -jar hello.jar ，此时成功在控制台看到 hello 2、含有两个类的jar包——通过调用输出hello最终生成的jar包结构 META-INF Tom.class Hello.class （1）用记事本写一个Hello.java和一个Tom.java的文件 12345class Hello &#123; public static void main(String[] agrs) &#123; System.out.println("hello"); &#125;&#125; 12345class Tom &#123; public static void speak() &#123; System.out.println("hello"); &#125;&#125; （2）编译 1javac Hello.java 此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom （3）打jar包，这次我们换一种方式直接定义Main-Class 123Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation)Main-Class: Hello 事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下 1jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class 该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件 （4）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 3、有目录结构的jar包——通过引包并调用输出hello最终生成的jar包结构 META-INF com ​ Tom.class Hello.class 我们将上一个稍稍变化一下，将Tom类放在com包下。 12package com;# Tom.java需要在第一行声明自己的包名 12import com.Tom;# Hello.java需要引入Tom这个类 （1）编译Hello.java （2）打jar包，同样准备好MENIFEST文件 12jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com # 最后一个com表示把文件夹下的所有文件都打进jar包 （3）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 （4）优化过程 我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。 在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令 12javac Hello.java -d target# 将所有编译后的文件，都放到target文件夹下 将META-INF文件夹也复制到target目录下，进入这个目录，输入如下命令 12jar -cvfm hello.jar META-INF\MENIFEST.MF * # 最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里 原文]]></content>
      <tags>
        <tag>jar</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类加载器]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器类加载器负责将.class文件加载到内存中，并为类生成一个java.lang.Class实例。 一旦一个类被加载入JVM中，同一个类就不会被再次加入了。在JVM中用来判断类的唯一性标识是：类名、类所在的包名和类加载器。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构： BootStrap ClassLoader：根类加载器 Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 根类加载器 （bootstrap class loader）：它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，并不继承自java.lang.ClassLoader。没有父加载器 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 父加载器为根类加载器 扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。父加载器为扩展类加载器 系统类加载器是纯Java类，是java.lang.ClassLoader类的子类 自定义类加载器（custom class loader）：除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 类加载的父委托机制从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。 在父委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器，各个加载器按照父子关系形成了树形结构。 当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由loader1本身加载Sample类。 注： 这里的父加载器概念并不是指类的继承关系，子加载器不一定继承了父加载器（其实是组合的关系） 每个加载器都优先尝试用父类加载，若父类不能加载则自己尝试加载；若成功则返回Class对象给子类，若失败则告诉子类让子类自己加载。所有都失败则抛出ClassNotFoundException异常]]></content>
      <tags>
        <tag>java</tag>
        <tag>ClassLoader</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch基本使用]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F11%2FElasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面向文档通常，应用程序中的对象拥有复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。如果要把这些对象存储在关系型数据库中，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将对象扁平化来适应表结构，而且又不得不在每次查询时重新构造对象： 一个简单字段对应一列 一个对象字段需要新建表、引用主键 一个数组字段需要新建表、引用主键、每个数组元素对应一行 Elasticsearch使用JavaScript Object Notation或者JSON作为文档的序列化格式。JSON序列化被大多数编程语言所支持，并且已经成为 NoSQL领域的标准格式。 注：文档 =》对象 请求格式一个Elasticsearch请求和任何HTTP请求一样由若干相同的部件组成： 1curl -X &lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; 被 &lt; &gt; 标记的部件： 参数 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE PROTOCOL http 或者 https HOST Elasticsearch 集群中任意节点的主机名 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径，由index、type、id 等组成 QUERY_STRING 任意可选的查询字符串参数，?pretty 将格式化地输出 JSON 返回值 BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个： 123456curl -X GET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 搜索格式 搜索所有type 1GET /megacorp/employee/_search 注：使用 _search代替具体的id 参数搜索 12# 查询字符串GET /megacorp/employee/_search?q=last_name:Smith 123456789# match 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;Smith&quot; &#125; &#125;&#125; 123456789101112131415161718# filter 过滤器GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;smith&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &#125; &#125; &#125; &#125;&#125; 123456789# match_phrase 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;about&quot; : &quot;rock climbing&quot; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本知识]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类名与文件名 一个Java文件中只能有一个public类 如果文件中存在public类，文件名必须与public类名一致 如果文件中没有public类，文件名与类名可以不一致 注：一个源文件中，用class关键字定义了几个类，编译的时候就会产生几个字节码文件 包名与文件名.java文件中的包名必须与物理文件夹对应 123// Something.java 文件package net.java.util;public class Something&#123;&#125; 物理存储位置应该是：net/java/util/Something.java 注： 同一个包中的类名字不能相同 同级包下的类引用不需要import，可以直接调用 Java编译器默认导入java.lang包 主入口方法1public static void main(String[] args) &#123;&#125; 该java类由java虚拟机调用，所以java类应把该方法暴露，故用public 既然由JVM调用该方法，肯定不能new 一个对象再由对象调用该方法，应直接由JVM调用故用static 给JVM返回东西是无意义的 ，故用void 括号里的参数是由JVM传给该方法的，具体可为： 从cmd控制台传入 从开发环境IDE配置参数传入 装箱与拆箱所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型 。 12345678910public class Test &#123; public static void main(String args[]) &#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱// 然后，为了使x能进行加运算，所以要对x进行拆箱 创建数组1dataType[] arrayRefVar = new dataType[arraySize]; 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 重写与重载重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
