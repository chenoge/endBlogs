<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Elasticsearch基本使用]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F11%2FElasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面向文档通常，应用程序中的对象拥有复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。如果要把这些对象存储在关系型数据库中，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将对象扁平化来适应表结构，而且又不得不在每次查询时重新构造对象： 一个简单字段对应一列 一个对象字段需要新建表、引用主键 一个数组字段需要新建表、引用主键、每个数组元素对应一行 Elasticsearch使用JavaScript Object Notation或者JSON作为文档的序列化格式。JSON序列化被大多数编程语言所支持，并且已经成为 NoSQL领域的标准格式。 注：文档 =》对象 请求格式一个Elasticsearch请求和任何HTTP请求一样由若干相同的部件组成： 1curl -X &lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; 被 &lt; &gt; 标记的部件： 参数 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE PROTOCOL http 或者 https HOST Elasticsearch 集群中任意节点的主机名 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径，由index、type、id 等组成 QUERY_STRING 任意可选的查询字符串参数，?pretty 将格式化地输出 JSON 返回值 BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个： 123456curl -X GET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 搜索格式 搜索所有type 1GET /megacorp/employee/_search 注：使用 _search代替具体的id 参数搜索 12# 查询字符串GET /megacorp/employee/_search?q=last_name:Smith 123456789# match 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;Smith&quot; &#125; &#125;&#125; 123456789101112131415161718# filter 过滤器GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;smith&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &#125; &#125; &#125; &#125;&#125; 123456789# match_phrase 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;about&quot; : &quot;rock climbing&quot; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本知识]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类名与文件名 一个Java文件中只能有一个public类 如果文件中存在public类，文件名必须与public类名一致 如果文件中没有public类，文件名与类名可以不一致 注：一个源文件中，用class关键字定义了几个类，编译的时候就会产生几个字节码文件 包名与文件名.java文件中的包名必须与物理文件夹对应 123// Something.java 文件package net.java.util;public class Something&#123;&#125; 物理存储位置应该是：net/java/util/Something.java 注： 同一个包中的类名字不能相同 同级包下的类引用不需要import，可以直接调用 Java编译器默认导入java.lang包 主入口方法1public static void main(String[] args) &#123;&#125; 该java类由java虚拟机调用，所以java类应把该方法暴露，故用public 既然由JVM调用该方法，肯定不能new 一个对象再由对象调用该方法，应直接由JVM调用故用static 给JVM返回东西是无意义的 ，故用void 括号里的参数是由JVM传给该方法的，具体可为： 从cmd控制台传入 从开发环境IDE配置参数传入 装箱与拆箱所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型 。 12345678910public class Test &#123; public static void main(String args[]) &#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱// 然后，为了使x能进行加运算，所以要对x进行拆箱 创建数组1dataType[] arrayRefVar = new dataType[arraySize]; 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 重写与重载重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
