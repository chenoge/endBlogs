<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[函数扩展-尾调用和尾递归]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95-%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[一、尾调用尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 1234567891011121314151617181920212223242526272829// 函数f的最后一步是调用函数g，这就叫尾调用function f(x) &#123; return g(x);&#125;// 尾调用不一定出现在函数尾部，只要是最后一步操作即可function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125;// 以下三种情况，都不属于尾调用// 情况一function f(x) &#123; let y = g(x); return y;&#125;// 情况二function f(x) &#123; return g(x) + 1;&#125;// 情况三function f(x) &#123; g(x);&#125; 二、尾调用优化函数调用会在内存形成一个调用帧（call frame），保存调用位置和内部变量等信息。所有的调用帧，就形成一个调用栈（call stack）。 如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行尾调用优化。 123456789// 不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量onefunction addOne(a) &#123; var one = 1; function inner(b) &#123; return b + one; &#125; return inner(a);&#125; 三、尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生栈溢出错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出错误。 123456789101112131415// 计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120// 改写成尾递归，只保留一个调用记录，复杂度 O(1) function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 123456789101112131415161718192021222324// 非尾递归的 Fibonacci 数列function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出// 尾递归优化过的 Fibonacci 数列// 只要函数参数使用了默认值、解构赋值、或者扩展运算符，// 那么函数内部就不能显式设定为严格模式，否则会报错function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 注：ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。（验证：结论错误，Fibonacci2是正常模式） 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。]]></content>
      <tags>
        <tag>尾调用</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符优先级和短路运算]]></title>
    <url>%2F2019%2F01%2F16%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一、短路运算当逻辑与&amp;&amp;的第一个操作数的值是false时，直接返回第一个操作数的值，不再对第二个操作数进行计算 当逻辑或||的第一个操作数的值是true时，直接返回第一个操作数的值，不再对第二个操作数进行计算 二、运算符优先级优先级表格 三、求值顺序12345678910111213141516function fn01() &#123; console.log('fn01'); return false;&#125;function fn02() &#123; console.log('fn02'); return true;&#125;function fn03() &#123; console.log('fn03'); return true;&#125;console.log(fn01() || fn02() &amp;&amp; fn03()); // fn01 =&gt; fn02 =&gt; fn03 =&gt; true 要注意区分优先级、结合性、求值顺序三者的区别。 这三个是不同的概念，却经常被混淆。通过AST来看就很容易理解：（假设源码是从左到右输入的） 所谓优先级，就是不同操作相邻出现时，AST节点与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵AST是以后序遍历求值的，显然节点离根越远就越早被求值。 所谓结合性，就是当同类操作相邻出现时，操作的先后顺序同AST节点与根的距离的关系。如果是左结合，则先出现的操作对应的AST节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。 所谓求值顺序，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历左子节点再遍历右子节点就是从左到右的求值顺序，反之则是从右到左的求值顺序。 这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是解析器根据语法生成AST时就已经决定好的，后者则是解释执行或者生成代码而去遍历AST时决定的。 在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。 对应console.log(fn01() || fn02() &amp;&amp; fn03())，AST是： 12345 || / \fn01() &amp;&amp; / \ fn02() fn03() 表达式层面上，代码的执行就是后序遍历这棵AST而已。 优先级：在相邻的两个运算符 || 与 &amp;&amp; 中，&amp;&amp; 比 || 离AST的根更远所以优先级更高 结合性：这里没有相邻的同优先级运算符所以展现不出 || 与 &amp;&amp; 的结合性，虽然它们都是左结合的 求值顺序：JavaScript的求值顺序就是从左向右的。对这棵AST来说就是在后序遍历时，每个节点的求值过程是先遍历左子树，再遍历右子树，然后对自己求值。 AST生成传送门 Esprima: Parser AST Visualization on browser]]></content>
      <tags>
        <tag>运算符</tag>
        <tag>短路</tag>
        <tag>优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量对象]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一、freezeObject.freeze()方法可以冻结（浅冻结 ）一个对象，冻结指的是不能向这个对象添加新的属性（增），不能修改其已有属性的值（改），不能删除已有属性（删），以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回传递的对象，而不是创建一个被冻结的副本 。 12345678// 浅冻结let obj1 = Object.freeze(&#123;internal: &#123;&#125;&#125;);obj1.internal.a = 'aValue';obj1.freeze = 'freeze'; // 在严格模式，会抛出TypeErrors错误obj1.internal.a; // 'aValue'obj1.freeze; // undefined 注：通过Object.isFrozen(obj)可以判断对象是否被冻结 二、sealObject.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。 注：不会影响从原型链上继承的属性。但 __proto__属性的值不能通过对象直接修改。 三、preventExtensionsObject.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。 注：Object.preventExtensions()仅阻止添加自身的属性。但属性仍然可以添加到对象原型 。]]></content>
      <tags>
        <tag>常量</tag>
        <tag>freeze</tag>
        <tag>seal</tag>
        <tag>preventExtensions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写出符合开放封闭原则的代码]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E7%AC%A6%E5%90%88%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在面向对象的程序设计中，开放封闭原则(OCP)是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放封闭原则的。 当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。 一、故事背景假设我们是一个大型 Web 项目的维护人员，在接手这个项目时，发现它已经拥有10万行以上的JavaScript代码和数百个 JS 文件。 不久后接到了一个新的需求，即在 window.onload 函数中打印出页面中的所有节点数量。这 当然难不倒我们了。于是我们打开文本编辑器，搜索window.onload函数在文件中的位置，在函数内部添加以下代码 1234window.onload = function()&#123; // 原有代码略 console.log( document.getElementsByTagName( '*' ).length ); &#125;; 二、应用AOP1234567891011Function.prototype.after = function( afterfn )&#123; var __self = this; return function()&#123; var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments ); return ret; &#125; &#125;;window.onload = ( window.onload || function()&#123;&#125; ).after(function()&#123; console.log( document.getElementsByTagName( '*' ).length );&#125;); 通过AOP装饰函数的方式，我们完全不用理会从前 window.onload 函数的内部实现，就算拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以互不影响。 三、编写符合OCP代码的方法过多的条件分支语句是造成程序违反开放封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。 利用对象的多态性来让程序遵守开放封闭原则，是一个常用的技巧 放置挂钩 放置挂钩(hook)也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。 回调函数 回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。 四、总结开放封闭原则是一个看起来比较虚幻的原则，但我们还是能找到一些让程序尽量遵守开放封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来。 通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。]]></content>
      <tags>
        <tag>开放封闭原则</tag>
        <tag>OCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式-装饰者模式]]></title>
    <url>%2F2019%2F01%2F04%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、装饰者模式装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。 12装饰者模式将一个对象嵌入到另一个对象之中，实际上相当于这个对象被另一个对像包装起来，形成一条包装链。请求随着这条包装链依次传递到所有的对象，每个对象都有处理这条请求的机会。 二、装饰函数在JavaScript中可以很方便的给某个对象扩展属性和方法，但却很难在不改动某个函数源代码的情况下，给该函数添加一些额外的功能。也就是在代码运行期间，我们很难切入某个函数的执行环境。 1、使用装饰者模式例子123456789101112/对window.onload的处理window.onload=function () &#123; console.log('test');&#125;;var _onload= window.onload || function () &#123;&#125;;window.onload=function () &#123; _onload(); console.log('自己的处理函数');&#125;; 2、使用AOP（面向切面编程）装饰函数在需要执行的函数之前执行某个新添加的功能函数 12345678// 封装的before函数Function.prototype.before = function(beforefn) &#123; var __self = this; return function() &#123; beforefn.apply(this, arguments); return __self.apply(this, arguments); &#125;;&#125;; 在需要执行的函数之后执行某个新添加的功能函数 123456789// 封装的after函数Function.prototype.after = function( afterfn )&#123; var __self = this; return function()&#123; var ret = __self.apply( this, arguments ); afterfn.apply( this, arguments ); return ret; &#125; &#125;; 不污染Function原型的做法 1234567891011121314var before = function(fn, beforeFn) &#123; return function() &#123; beforeFn.apply(this, arguments); return fn.apply(this, arguments); &#125;;&#125;;function fn() &#123; console.log('fn') &#125;function beforeFn() &#123; console.log('beforeFn') &#125;fn = before(fn, beforeFn);fn(); 3、使用装饰者模式动态的改变ajax函数12345678910111213141516171819202122Function.prototype.before = function(beforefn) &#123; var _this = this; return function() &#123; beforefn.apply(this, arguments); return _this.apply(this, arguments); &#125;;&#125;;//给ajax请求动态添加参数的例子var ajax = function(type, url, param) &#123; console.log(param);&#125;;var getToken = function() &#123; return 'Token';&#125;;ajax = ajax.before(function(type, url, param) &#123; param.token = getToken();&#125;);ajax('get', 'http://www.jn.com', &#123; name: 'zhiqiang' &#125;);]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端中的IoC理念]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84IoC%E7%90%86%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[原文 一、什么是 IoCIoC 的全称叫做 Inversion of Control，可翻译为为「控制反转」或「依赖倒置」，它主要包含了三个准则： 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象 抽象不应该依赖于具体实现，具体实现应该依赖于抽象 面向接口编程 而不要面向实现编程 概念总是抽象的，所以下面将以一个例子来解释上述的概念。假设需要构建一款应用叫 App，它包含一个路由模块 Router 和一个页面监控模块 Track，一开始可能会这么实现： 1234567891011121314151617181920212223242526272829// app.jsimport Router from './modules/Router';import Track from './modules/Track';class App &#123; constructor(options) &#123; this.options = options; this.router = new Router(); this.track = new Track(); this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.router.to('home'); this.track.tracking(); this.options.onReady(); &#125;); &#125;&#125;// index.jsimport App from 'path/to/App';new App(&#123; onReady() &#123; // do something here... &#125;,&#125;); 嗯，看起来没什么问题，但是实际应用中需求是非常多变的，可能需要给路由新增功能（比如实现 history 模式）或者更新配置（启用 history, new Router({ mode: &#39;history&#39; })）。这就不得不在 App 内部去修改这两个模块，这是一个 INNER BREAKING 的操作，而对于之前测试通过了的 App 来说，也必须重新测试。 很明显，这不是一个好的应用结构，高层次的模块 App 依赖了两个低层次的模块 Router 和 Track，对低层次模块的修改都会影响高层次的模块 App。那么如何解决这个问题呢，解决方案就是接下来要讲述的 依赖注入（Dependency Injection）。 二、依赖注入所谓的依赖注入，简单来说就是把高层模块所依赖的模块通过传参的方式把依赖「注入」到模块内部，上面的代码可以通过依赖注入的方式改造成如下方式： 12345678910111213141516171819202122232425262728293031// app.jsclass App &#123; constructor(options) &#123; this.options = options; this.router = options.router; this.track = options.track; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.router.to('home'); this.track.tracking(); this.options.onReady(); &#125;); &#125;&#125;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';new App(&#123; router: new Router(), track: new Track(), onReady() &#123; // do something here... &#125;,&#125;); 可以看到，通过依赖注入解决了上面所说的 INNER BREAKING 的问题，可以直接在 App 外部对各个模块进行修改而不影响内部。 是不是就万事大吉了？理想很丰满，但现实却是很骨感的，没过两天产品就给你提了一个新需求，给 App 添加一个分享模块 Share。这样的话又回到了上面所提到的 INNER BREAKING 的问题上：你不得不对 App 模块进行修改加上一行 this.share = options.share，这明显不是我们所期望的。 虽然 App 通过依赖注入的方式在一定程度上解耦了与其他几个模块的依赖关系，但是还不够彻底，其中的 this.router 和 this.track 等属性其实都还是对「具体实现」的依赖，明显违背了 IoC 思想的准则，那如何进一步抽象 App 模块呢。 三、面向接口编程123456789101112131415161718192021class App &#123; static modules = [] constructor(options) &#123; this.options = options; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.initModules(); this.options.onReady(this); &#125;); &#125; static use(module) &#123; Array.isArray(module) ? module.map(item =&gt; App.use(item)) : App.modules.push(module); &#125; initModules() &#123; App.modules.map( module =&gt; module.init &amp;&amp; typeof module.init == 'function' &amp;&amp; module.init(this) ); &#125;&#125; 经过改造后 App 内已经没有「具体实现」了，看不到任何业务代码了，那么如何使用 App 来管理我们的依赖呢： 123456789101112131415161718192021222324252627282930313233343536// modules/Router.jsimport Router from 'path/to/Router';export default &#123; init(app) &#123; app.router = new Router(app.options.router); app.router.to('home'); &#125;&#125;;// modules/Track.jsimport Track from 'path/to/Track';export default &#123; init(app) &#123; app.track = new Track(app.options.track); app.track.tracking(); &#125;&#125;;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';App.use([Router, Track]);new App(&#123; router: &#123; mode: 'history', &#125;, track: &#123; // ... &#125;, onReady(app) &#123; // app.options ... &#125;,&#125;); 可以发现 App 模块在使用上也非常的方便，通过 App.use() 方法来「注入」依赖，在 ./modules/some-module.js 中按照一定的「约定」去初始化相关配置，比如此时需要新增一个 Share 模块的话，无需到 App 内部去修改内容： 123456789101112131415161718192021// modules/Share.jsimport Share from 'path/to/Share';export default &#123; init(app) &#123; app.share = new Share(); app.setShare = data =&gt; app.share.setShare(data); &#125;&#125;;// index.jsApp.use(Share);new App(&#123; // ... onReady(app) &#123; app.setShare(&#123; title: 'Hello IoC.', description: 'description here...', // some other data here... &#125;); &#125;&#125;); 直接在 App 外部去 use 这个 Share 模块即可，对模块的注入和配置极为方便。 这其实就是 IoC 思想中对「面向接口编程 而不要面向实现编程」这一准则的很好的体现。App 不关心模块具体实现了什么，只要满足对 接口 init 的「约定」就可以了。 四、总结App 模块此时应该称之为「容器」比较合适了，跟业务已经没有任何关系了，它仅仅只是提供了一些方法来辅助管理注入的依赖和控制模块如何执行。 控制反转（Inversion of Control）是一种「思想」，依赖注入（Dependency Injection）则是这一思想的一种具体「实现方式」，而这里的 App 则是辅助依赖管理的一个「容器」。 注：直接依赖 =》 传参注入依赖 =》 接口注入依赖]]></content>
      <tags>
        <tag>IoC</tag>
        <tag>依赖注入</tag>
        <tag>控制反转</tag>
        <tag>面向接口编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx使用include命令拆分配置文件]]></title>
    <url>%2F2019%2F01%2F03%2Fnginx%E4%BD%BF%E7%94%A8include%E5%91%BD%E4%BB%A4%E6%8B%86%E5%88%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[include123Syntax: include file | mask;Default: —Context: any Includes another file, or files matching the specified mask, into configuration. Included files should consist of syntactically correct directives and blocks. 12include mime.types;include vhosts/*.conf; #通配符写法 注：适用范围是任何地方，include命令相当于是复制文件内容到引用的地方]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>include</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS在IE中的兼容问题]]></title>
    <url>%2F2019%2F01%2F02%2FJS%E5%9C%A8IE%E4%B8%AD%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[标识符与保留字保留字是JavaScript语言中定义具有特殊含义的标识符，保留字不能作为标识符使用。JavaScript语言中定义了一些具有专门的意义和用途的保留字，这些保留字称为关键字。 标识符：变量，属性，数组，函数名称 SCRIPT1010缺少标识符 ，一般在IE浏览器下，使用了保留字就会报这个错误，如： default, delete 等 SCRIPT10281234567// 对象最后一项是不允许有逗号的，跟json的规则相似let point = &#123; x: 1.2, y: -3.4 &#125;; // 合法声明let point = &#123; x: 1.2, y: -3.4, &#125;; // 缺少标识符、字符串或数字// 使用了保留字let point = &#123; x: 1.2, 'delete': -3.4 &#125;; // 合法声明let point = &#123; x: 1.2, delete: -3.4 &#125;; // 缺少标识符、字符串或数字 对象文字值的属性必须是标识符、字符串或数字。 对象文字值（也称为“对象初始值设定项”）由逗号分隔的“属性:值”对的列表构成，其中各对都括在括号中。 注：使用打包工具会存在&#39;delete&#39;变为delete的情况，最好不要使用保留字作为标识符。 版本1234// 相同工程：线上环境 // 存在以上问题// IE11 浏览器的 navigator.userAgent"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; Tablet PC 2.0)" 注：IE11不存在以上问题 1234// 相同工程：开发环境、vue、webpack-dev-server // 不存在以上问题// IE11 浏览器的 navigator.userAgent"Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; Tablet PC 2.0; rv:11.0) like Gecko" 注：因为项目中未使用X-UA-Compatible指定IE内核版本 12&lt;!--使用后，线上环境恢复正常，与开发环境一致--&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt; 检测页面IE版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function IEVersion() &#123; //取得浏览器的userAgent字符串 var userAgent = navigator.userAgent; //判断是否IE&lt;11浏览器 var isIE = userAgent.indexOf("compatible") &gt; -1 &amp;&amp; userAgent.indexOf("MSIE") &gt; -1; //判断是否IE的Edge浏览器 var isEdge = userAgent.indexOf("Edge") &gt; -1 &amp;&amp; !isIE; //判断是否IE11浏览器 var isIE11 = userAgent.indexOf('Trident') &gt; -1 &amp;&amp; userAgent.indexOf("rv:11.0") &gt; -1; if (isEdge) &#123; return 'edge'; //edge &#125; if (isIE11) &#123; return 11; //IE11 &#125; if (isIE) &#123; var reIE = new RegExp("MSIE (\\d+\\.\\d+);"); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp["$1"]); if (fIEVersion == 7) &#123; return 7; &#125; if (fIEVersion == 8) &#123; return 8; &#125; if (fIEVersion == 9) &#123; return 9; &#125; if (fIEVersion == 10) &#123; return 10; &#125; &#123; return 6; //IE版本&lt;=7 &#125; &#125; return -1; //不是ie浏览器&#125;]]></content>
      <tags>
        <tag>js</tag>
        <tag>IE</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url长度限制]]></title>
    <url>%2F2018%2F12%2F29%2Furl%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、HTTP协议HTTP协议不对url的长度设置任何先验限制 服务器必须能够处理它们所服务的任何资源的URI，并且如果它们提供可以生成这种URI的基于GET的表单，则应该能够处理无限长度的URI。 如果URI长于服务器可以处理的长度，服务器应该返回414（Request-URI Too Long）状态 。 二、浏览器1、IE：IE浏览器对url长度限制是2083（2K+53）字符，超过这个限制，则自动截断 若是form提交则提交按钮不起作用 注：实测超过2048字符会截断（2018-12-3） 2、firefox：firefox浏览器对url长度限制为 65,536字符 实际上有效的URL最大长度不少于100,000个字符 3、chrome：chrome浏览器对url长度限制为8182字符 4、Safari：Safari浏览器对url长度限制至少为80,000字符 5、Opera：Opera 浏览器对url长度限制为190 000字符 注： URL只能使用英文字母、阿拉伯数字和某些标点符号。不能使用其他文字和符号，否则必须编码后使用 即使是2048个ASCII字符也能满足大多数的使用场景，可以放心使用。 三、服务器1、Apache：Apache能接受url长度限制为8,192 字符 2、ngnix：可以通过修改配置来改变url长度限制 12client_header_buffer_size 1k # 默认值large_client_header_buffers 4 4k/8k # 默认值 四、URL编码原文 网页路径的编码，用的是utf-8编码 1http://zh.wikipedia.org/wiki/春节 查询字符串的编码，用的是操作系统的默认编码 1http://www.baidu.com/s?wd=春节 GET和POST方法的编码，用的是网页的编码 12// 在已打开的网页上，直接用Get或Post方法发出HTTP请求&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&gt; 在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码 1三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用 注：文章太久远了，可能都默认utf-8了（猜测，未验证2018-12-30）]]></content>
      <tags>
        <tag>url</tag>
        <tag>长度限制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间戳、时区以及时间格式]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%B6%E5%8C%BA%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、时间戳时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总毫秒数。 注：时间戳是不会跟着时区的改变而改变，同一时刻的时间戳都是相同的。 二、GMT 和UTC格林威治标准时间GMT1十七世纪，格林威治皇家天文台为了海上霸权的扩张计画而进行天体观测。1675年旧皇家观测所(Old Royal Observatory) 正式成立，到了1884年决定以通过格林威治的子午线作为划分地球东西两半球的经度零度。观测所门口墙上有一个标志24小时的时钟，显示当下的时间，对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间(Greenwich Mean Time，简称G.M.T.)的由来，标示在手表上，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。 世界协调时间UTC1多数的两地时间表都以GMT来表示，但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母，究竟何谓UTC？事实上，UTC指的是Coordinated Universal Time－世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。所以基本上UTC的本质强调的是比GMT更为精确的世界时间标准，不过对于现行表款来说，GMT与UTC的功能与精确度是没有差别的。 注： 两者的区别在于前者是一个天文上的概念，而后者是基于一个原子钟。 在UTC中，每一年或两年会有一个“闰秒”。 三、时区整个地球分为二十四时区，每个时区都有自己的本地时间 。本地时间 = UTC + 时区差，时区差东为正，西为负。因此，把东八时区（北京时间 ）记为 UTC+8。 四、表示时间的格式/标准1、RFC-2822标准格式，形如：1234// GMT+0800(CST)代表东八区// CST(china standard time)表示中国标准时间Sun Apr 08 2018 11:38:39 GMT+0800(CST) 2、ISO-8601标准格式，其中一种常见的格式形如：122018-04-08T11:38:39+08:00 // 日期用&apos;-&apos;相隔，与时间用&apos;T&apos;连接2018-04-08T11:38:39Z // Z代表UTC时间，Z也可写成00:00 ISO 8601的标准格式是：YYYY-MM-DDTHH:mm:ss.sssZ，分别表示： 1234567891011121314151617YYYY：年份，0000 ~ 9999MM：月份，01 ~ 12DD：日，01 ~ 31T：分隔日期和时间HH：小时，00 ~ 24mm：分钟，00 ~ 59ss：秒，00 ~ 59.sss：毫秒Z：时区，可以是：Z（UFC）、+HH:mm、-HH:mm// ISO格式例子// 1997// 1997-07// 1997-07-16// 1997-07-16T19：20 + 01:00// 1997-07-16T19：20：30 + 01:00// 1997-07-16T19：20：30.45 + 01:00 五、JS DateJavaScript内部，所有日期和时间都储存为一个整数，表示当前时间距离1970年1月1日00:00:00的毫秒数，正负的范围为基准时间前后各1亿天。 1234567891011// 依据系统设置的当前时间来创建一个Date对象new Date();// 时间戳new Date(value);// 表示日期的字符串值。该字符串应该能被 Date.parse() 方法识别new Date(dateString);// 当Date作为构造函数调用并传入多个参数时，所定义参数代表的是当地时间new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); 1、new Date(dateString)中的ISO格式在ES5之中，如果日期采用连词线（-）格式分隔，且具有前导0，JavaScript会认为这是一个ISO格式的日期字符串，导致返回的时间是以UTC时区计算的。 12345new Date('2014-01-01')// Wed Jan 01 2014 08:00:00 GMT+0800 (CST)new Date('2014-1-1')// Wed Jan 01 2014 00:00:00 GMT+0800 (CST) 在ES5之中，如果日期采用连词线（-）格式分隔，且没有前导0，JavaScript引擎假设用户处于本地时区。 ES6 改变了这种做法，规定凡是没有指定时区的日期字符串，一律认定用户处于本地时区。 对于其他格式的日期字符串，一律视为非ISO格式，采用本地时区作为计时标准。 12345new Date('2014-12-11')// Thu Dec 11 2014 08:00:00 GMT+0800 (CST)new Date('2014/12/11')// Thu Dec 11 2014 00:00:00 GMT+0800 (CST) 注：上面代码中，第一个日期字符串是ISO格式，第二个不是]]></content>
      <tags>
        <tag>时间戳</tag>
        <tag>时区</tag>
        <tag>时间格式</tag>
        <tag>UTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pushState和replaceState]]></title>
    <url>%2F2018%2F12%2F24%2FpushState%E5%92%8CreplaceState%2F</url>
    <content type="text"><![CDATA[window 对象通过 history 对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时——从HTML5开始——提供了对history栈中内容的操作。 123window.history.back(); // 与点击浏览器回退按钮的效果相同window.history.forward(); // 与点击浏览器前进按钮的效果相同window.history.go(-1); // 通过与当前页面相对位置，来标志某一特定页面 一、pushStatepushState() 需要三个参数: 一个状态对象， 一个标题 (目前被忽略)，和 (可选的) 一个URL。让我们来解释下这三个参数详细内容： 状态对象 状态对象state是一个JavaScript对象 popstate事件被触发时，该事件的state属性包含该历史记录状态对象的副本 状态对象可以是能被序列化的任何东西，但有640k的大小限制 标题 Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。 URL 该参数定义了新的历史URL记录 注意，调用 pushState() 后浏览器并不会立即加载这个URL 新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理 新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL 1234567// http://mozilla.org/foo.html 假设当前urllet stateObj = &#123; foo: "bar" &#125;;history.pushState(stateObj, "page 2", "bar.html");// 这将使浏览器地址栏显示为 http://mozilla.org/bar.html// 但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在。 注： pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。vue-router 底层调用的正是history.pushState和history.replaceState。 二、replaceStatehistory.replaceState() 的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个。 replaceState() 的使用场景在于为了响应用户操作，你想要更新状态对象state或者当前历史记录的URL。 三、获取当前状态 你可以读取当前历史记录项的状态对象state，而不必等待popstate 事件， 只需要这样使用history.state 属性： 1let currentState = history.state; 四、改变referrer使用 history.pushState() 可以改变referrer，它在用户发送 XMLHttpRequest请求时在HTTP头部使用，改变state后创建的 XMLHttpRequest对象的referrer都会被改变，但超越不了同源策略。]]></content>
      <tags>
        <tag>pushState</tag>
        <tag>replaceState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[visibilityState]]></title>
    <url>%2F2018%2F12%2F20%2FvisibilityState%2F</url>
    <content type="text"><![CDATA[一、document.visibilityStatePage Visibility API 在document对象上，新增了一个document.visibilityState属性。该属性返回一个字符串，表示页面当前的可见性状态，共有三个可能的值。 hidden：页面彻底不可见 visible：页面至少一部分可见 prerender：页面即将或正在渲染，处于不可见状态 其中，hidden状态和visible状态是所有浏览器都必须支持的。prerender状态只在支持”预渲染”的浏览器上才会出现，比如 Chrome 浏览器就有预渲染功能，可以在用户不可见的状态下，预先把页面渲染出来，等到用户要浏览的时候，直接展示渲染好的网页。 只要页面可见，哪怕只露出一个角，document.visibilityState属性就返回visible。只有以下四种情况，才会返回hidden。 浏览器最小化 浏览器没有最小化，但是当前页面切换成了背景页 浏览器将要卸载（unload）页面 操作系统触发锁屏屏幕 注意，document.visibilityState属性只针对顶层窗口，内嵌的&lt;iframe&gt;页面的document.visibilityState属性由顶层窗口决定。使用 CSS 属性隐藏&lt;iframe&gt;页面（比如display: none;），并不会影响内嵌页面的可见性。 二、visibilitychange 事件只要document.visibilityState属性发生变化，就会触发visibilitychange事件，通过document.addEventListener()方法或document.onvisibilitychange属性。 1234567891011document.addEventListener('visibilitychange', function () &#123; // 用户离开了当前页面 if (document.visibilityState === 'hidden') &#123; document.title = '页面不可见'; &#125; // 用户打开或回到页面 if (document.visibilityState === 'visible') &#123; document.title = '页面可见'; &#125;&#125;); 三、Page Lifecycle API(原文)Android、iOS 和最新的 Windows 系统可以随时自主地停止后台进程，及时释放系统资源。也就是说，网页可能随时被系统丢弃掉。Page Visibility API 只在网页对用户不可见时触发，至于网页会不会被系统丢弃掉，它就无能为力了。 为了解决这个问题，W3C 新制定了一个 Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。 有了这个 API，开发者就可以预测网页下一步的状态，从而进行各种针对性的处理。Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库 PageLifecycle.js。 网页的生命周期分成六个阶段，每个时刻只可能处于其中一个阶段]]></content>
      <tags>
        <tag>document</tag>
        <tag>visibilityState</tag>
        <tag>visibilitychange</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Performance]]></title>
    <url>%2F2018%2F12%2F20%2FPerformance%2F</url>
    <content type="text"><![CDATA[一、performanceperformace允许访问当前页面性能相关的信息，主要功能都是由Performance Timeline API、the Navigation Timing API、the User Timing API、 the Resource Timing API提供的。 1、performance.timing，提供了各种与浏览器处理相关的时间数据 名称 作用（这里所有时间戳都代表UNIX毫秒时间戳） connectEnd 浏览器与服务器之间的连接建立时的时间戳，连接建立指的是所有握手和认证过程全部结束 connectStart HTTP请求开始向服务器发送时的时间戳，如果是持久连接，则等同于fetchStart。 domComplete 当前网页DOM结构生成时，也就是Document.readyState属性变为“complete”,并且相应的readystatechange事件触发时的时间戳。 domContentLoadedEventEnd 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本运行完成时的时间戳。 domContentLoadedEventStart 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本开始运行时的时间戳。 domInteractive 当前网页DOM结构结束解析、开始加载内嵌资源时，也就是Document.readyState属性变为“interactive”、并且相应的readystatechange事件触发时的时间戳。 domLoading 当前网页DOM结构开始解析时,也就是Document.readyState属性变为“loading”、并且相应的readystatechange事件触发时的时间戳。 domainLookupEnd 域名查询结束时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart domainLookupStart 域名查询开始时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart fetchStart 浏览器准备通过HTTP请求去获取页面的时间戳。在检查应用缓存之前发生。 loadEventEnd 当前网页load事件的回调函数结束时的时间戳。如果该事件还没有发生，返回0。 loadEventStart 当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生，返回0。 navigationStart 当前浏览器窗口的前一个网页关闭，发生unload事件时的时间戳。如果没有前一个网页，就等于fetchStart redirectEnd 最后一次重定向完成，也就是Http响应的最后一个字节返回时的时间戳。如果没有重定向，或者上次重定向不是同源的。则为0 redirectStart 第一次重定向开始时的时间戳，如果没有重定向，或者上次重定向不是同源的。则为0 requestStart 浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。 responseEnd 浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳 responseStart 浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。 secureConnectionStart 浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。 unloadEventEnd 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload回调结束时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 unloadEventStart 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload事件发生时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 组合值的意义 DNS查询耗时 ：domainLookupEnd - domainLookupStart TCP链接耗时 ：connectEnd - connectStart request请求耗时 ：responseEnd - responseStart 解析dom树耗时 ： domComplete - domInteractive 白屏时间 ：responseStart - navigationStart domready时间 ：domContentLoadedEventEnd - navigationStart onload时间 ：loadEventEnd - navigationStart 2、performance.navagation，呈现了如何导航到当前文档的信息performance.navagation有两个属性 type，表示如何导航到当前页面的，主要有4个值 type = 0，通过点击链接、书签和表单提交，或者脚本操作，或者在url中直接输入地址访问的 type=1，点击刷新或者调用Location.reload()方法访问的 type=2，通过历史记录或者前进后退按钮访问的 type=255，其他方式访问的 redirectCount，表示到达当前页面之前经过几次重定向 3、performance.timeOrigin表示performance性能测试开始的时间，是一个高精度时间戳（千分之一毫秒） 4、performance.onresourcetimingbufferfull表示当浏览器资源时间性能缓冲区已满时会触发的回调函数。下面是mdn上关于这个属性的一个demo。这个demo的主要内容是当缓冲区内容满时，调用buffer_full函数。 1234567891011function buffer_full(event) &#123; console.log("WARNING: Resource Timing Buffer is FULL!"); performance.setResourceTimingBufferSize(200);&#125;function init() &#123; // Set a callback if the resource buffer becomes filled performance.onresourcetimingbufferfull = buffer_full;&#125;&lt;body onload="init()"&gt; 5、performance.memory一个非标准属性，由chrome浏览器提供，这个属性提供了一个可以获取到基本内存使用情况的对象。 12345memory: &#123; jsHeapSizeLimit: 2217857988, // 内存大小限制 totalJSHeapSize: 27488256, // 可使用的内存 usedJSHeapSize: 23214320 // JS对象(包括V8引擎内部对象)已占用的内存&#125; 注：usedJSHeapSize表示所有被使用的js堆栈内存；totalJSHeapSize表示当前js堆栈内存总大小，这表示usedJSHeapSize不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏。 6、performance.getEntries12345678910111213141516171819202122232425262728var resourcesObj = performance.getEntries();[ &#123; connectEnd: 1057.4999999989814, connectStart: 1057.4999999989814, decodedBodySize: 4263, domainLookupEnd: 1057.4999999989814, domainLookupStart: 1057.4999999989814, duration: 453.3000000010361, encodedBodySize: 4263, entryType: "resource", fetchStart: 1057.4999999989814, initiatorType: "img", name: "https://cdn.segmentfault.com/v-5c19e300/page/img/app/appQrcode.png", nextHopProtocol: "http/1.1", redirectEnd: 0, redirectStart: 0, requestStart: 1508.2999999976892, responseEnd: 1510.8000000000175, responseStart: 1509.200000000419, secureConnectionStart: 0, serverTiming: [], startTime: 1057.4999999989814, transferSize: 0, workerStart: 0 &#125;, ...] 返回的是一个对象数组，按startTime排序，数组每一个项都是一个对象，这个对象中包含了当前静态资源的加载Timing 。还可以用mark()，measure()方法自定义添加 。 123456789101112131415161718192021222324// 标记一个开始点performance.mark("mySetTimeout-start");// 等待1000mssetTimeout(function() &#123; // 标记一个结束点 performance.mark("mySetTimeout-end"); // 标记开始点和结束点之间的时间戳 performance.measure( "mySetTimeout", "mySetTimeout-start", "mySetTimeout-end" ); // 获取所有名称为mySetTimeout的measures var measures = performance.getEntriesByName("mySetTimeout"); var measure = measures[0]; console.log("setTimeout milliseconds:", measure.duration) // 清除标记 performance.clearMarks(); performance.clearMeasures();&#125;, 1000); 二、一套性能API标准 API 名称 功能 Navigation Timing 导航计时 能够帮助网站开发者检测真实用户数据（RUM），例如带宽、延迟或主页的整体页面加载时间。 Resource Timing 资源计时 对单个资源的计时，可以对细粒度的用户体验进行检测。 High Resolution Timing 高精度计时 该API规范所定义的JavaScript接口能够提供精确到微秒级的当前时间，并且不会受到系统时钟偏差或调整的影响。 Page Visibility 页面可见性 通过这一规范，网站开发者能够以编程方式确定页面的当前可见状态，从而使网站能够更有效地利用电源与CPU。当页面获得或失去焦点时，文档对象的visibilitychange事件便会被触发。 Performance Timeline 性能时间线 以一个统一的接口获取由Navigation Timing、Resourcing Timing和User Timing所收集的性能数据。 Battery Status 电池状态 能够检测当前设备的电池状态，例如是否正在充电、电量等级。可以根据当前电量决定是否显示某些内容，对于移动设备来说非常实用。 User Timing 用户计时 可以对某段代码、函数进行自定义计时，以了解这段代码的具体运行时间。 Beacon 灯塔 可以将分析结果或诊断代码发送给服务器，它采用了异步执行的方式，因此不会影响页面中其它代码的运行。 Animation Timing 动画计时 通过requestAnimationFrame函数让浏览器精通地控制动画的帧数，能够有效地配合显示器的刷新率，提供更平滑的动画效果，减少对CPU和电池的消耗。 Resource Hits 资源提示 通过html属性指定资源的预加载，例如在浏览相册时能够预先加载下一张图片，加快翻页的显示速度。 Frame Timing 帧计时 通过一个接口获取与帧相关的性能数据，例如每秒帧数和TTF。 Navigation Error Logging 错误日志记录 通过一个接口存储及获取与某个文档相关的错误记录。]]></content>
      <tags>
        <tag>Performance</tag>
        <tag>首屏时间</tag>
        <tag>白屏时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支开发规范]]></title>
    <url>%2F2018%2F12%2F19%2Fgit%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[分支管理1、master分支 部署生产环境的分支，这个分支只能从其他分支合并，如develop/release/hotfix，不能在这个分支直接修改 2、develop分支 我们的主开发分支，是一个稳定的版本，通常由release分支合并过来，通常发到sit/uat环境进行测试，然后合并到master分支 3、hotfix分支 主要是修复线上紧急bug的分支，此分支来自master分支，然后合并到master和develop 4、release分支 主要是多人协作开发的大功能分支，此分支来自develop，合并到develop分支 5、feature分支 主要是个人新功能开发的分支，如果多人开发，从release分支上拉，开发完成，合到release分支，如果单人开发，release和feature分支是相同的 master、develop 分支大部分情况下都会保持一致，只有在上线前的测试阶段 develop 比 master 的代码要多，一旦测试没问题，准备发布了，这时候会将 develop 合并到 master上。 但是我们发布之后又会进行下一版本的功能开发，开发中间可能又会遇到需要紧急修复 bug ，一个功能开发完成之后突然需求变动了等情况，所以除了以上master 和 develop 两个主要分支以外，还提出了以下三个辅助分支：hotfix、release、feature。 分支命名除了主要分支的名字是固定的之外，派生分支是需要自己命名的，采用如下形式： feature : 按照功能点（而不是需求）命名feature/ ；如 feature/weixin_recharge hotfix : 通过平台生成的问题编号来命名；如 hotfix/#1]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[埋点分析定义]]></title>
    <url>%2F2018%2F12%2F19%2F%E5%9F%8B%E7%82%B9%E5%88%86%E6%9E%90%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[一、基础指标PV、UV、VV、IP是网站分析中最基础、最常见的指标 访问次数（Visit View） 当访客完成所有的浏览并最终关掉该网站的所有页面时，便完成了一次访问 若访客连续30分钟没有新开和刷新页面，则被计算为本次访问结束 网页浏览数（Page View） 指网页的浏览次数，用以衡量用户访问的网页数量。多次打开或刷新同一网页则浏览量累计 独立访客数（Unique Visitor） 1天内相同的访客多次访问网站只计算1个UV，以cookie为依据 独立IP数（IP） 1天内相同的访客多次访问网站只计算1个独立IP，以IP为依据 二、访问记录模型1user =&gt; timeStamp =&gt; location =&gt; action =&gt; meta user：触发动作的用户，必要 有账号，使用userId标识 没账号，使用浏览器fingerprint + cookie timeStamp：触发动作的时间戳，必要 location：动作发生的页面，必要 123456location: &#123; siteId: '', // 标识一个站点集合，必要 module: '', // 标识当前url属于哪个模块，可选 url: '', // 用于定位具体某一页，必要&#125;// siteId字段、module字段是对url字段的特定描述 action：具体动作，必要 1234action: &#123; name: '', // meta: '' // 对动作的描述补充，如download的文件类型&#125; action.name 123访问次数(Visit View): enter, leave浏览数(Page View)：view其他：click, download, upload meta：补充额外的参数 1234meta: &#123; brower: '', // 浏览器统计 system: '', // 操作系统统计&#125; 三、埋点接口12345678910// 统一传参格式&#123; userId: '', siteId: '', module: 'module1&amp;module2&amp;module3', //多级模块通过&amp;拼接 pageViewUrl: '', timeStamp: '', action: '', meta: '' // 对动作的描述补充，如download的文件类型&#125; 注：用户表、site表、module表、action表 1、埋点采集数据 1234567891011121314&#123; url: /api/statistics / collection, method: post, Content - Type: application / json;charset = utf - 8, data: &#123; userId: '', siteId: '', module: 'module1&amp;module2&amp;module3', //多级模块通过&amp;拼接 pageViewUrl: '', timeStamp: '', action: '', meta: '' &#125;&#125;]]></content>
      <tags>
        <tag>埋点</tag>
        <tag>分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[white-space与换行]]></title>
    <url>%2F2018%2F12%2F14%2Fwhite-space%2F</url>
    <content type="text"><![CDATA[white-space CSS 属性是用来设置如何处理元素中的空白。 1white-space: normal | pre | nowrap | pre-wrap | pre-line normal：连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap：和 normal 一样，连续的空白符会被合并。但文本内的换行无效。 pre：连续的空白符会被保留。在遇到换行符或者&lt;br/&gt;元素时才会换行。 pre-wrap：连续的空白符会被保留。在遇到换行符或者&lt;br/&gt;元素，或者需要为了填充line盒子时才会换行。 pre-line：连续的空白符会被合并。在遇到换行符或者&lt;br/&gt;元素，或者需要为了填充line盒子时会换行。 换行符 空格和制表符 文本超出容器宽度 normal 合并 合并 换行 nowrap 合并 合并 不换行 pre 保留 保留 不换行 pre-wrap 保留 保留 换行 pre-line 保留 合并 换行]]></content>
      <tags>
        <tag>white-space</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-Scroll-Snap]]></title>
    <url>%2F2018%2F12%2F11%2FCSS-Scroll-Snap%2F</url>
    <content type="text"><![CDATA[CSS Scroll Snap是CSS中一个独立的模块，可以让网页容器滚动停止的时候，自动平滑定位到指定元素的指定位置，包含scroll-*以及scroll-snap-*等诸多CSS属性。 Scroll Snap模块相关CSS属性可以分为两类，一类作用在滚动容器上，一拨作用在你希望有滚动定位点的子元素上。具体参见下表： 作用在滚动容器上 作用在定位子项上 scroll-snap-type scroll-snap-align scroll-snap-stop scroll-margin/scroll-margin-* scroll-padding/scroll-padding-* 1. scroll-snap-typescroll-snap-type作用就是确定是水平滚动定位，还是垂直滚动定位。支持的属性值如下： none ：默认值，表示滚动时候忽略捕捉点。 x ：捕捉水平定位点。 y ：捕捉垂直平定位点。 block ： 捕捉和块状元素排列一个滚动方向的定位点，默认文档流下指的就是垂直轴。 inline ：捕捉和内联元素排列一个滚动方向的定位点，默认文档流下指的就是水平轴。 both ：横轴纵轴都捕捉。 mandatory ：强制定位，可选参数。无论是添加删除元素，或者滚动窗口较小，不足以放下子元素。 proximity ：表示“大约”，可选参数。 2. scroll-snap-stopscroll-snap-stop表示是否允许滚动容器忽略捕获位置。其中，支持的属性值： normal ：默认值。可以忽略捕获位置。 always：不能忽略捕获位置。且必须定位到第一个捕获元素的位置。 3. scroll-snap-alignscroll-snap-align是作用在滚动容器子元素上的，表示捕获点是上边缘，下边缘，还是中间位置。其中，支持的属性值： none：默认值。不定义位置。 start：起始位置对齐，例如，垂直滚动，子元素和容器同上边缘对齐。 end：结束位置对齐，例如，垂直滚动，子元素和容器同下边缘对齐。 center：居中对齐。子元素中心和滚动容器中心一致。 注：scroll-snap-align还支持同时使用两个属性值，例如： 1scroll-snap-align: start end; 此时，第一个属性值表示block元素排列方向（通常垂直），第二个属性值表示inline元素`的排列方向（通常水平）。]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>scroll-snap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码与存储_UCS_UTF]]></title>
    <url>%2F2018%2F12%2F07%2FUCS-2%E5%92%8CUCS-4%2F</url>
    <content type="text"><![CDATA[1、字节和字符的区别ASCII时代，字节和字符是一样的。当Unicode出现后，事情有所不同了。字节（octet）是一个八位的存储单元，取值范围一定是0～255。而字符（character，或者word）为语言意义上的符号，范围就不一定了。例如在UCS-2中定义的字符范围为0～65535，它的一个字符占用两个字节。 2、UCS-2和UCS-4Unicode是为整合全世界的所有语言文字而诞生的。任何文字在Unicode中都对应一个值，这个值称为代码点（code point）。代码点的值通常写成U+ABCD的格式。而文字和代码点之间的对应关系就是UCS-2（Universal Character Set coded in 2 octets）。顾名思义，UCS-2是用两个字节来表示代码点，其取值范围为 U+0000～U+FFFF。 为了能表示更多的文字，人们又提出了UCS-4，即用四个字节表示代码点。它的范围为 U+00000000～U+7FFFFFFF，其中 U+00000000～U+0000FFFF和UCS-2是一样的。 要注意，UCS-2和UCS-4只规定了代码点和文字之间的对应关系，并没有规定代码点在计算机中如何存储。规定存储方式的称为UTF（Unicode Transformation Format），其中应用较多的就是UTF-8。 注： Unicode不是一次性定义的，而是分区定义。每个区可以存放65536个字符，称为一个平面（plane），定义了17个平面，目前Unicode字符集的大小是1,114,112。 最前面的65536个字符位，称为基本平面（缩写BMP），是Unicode最先定义和公布的一个平面。 3、UTF-8UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~6个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8 的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 下表总结了编码规则，字母x表示可用编码的位。 123456789Unicode符号范围 | UTF-8编码方式 (十六进制) | （二进制）--------------------+-------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-001F FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx0020 0000-03FF FFFF | 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx0400 0000-7FFF FFFF | 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 注： 如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是最多四个字节，非标准UTF-8仍支持使用1~6个字节表示一个符号。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 常用中文编码范围（并非全部） 12345/[\u4e00-\u9fa5]/ 中文：20902个/[\u0800-\u4e00]/ 日文：17921个/[\uac00-\ud7ff]/ 韩文：11264个 注：以上正则表达式是部分中文匹配，并非精确，但能满足大多数情况。 4、中文Unicode 编码范围 字符集 字数 Unicode 编码 基本汉字 20902字 4E00-9FA5 基本汉字补充 38字 9FA6-9FCB 扩展A 6582字 3400-4DB5 扩展B 42711字 20000-2A6D6 扩展C 4149字 2A700-2B734 扩展D 222字 2B740-2B81D 康熙部首 214字 2F00-2FD5 部首扩展 115字 2E80-2EF3 兼容汉字 477字 F900-FAD9 兼容扩展 542字 2F800-2FA1D PUA(GBK)部件 81字 E815-E86F 部件扩展 452字 E400-E5E8 PUA增补 207字 E600-E6CF 汉字笔画 36字 31C0-31E3 汉字结构 12字 2FF0-2FFB 汉语注音 22字 3105-3120 注音扩展 22字 31A0-31BA 〇 1字 3007 5、UTF-16UTF-16的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节。也就是说，UTF-16的编码长度要么是2个字节（U+0000到U+FFFF），要么是4个字节（U+010000到U+10FFFF）。UTF-16编码是UCS-2的超集，介于UTF-32与UTF-8之间，同时结合了定长和变长两种编码方法的特点。 Unicode 编号范围 （十六进制） 0000 0000 ~ 0000 FFFF 0001 0000 ~ 0010 FFFF Unicode 编号 （二进制） xxxx-xxxx ~ xxxx-xxxx xxxx xxxx xxxx xxxx xxxx UTF-16 编码 xxxx-xxxx ~ xxxx-xxxx 110110xx xxxx xxxx 110111xx xxxx xxxx 字节数 2 4 四字节存储：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位用一个值介于DC00~DFFF 之间的双字节存储。 注：标准的UTF-8和UTF-16都是最多支持U+0000到U+10FFFF的Unicode码点 6、Unicode与JavaScriptJavaScript语言采用Unicode字符集，但是只支持一种编码方法。这种编码既不是UTF-16，也不是UTF-8，更不是UTF-32。JavaScript用的是UCS-2。 注：在 level 3 或者更高等级的实现中，遵循国际标准，JavaScript 引擎是允许使用 UCS-2或者 UTF-16 进行编码的。 JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011121314"\u20BB7"// "₻7" JavaScript会理解成\u20BB+7"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。 使用for...of循环，它会正确识别 32 位的 UTF-16 字符 123456let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 Array.from()可以将字符串转为数组，然后返回字符串的长度。它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。 1Array.from(string).length codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false]]></content>
      <tags>
        <tag>UCS-2</tag>
        <tag>UCS-4</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log格式化输出]]></title>
    <url>%2F2018%2F12%2F07%2Fconsole%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[字符串替代和格式设置传递到任何记录方法的第一个参数可能包含一个或多个格式说明符。格式说明符由一个 % 符号与后面紧跟的一个字母组成，字母指示应用到值的格式。字符串后面的参数会按顺序应用到占位符。 12345 // Sam has 100 pointsconsole.log("%s has %d points", "Sam", 100);// Node count: 2, and the time is 1544184144238.console.log("Node count: %d, and the time is %f.", document.childNodes.length, Date.now()); 格式说明符的完整列表为： 说明符 输出 %s 将值格式化为字符串 %i 或 %d 将值格式化为整型 %f 将值格式化为浮点值 %o 将值格式化为可扩展 DOM 元素。如同在 Elements 面板中显示的一样 %O 将值格式化为可扩展 JavaScript 对象 %c 将 CSS 样式规则应用到第二个参数指定的输出字符串]]></content>
      <tags>
        <tag>console.log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getComputedStyle和currentStyle]]></title>
    <url>%2F2018%2F12%2F07%2FgetComputedStyle%E5%92%8CcurrentStyle%2F</url>
    <content type="text"><![CDATA[getComputedStyleWindow.getComputedStyle()方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。 12let style = window.getComputedStyle(element, [pseudoElt]);// let afterStyle = window.getComputedStyle(h3, '::after'); pseudoElt 可选，指定一个要匹配的伪元素的字符串。 defaultView在许多在线的演示代码中，getComputedStyle是通过 document.defaultView 对象来调用的。大部分情况下，这是不需要的，因为可以直接通过window对象调用。但有一种情况，你必需要使用 defaultView, 那是在firefox3.6上访问子框架内的样式 。 currentStyleElement.currentStyle 是一个与 window.getComputedStyle方法功能相同的属性。这个属性实现在旧版本的IE浏览器中。]]></content>
      <tags>
        <tag>getComputedStyle</tag>
        <tag>currentStyle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[supporst属性]]></title>
    <url>%2F2018%2F12%2F07%2Fcss3-supporst%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[@supports是CSS3新引入的规则之一，主要用于检测当前浏览器是否支持某个CSS属性并加载具体样式。 1、基本使用12345@supports (display: grid) &#123; .container &#123; color: red; &#125;&#125; 类似@media媒体查询，当浏览器支持display:grid这个CSS属性时才应用其中的样式。 2、逻辑运算12345678/**not*/@supports not(display: grid)&#123;...&#125; /**and*/@supports (display: grid) and (position: sticky)&#123;...&#125;/**or*/@supports (display: grid) or (display: flex)&#123;...&#125; 注：括号内不一定都要是“关键字”，只要是CSS语法都可以 1@supports (border-radius: 4px) or (--btn-color: red)&#123;...&#125; 3、js方法查询123if(CSS.supports('display', 'grid'))&#123; alert('it support!');&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>supporst</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BASIC_HTTP认证_nginx]]></title>
    <url>%2F2018%2F12%2F05%2FBASIC-HTTP%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[一、BASIC认证概述HTTP协议定义了基本认证过程，允许HTTP服务器对WEB浏览器进行用户身份证的方法。 当一个客户端向HTTP服务器进行数据请求时，如果客户端未被认证，则HTTP服务器将通过基本认证过程对客户端的用户名及密码进行验证，以决定用户是否合法。 客户端在接收到HTTP服务器的身份认证要求后，会提示用户输入用户名及密码，然后将用户名及密码以BASE64加密，加密后的密文将附加于请求信息中， 如当用户名为anjuta，密码为：123456时，客户端将用户名和密码用“：”合并，并将合并后的字符串用BASE64加密为密文，并于每次请求数据 时，将密文附加于请求头（Request Header）中。 HTTP服务器在每次收到请求包后，根据协议取得客户端附加的用户信息（BASE64加密的用户名和密码），解开请求包，对用户名及密码进行验证，如果用 户名及密码正确，则根据客户端请求，返回客户端所需要的数据;否则，返回错误代码或重新要求客户端提供用户名及密码。 二、BASIC认证的过程1、客户端向服务器请求数据，请求的内容可能是一个网页或者是一个其它的MIME类型，此时，假设客户端尚未被验证(即header中不带正确的Authorization字段)，则客户端提供如下请求至服务器: 12Get /index.html HTTP/1.0Host:www.google.com 2、 服务器向客户端发送验证请求代码401,服务器返回的数据大抵如下： 12345HTTP/1.0 401 UnauthorisedServer: SokEvo/1.0WWW-Authenticate: Basic realm="google.com"Content-Type: text/htmlContent-Length: xxx 3、当符合http规范的客户端收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。 4、用户输入用户名和密码后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容(即在header中自动加入Authorization字段)： 123Get /index.html HTTP/1.0Host:www.google.comAuthorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxxxx 5、服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。 三、nginx用户认证配置nginx_http_auth_basic_module模块实现让访问着，只有输入正确的用户密码才允许访问web内容。默认情况下nginx已经安装了ngx_http_auth_basic_module模块，如果不需要这个模块，可以加上--without-http_auth_basic_module。 1、nginx basic auth指令123语法: auth_basic string | off;默认值: auth_basic off;配置段: http, server, location, limit_except 默认表示不开启认证，后面如果跟上字符，这些字符会在弹窗中显示。 123语法: auth_basic_user_file file;默认值: —配置段: http, server, location, limit_except 生成密码可以使用htpasswd，或者使用openssl。用户密码文件，文件内容类似如下： 123# printf &quot;ttlsa:$(openssl passwd -crypt 123456)\n&quot; &gt;&gt;conf/htpasswd# cat conf/htpasswdttlsauser1:password1 12345678910server &#123; server_name www.ttlsa.comttlsa.com; index index.html index.php; root /data/site/www.ttlsa.com; location / &#123; auth_basic "nginx basic http test for ttlsa.com"; auth_basic_user_file conf/htpasswd; &#125;&#125;]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>BASIC</tag>
        <tag>authentication</tag>
        <tag>nginx_http_auth_basic_module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm依赖包版本号]]></title>
    <url>%2F2018%2F12%2F05%2Fnpm%E4%BE%9D%E8%B5%96%E5%8C%85%E7%89%88%E6%9C%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[一、版本号给定一个版本号：主版本号(major).次版本号(minor).补丁版本号(patch)， 以下这三种情况需要增加相应的版本号： 主版本号： 当API发生改变，并与之前的版本不兼容的时候 次版本号： 当增加了功能，但是向后兼容的时 补丁版本号： 当做了向后兼容的缺陷修复的时候 1、~version 如果minor版本号指定了，那么minor版本号不变，而patch版本号任意 如果minor和patch版本号未指定，那么minor和patch版本号任意 12345~1.1.2，表示 &gt;= 1.1.2 &lt; 1.2.0~1.1，表示 &gt;= 1.1.0 &lt; 1.2.0~1，表示 &gt;= 1.0.0 &lt; 2.0.0 2、^version 版本号中最左边的非0数字的右侧可以任意 如果缺少某个版本号，则这个版本号的位置可以任意 12345^1.1.2 ，表示 &gt;= 1.1.2 &lt; 2.0.0^0.2.3 ，表示&gt;= 0.2.3 &lt; 0.3.0^0.0，表示 &gt;= 0.0.0 &lt; 0.1.0 注：^版本更新可能比较大，会造成项目代码错误]]></content>
      <tags>
        <tag>npm</tag>
        <tag>版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp三次握手]]></title>
    <url>%2F2018%2F11%2F30%2Ftcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[一、TCP报文格式 TCP报文格式图： 上图中有几个字段需要重点介绍下： 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 注： 不要将确认序号Ack与标志位中的ACK搞混了。 确认方Ack=发起方Req+1，两端配对。 二、三次握手 （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 为什么TCP客户端最后还要发送一次确认呢？12345一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>三次握手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓动公式]]></title>
    <url>%2F2018%2F11%2F28%2F%E7%BC%93%E5%8A%A8%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、过渡函数 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果 ease-in 规定以慢速开始的过渡效果 ease-out 规定以慢速结束的过渡效果 ease-in-out 规定以慢速开始和结束的过渡效果 二、参数解析首先说说四个参数的含义： t：timestamp，动画执行到当前帧所进过的时间 b：begining，起始值 c：change，需要变化的量 d：duration，动画的总时间 三、数学原理首先要清楚一点，动画中每一帧所经过的时间是相同的，只是由于上一帧与下一帧的位移量不同，因此速度在视觉上感受不同，位移量小，感觉上速度就慢了。 下面简要分析一下原理，一步一步来： 动画执行时间的变化可表达为0 -&gt; d，提取出常数d，就变成d*(0 -&gt; 1)，变化部分为(0-&gt;1)，记为x轴变化 动画总的变化量和开始值是已知的，其变化可以表达为b -&gt; b+c,提取一下变为b+c*(0 -&gt; 1)，变化部分也是(0-&gt;1)，记为y轴变化 t用来指示事件当前的时间点，将其变为指示动画完成的百分比，即t/d； 通过上面的变换，我们需要做的事情就是构造x轴区间为[0,1],y轴区间也为[0,1]的线性或者非线性关系了。线性关系多数是y=x，也就是常用的linear了，非线性复杂一点。 然后我们看看可以构造出哪些非线性关系，并给出函数关系表达式： 利用指数函数(x的n次方)可以构造一大堆easein的效果，再根据他们的轴对称或者中心对称做翻转和位移，又可以构造出其对应的easeout效果： 利用平方根(Math.sqrt)或者立方根来实现这种非线性关系： sin或者cos函数可以通过调节参数构造两种运动趋势(下面主要给函数表达式): easein: y = 1-cos(0.5πx) easeout: y = sin(0.5πx) 通过幂函数或者对数函数： easein: y = 2^(10x-10) (当x=0时，y=0) easeout: y = 1-2^(-10x) (当x=1时，y=1) 效果还可以叠加呀，叠加的结果除以2，就能创造弹簧效果了。 下面来看看缓动公式运用了哪些吧 Sine表示由三角函数实现 Quad是二次方，Cubic是三次方，Quart是四次方，Quint是五次方 Circ是开平方根(Math.sqit)，Expo是幂函数(Math.pow) Elastic是结合三角函数和开立方根 Back则引入了常数1.70158 四、代码实现原理也就差不多分析完了，那么来看看具体实现吧，下面一2次方Quad为例子来实现，其它的都差不多。 首先是实现easein，函数表达是为： y = x*x，因此实现为： 12345function easeInQuad(t,b,c,d)&#123; var x = t/d; //x值 var y = x*x; //y值 return b+c*y; //套入最初的公式&#125; 然后来看看easeout，函数表达式为： y = -x*x+2*x，因此实现为： 12345function easeOutQuad(t,b,c,d)&#123; var x = t/d; //x值 var y = -x*x + 2*x; //y值 return b+c*y; //套入最初的公式&#125; 下面再看看easeinout的实现，它的实现就是一半的时间用easein走完一半的路程，另一半时间用easeout走完另一半路程，那么我们计算就套用上面两个公式就会非常直观了。 123456789function easeInOutQuad(t,b,c,d)&#123; if(t&lt;d/2)&#123; //前半段时间 return easeInQuad(t,b,c/2,d/2);//改变量和时间都除以2 &#125;else&#123; var t1 = t-d/2; //注意时间要减去前半段时间 var b1 = b + c/2;//初始量要加上前半段已经完成的 return easeOutQuad(t1,b1,c/2,d/2);//改变量和时间都除以2 &#125;&#125; jquery.easing.js里面一样是经过代码优化的，不会那么好理解。这里这样写只是为了便于理解，其它的原理都差不多。 123456789101112131415161718// 滚动到顶部的缓冲效果function backToTop() &#123; const start = window.pageYOffset; let backPosition = 0; let duration = 500; let fps = 16.7; let i = 0; let interval = setInterval(() =&gt; &#123; const next = Math.floor(easeInOutQuad(fps * i, start, -start, duration)); if (next &lt;= backPosition || fps * i &gt; duration) &#123; window.scrollTo(0, backPosition); clearInterval(interval); &#125; else &#123; window.scrollTo(0, next); &#125; i++; &#125;, fps);&#125;]]></content>
      <tags>
        <tag>缓动公式</tag>
        <tag>ease</tag>
        <tag>easein</tag>
        <tag>easeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种常见的contentType类型]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84contentType%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1、application/x-www-form-urlencoded浏览器的原生&lt;form&gt; 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。 对应postman中的x-www-form-urlencoded。 1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 123decodeURI('title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3')// "title=test&amp;sub[]=1&amp;sub[]=2&amp;sub[]=3"// sub：[1,2,3] 注：提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key和val都进行了URL转码 2、multipart/form-data常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的enctype 等于这个值。对应postman中的form-data。 12345&lt;form action="/" method="post" enctype="multipart/form-data"&gt; &lt;input type="text" name="description" value="some text"&gt; &lt;input type="file" name="myFile"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt; 1234567891011121314POST /foo HTTP/1.1Content-Length: 68137Content-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575---------------------------974767299852498929531610575Content-Disposition: form-data; name="description"some text---------------------------974767299852498929531610575Content-Disposition: form-data; name="myFile"; filename="foo.txt"Content-Type: text/plain(content of the uploaded file foo.txt)---------------------------974767299852498929531610575-- 3、application/json消息主体是序列化后的 JSON 字符串,这个类型越来越多地被大家所使用 。对应postman中的json。 1234POST [http://www.example.com](http://www.example.com) HTTP/1.1 Content-Type: application/json;charset=utf-8 &#123;"title":"test","sub":[1,2,3]&#125; 方便的提交复杂的结构化数据，特别适合 RESTful 的接口 4、text/xml是一种使用HTTP 作为传输协议，XML 作为编码方式的远程调用规范 。对应postman中的xml。 12345678910POST [http://www.example.com](http://www.example.com) HTTP/1.1 Content-Type: text/xml &lt;!--?xml version="1.0"?--&gt; &lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt; &lt;/methodcall&gt;]]></content>
      <tags>
        <tag>contentType</tag>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨站请求伪造CSRF]]></title>
    <url>%2F2018%2F11%2F26%2F%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0CSRF%2F</url>
    <content type="text"><![CDATA[一、CSRF攻击原理 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie 2.在不登出A的情况下，访问危险网站B 注： 如果不满足以上两个条件中的一个，就不会受到CSRF的攻击 网站B向网站A发送请求时，如果网站A在打开状态下，那么该请求会携带网站A页面下的cookie（待验证） CSRF攻击是以突破同源策略限制为前提的 二、示例银行网站A：它以GET请求来完成银行转账的操作，如： 12http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000// 使用get来更改资源，真是作死！！！ 危险网站B：它里面有一段HTML的代码如下： 1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…… 三、CSRF防御1、Cookie Hashing所有表单中，生成一个隐藏域 ，它的值就是Cookie中的token 。 注：CSRF能模拟请求，不能跨域读取cookie。如果cookie已经被xss攻击，还是很危险。 2、检查Referer字段HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。 注：http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 3、使用JSON格式使用JavaScript发起AJAX请求是限制跨域的，并不能通过简单的 &lt;form&gt; 表单来发送JSON，所以，通过只接收JSON可以很大可能避免CSRF攻击。 注：CORS规范中对跨域访问资源规定了明确的限制]]></content>
      <tags>
        <tag>CSRF</tag>
        <tag>攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie 和 Referer]]></title>
    <url>%2F2018%2F11%2F26%2Fcookie%2F</url>
    <content type="text"><![CDATA[一、Cookie1、Secure 和HttpOnly 标记 Secure 标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure标记也无法提供确实的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点（http:）无法使用Cookie的 Secure 标记。 HttpOnly 为避免跨域脚本 XSS ，API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。 2、SameSite CookiesSameSite Cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击CSRF。但目前SameSite Cookie还处于实验阶段，并不是所有浏览器都支持。 3、跟localStorage、sessionStorage 相比 特性 Cookie localStorage sessionStorage 生命期 可设置失效时间，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭标签或浏览器后被清除 大小 4K左右 一般为5MB 一般为5MB 通信 每次都会携带在HTTP头中 仅在客户端中保存，不参与和服务器的通信 仅在客户端中保存，不参与和服务器的通信 作用域 通过domain文档源和path文档路径来确定的 文档源级别，通过协议、主机名以及端口三者来确定 通过文档源和标签来确定。相同文档源，但不同标签的页面，sessionStorage数据是无法共享的 二、RefererReferer 表示请求页面是通过此来源页面里的链接进入的，在以下两种情况下，Referer 不会被发送： 来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS） 注： 在浏览器中，Referer 属性只读不写。但可以通过代理服务进行修改 如果需要通过 document.referrer 采集页面访问来源，最好不要使用 JS 跳转或打开新窗口，也不要使用 meta 跳转]]></content>
      <tags>
        <tag>Cookie</tag>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp入门]]></title>
    <url>%2F2018%2F11%2F23%2Fgulp%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、安装gulp和插件1、安装gulp12npm install gulp -gnpm install gulp --save-dev 2、常用插件 sass的编译（gulp-ruby-sass） 自动添加css前缀（gulp-autoprefixer） 压缩css（gulp-minify-css） js代码校验（gulp-jshint） 合并js文件（gulp-concat） 压缩js代码（gulp-uglify） 压缩图片（gulp-imagemin） 自动刷新页面（gulp-livereload） 图片缓存，只有图片替换了才压缩（gulp-cache） 更改提醒（gulp-notify） 清除文件（del） 1npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev 二、新建gulpfile.js现在，组件安装完毕，我们需要新建gulpfile文件以指定gulp需要为我们完成什么任务。 在项目根目录新建一个js文件并命名为gulpfile.j。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入 gulpvar gulp = require('gulp'); // 引入组件var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename');// 检查脚本gulp.task('lint', function() &#123; gulp.src('./js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;);// 编译Sassgulp.task('sass', function() &#123; gulp.src('./scss/*.scss') .pipe(sass()) .pipe(gulp.dest('./css'));&#125;);// 合并，压缩文件gulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('./dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;);// 默认任务gulp.task('default', function()&#123; gulp.run('lint', 'sass', 'scripts'); // 监听文件变化 gulp.watch('./js/*.js', function()&#123; gulp.run('lint', 'sass', 'scripts'); &#125;);&#125;); 注： gulp五个常用方法task，run，watch，src，dest` 1、引入组件1234567var gulp = require('gulp'); var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename'); 我们引入了核心的gulp和其他依赖组件，接下来，分开创建lint, sass, scripts 和 default这四个不同的任务。 2、Lint任务12345gulp.task('lint', function() &#123; gulp.src('./js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;); Link任务会检查js/目录下得js文件有没有报错或警告。 3、Sass任务12345gulp.task('sass', function() &#123; gulp.src('./scss/*.scss') .pipe(sass()) .pipe(gulp.dest('./css'));&#125;); Sass任务会编译scss/目录下的scss文件，并把编译完成的css文件保存到/css目录中。 4、Scripts 任务12345678gulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('./dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;); scripts任务会合并js/目录下得所有得js文件并输出到dist/目录，然后gulp会重命名、压缩合并的文件，也输出到dist/目录。 5、default任务123456gulp.task('default', function()&#123; gulp.run('lint', 'sass', 'scripts'); gulp.watch('./js/*.js', function()&#123; gulp.run('lint', 'sass', 'scripts'); &#125;);&#125;); 这时，我们创建了一个基于其他任务的default任务。使用.run()方法关联和运行我们上面定义的任务，使用.watch()方法去监听指定目录的文件变化，当有文件变化时，会运行回调定义的其他任务。 现在，回到命令行，可以直接运行gulp任务了。 1gulp default]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签整理]]></title>
    <url>%2F2018%2F11%2F22%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、语义化1、语义化属性 添加itemprop、itemscope属性，到达数据结构化，属性名可参考 schema.org； meta标签和itemprop属性，&lt;meta itemprop=&quot;dateModified&quot; content=&quot;2018-11-17T04:14:51.000Z&quot;&gt;； 注：参考知乎页面，改动一下meta的读取位置 1234&lt;!--可以尝试，将meta标签放在需要元信息的块中--&gt;&lt;article&gt; &lt;meta itemprop="dateModified" content="2018-11-17T04:14:51.000Z"&gt;&lt;/article&gt; 2、语义化标签 各个标签的含义，使用场景 注：语义化，即面向对象写html，方便网络蜘蛛或人快速理解网页结构和内容。 二、语义化标签1、&lt;main&gt;&lt;main&gt; 标签规定了document的主要内容，主要内容包括与中心主题直接相关或扩展的内容，或应用程序的中心功能。&lt;main&gt;元素中的内容对于文档来说应当是唯一的。 注：在一个文档中，不得包含多个未指定hidden 属性的&lt;main&gt;元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。 2、&lt;header&gt;&lt;header&gt; 标签定义文档或者文档的一部分区域的页眉。&lt;header&gt; 元素应该作为介绍内容或者导航链接栏的容器。在一个文档中，您可以定义多个 &lt;header&gt;元素。 注：&lt;header&gt;标签不能被放在 &lt;footer&gt;、&lt;address&gt; 或者另一个 &lt;header&gt;元素内部 3、&lt;footer&gt;&lt;footer&gt; 标签定义文档或者文档的一部分区域的页脚。在典型情况下，该元素会包含文档创作者的姓名、文档的版权信息、使用条款的链接、联系信息等等。在一个文档中，您可以定义多 &lt;footer&gt;元素。 注：&lt;footer&gt;元素必须不能是 &lt;header&gt;、&lt;address&gt; 或者另一个&lt;footer&gt; 元素的后代元素 4、&lt;nav&gt;&lt;nav&gt; 标签定义导航链接的部分。并不是所有的 HTML 文档都要使用到&lt;nav&gt;元素。&lt;nav&gt;元素只是作为标注一个导航链接的区域。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 5、&lt;section&gt;&lt;section&gt;元素表示文档中的一个区域（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading）。一般通过是否包含一个标题 (&lt;h1&gt;-&lt;h6&gt;element) 作为子节点 来 辨识每一个&lt;section&gt;。 如果元素内容可以分为几个部分的话，应该使用 article 而不是 section。 不要把 section元素作为一个普通的容器来使用，这是div的用法（特别是当片段（the sectioning ）仅仅是为了美化样式的时候）。 1234&lt;section&gt; &lt;h2&gt;Heading&lt;/h2&gt; &lt;img src="bird.jpg" alt="bird"&gt;&lt;/section&gt; 6、&lt;article&gt;&lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 &lt;article&gt;元素的作者信息可通过&lt;address&gt;元素提供，但是不适用于嵌套的&lt;article&gt;元素。 &lt;article&gt;元素的发布日期和时间可通过&lt;time&gt;元素的pubdate属性表示。 12345678910111213141516171819202122232425262728293031&lt;article class="film_review"&gt; &lt;header&gt; &lt;h2&gt;Jurassic Park&lt;/h2&gt; &lt;/header&gt; &lt;section class="main_review"&gt; &lt;p&gt;Dinos were great!&lt;/p&gt; &lt;/section&gt; &lt;section class="user_reviews"&gt; &lt;article class="user_review"&gt; &lt;p&gt;Way too scary for me.&lt;/p&gt; &lt;footer&gt; &lt;p&gt; Posted on &lt;time datetime="2015-05-16 19:00"&gt;May 16&lt;/time&gt; by Lisa. &lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; &lt;article class="user_review"&gt; &lt;p&gt;I agree, dinos are my favorite.&lt;/p&gt; &lt;footer&gt; &lt;p&gt; Posted on &lt;time datetime="2015-05-17 19:00"&gt;May 17&lt;/time&gt; by Tom. &lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; &lt;/section&gt; &lt;footer&gt; &lt;p&gt; Posted on &lt;time datetime="2015-05-15 19:00"&gt;May 15&lt;/time&gt; by Staff. &lt;/p&gt; &lt;/footer&gt;&lt;/article&gt; 注：section与article的区别 section：用来表示文档或应用的一部分。它主要来对一个整体部分划分为多个小部分，所以一般会使用&lt;h1&gt;-&lt;h6&gt;标签与&lt;p&gt;标签，每个小部分用标题来进行标示。 acticle：定义文章、页面或者是应用程序中独立完整可被外部引用的内容。一般有自己的&lt;header&gt;与&lt;footer&gt;，通常内部会用&lt;aside&gt;来进行辅助性说明等。 7、&lt;aside&gt;&lt;aside&gt; 标签定义 &lt;article&gt;标签外的内容，&lt;aside&gt; 的内容应该与附近的内容相关。 通常表现为侧边栏或者嵌入内容。他们通常包含在工具条，例如来自词汇表的定义。也可能有其他类型的信息，例如相关的广告、笔者的传记、web 应用程序、个人资料信息，或在博客上的相关链接。 注： &lt;aside&gt; 元素不能成为&lt;address&gt;元素的子元素 8、&lt;address&gt;&lt;address&gt; 标签定义文档作者/所有者的联系信息。 如果 &lt;address&gt;元素位于 &lt;body&gt; 元素内部，则它表示该文档作者/所有者的联系信息。 如果&lt;address&gt; 元素位于 &lt;article&gt;元素内部，则它表示该文章作者/所有者的联系信息。 注：&lt;address&gt; 元素通常被包含在&lt;footer&gt;元素的其他信息中]]></content>
      <tags>
        <tag>标签</tag>
        <tag>语义化</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[itemprop]]></title>
    <url>%2F2018%2F11%2F19%2Fitemprop%2F</url>
    <content type="text"><![CDATA[一、itemprop属性全局属性 itemprop被用于向一个物体中添加属性。每一个HTML元素都可以指定一个itemprop属性，一个itemprop属性由name-value对组成。属性值可以是一个string或者一个URL，并且可以和大部分元素进行组合，包括img、video、link、source 、audio等。 二、结构化数据12345678&lt;div itemscope itemtype ="http://schema.org/Movie"&gt; &lt;h1 itemprop="name"&gt;Avatar&lt;/h1&gt; &lt;span&gt;Director: &lt;span itemprop="director"&gt;James Cameron&lt;/span&gt; (born August 16, 1954)&lt;/span&gt; &lt;span itemprop="genre"&gt;Science fiction&lt;/span&gt; &lt;a href="../movies/avatar-theatrical-trailer.html" itemprop="trailer"&gt;Trailer&lt;/a&gt;&lt;/div&gt; Item itemprop name itemprop value itemprop name Avatar itemprop director James Cameron itemprop genre Science fiction itemprop trailer ../movies/avatar-theatrical-trailer.html 三、itemscopeitemscope 是一个布尔值的 全局属性。它定义了一个与元数据关联的数据项。就是说一个元素的 itemscope 属性会创建一个项，包含了一组与元素相关的键值对。 相关的属性 itemtype通常表示表中一个有效的 URL （比如 schema.org） 来表述项目和上下文。下面每个例子中的概念表都来自 schema.org. 每个 HTML 元素都可以有指定的 itemscope 属性。一个具有 itemscope 属性的元素可以没有关联的 itemtype ，但必须有相关的 itemref。 Schema.org 提供了一份共享的词汇表，站长可以使用它来标记网页，而这些标记则被主要的搜索引擎： Google， Microsoft， Yandex 和 Yahoo! 所支持。]]></content>
      <tags>
        <tag>itemprop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tabindex]]></title>
    <url>%2F2018%2F11%2F19%2Ftabindex%2F</url>
    <content type="text"><![CDATA[一、tabindex 属性tabindex 是一个全局属性，值为整数类型，表示元素（如果可聚焦）是否能够接受输入焦点。 如果它应该参与键盘序列导航，那么就是它的位置。它可以设为多种值： tabindex=负值 (通常是tabindex=“-1”)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用JS做页面小组件内部键盘导航的时候非常有用。 tabindex=&quot;0&quot; ，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的DOM结构来决定的。 tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序按照tabindex 的数值递增而滞后获焦。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前DOM中的先后顺序决定。 如果我们在div上设置了 tabindex 属性，它的子元素内容不能使用箭头键来滚动，除非我们在内容上也设置 tabindex。 注：tabindex 的最大值不应超过 32767。如果没有指定，它的默认值为 -1。 二、访问顺序根据键盘序列导航的顺序，值为 0 、非法值、或者没有 tabindex 值的元素应该放置在 tabindex 值为正值的元素后面。]]></content>
      <tags>
        <tag>TAB</tag>
        <tag>tabindex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx基本使用]]></title>
    <url>%2F2018%2F11%2F19%2Fnginx%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、常用命令12345nginx -?,-h #查看帮助nginx -v #查看版本nginx #启动服务service nginx restart #重启服务nginx -s reload|stop|quit #重载配置、停止服务 注： reload：重新加载配置文件，Nginx服务不会中断。检查语法，如果出错会rollback stop：快速停止 ，不管有没有正在处理的请求 quit：正常停止，退出前完成已经接受的连接请求 。只有启动Nginx的用户才能执行该命令 二、nginx配置1、配置文件/etc/nginx/nginx.conf2、文件结构123456789101112131415161718192021222324252627... #全局块events &#123; #events块 ...&#125;http #http块&#123; ... #http全局块 server #server块 &#123; ... #server全局块 location [PATTERN] #location块 &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; ... #http全局块&#125; 3、文件详情123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#这是一个注释user nginx nginxs; #配置用户和组worker_processes 1; #允许生成的进程数，默认为1#设置错误日志路径，级别。这个设置可以放入全局块，http块，server块#级别以此为：debug|info|notice|warn|error|crit|alert|emergerror_log logs/error.log;error_log logs/error.log notice;error_log logs/error.log info;pid logs/nginx.pid; #指定nginx进程运行文件存放地址events &#123; accept_mutex on; #设置网路连接序列化，防止惊群现象发生，默认为on multi_accept on; #设置一个进程是否同时接受多个网络连接，默认为off use epoll; #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport worker_connections 1024; #最大连接数，默认为512&#125;http &#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型，默认为text/plain #自定义main日志格式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; #设置访问日志 sendfile on; #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块 sendfile_max_chunk 100k; #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限 #tcp_nopush on; keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块 gzip on; #使用gzip压缩响应 #是否拦截4xx和5xx错误信息到客户端，默认值off #可以在http，server，location块，与error_page配合使用 fastcgi_intercept_errors on; #负载均衡 upstream mysvr &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备 &#125; server &#123; listen 80; #监听端口 server_name localhost; #监听地址 charset utf-8; #指定字符集添加到“Content-Type”响应头字段 access_log logs/host.access.log main; location / &#123; root /usr/share/nginx/html; #根目录 index index.html index.htm; #设置默认页 keepalive_requests 120; #单连接请求上限次数 &#125; location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写 proxy_pass http://mysvr; #请求转向mysvr 定义的服务器列表 #仅允许IPv4网络访问 10.1.1.0/16并且192.168.1.0/24 不包括地址192.168.1.1 #以及IPv6网络2001:0db8::/32 #如果有很多规则， 最好使用 ngx_http_geo_module模块变量 deny 192.168.1.1; #拒绝的ip allow 192.168.1.0/24; #允许的ip allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 location ~ \.php$ &#123; proxy_pass http://127.0.0.1; &#125; # redirect server error pages to the static page /50x.html # 前提：设置fastcgi_intercept_errors on error_page 404 https://www.baidu.com; #错误页 error_page 500 /500.html; location = /500.html &#123; root /usr/share/nginx/html; &#125; # @定义一个命名的 location，使用在内部定向时 error_page 502 503 504 @errpage; location @errpage &#123; access_log logs/host.access.log main; proxy_pass http://127.0.0.1; &#125; &#125; #other server server &#123; listen 8000; server_name www.somename.com; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; &#125; #HTTPS server server &#123; listen 443 ssl; server_name localhost; #配置ssl证书路径 ssl_certificate /etc/nginx/cer/www.somename.com.pem; ssl_certificate_key /etc/nginx/cer/www.somename.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; &#125;&#125; 变量说明： remote_addr 与http_x_forwarded_for 用以记录客户端的ip地址 remote_user ：用来记录客户端用户名称 time_local ： 用来记录访问时间与时区 request ： 用来记录请求的url与http协议 status ： 用来记录请求状态，成功是200 body_bytes_s ent ：记录发送给客户端文件主体内容大小 http_referer ：用来记录从那个页面链接访问过来的 http_user_agent ：记录客户端浏览器的相关信息 4、简化nginx.conf文件通过include 命令，按server引入 123456789101112131415161718192021222324252627282930313233343536# nginx.confuser nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.# 加载动态模块include /usr/share/nginx/modules/\*.conf; #/usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; # 从/etc/nginx/conf.d目录加载模块化配置 # See http://nginx.org/en/docs/ngx_core_module.html#include include /etc/nginx/conf.d/\*.conf; #/etc/nginx/conf.d/*.conf server &#123; listen 80 default_server; listen [::]:80 default_server; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/\*.conf; #/etc/nginx/default.d/*.conf error_page 404 /404.html; location = /40x.html &#123; &#125; &#125;&#125; 1234567891011# /etc/nginx/conf.d/example.conf#负载均衡upstream mysvr &#123; ...&#125;#HTTPS serverserver &#123; ...&#125;]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS/AMD/CMD区别]]></title>
    <url>%2F2018%2F11%2F14%2FCommonJS-AMD-CMD%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、概括CommonJs用在服务器端，AMD和CMD用在浏览器环境。AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 二、CommonJsCommonJS是服务器端模块的规范，由Node推广使用。由于服务端编程的复杂性，如果没有模块很难与操作系统及其他应用程序互动。使用方法如下： module.exports和require 1234567891011121314151617181920// math.jsmodule.exports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;;// increment.jsvar add = require('math').add;module.exports.increment = function(val) &#123; return add(val, 1);&#125;;// index.jsvar increment = require('increment').increment;var a = increment(1); //2 注：CommonJs中的require是同步的 三、AMDAMD（Asynchronous Module Definition），意思就是”异步模块定义”。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 1、define()函数RequireJS定义了一个函数 define，它是全局变量，用来定义模块: 1define(id?, dependencies?, factory); id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 factory：模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 123456789101112define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125;&#125;); 2、RequireJs使用12345678910111213// main.js//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min' //可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 12345678910111213// math.jsdefine('math',['jquery'], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;);// main.jsrequire(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 四、CMDCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。 123456define(function(require, exports, module) &#123; // 模块代码&#125;);// require是可以把其他模块导入进来的一个参数;// 而exports是可以把模块内的一些属性和方法导出的;// module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 123456789101112// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('p').addClass('active'); exports.data = 1;&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123; var star= my.data; console.log(star); //1&#125;);]]></content>
      <tags>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts配置项的data格式]]></title>
    <url>%2F2018%2F11%2F13%2Fecharts%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9A%84data%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[echarts配置 图例legend的data 坐标轴xAxis与yAxis的data 数据series的data]]></content>
      <tags>
        <tag>echarts</tag>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动条归属问题]]></title>
    <url>%2F2018%2F11%2F08%2F%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%BD%92%E5%B1%9E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[谁的滚动条 当元素的内容区恰好包含了滚动条时，滚动条属于当前元素（div.outer） overflow溢出的高度是谁的123456&lt;div class="outer"&gt; &lt;div class="inner"&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122.outer &#123; height: 300px; overflow: auto; background-color: antiquewhite;&#125;.inner &#123; height: 200px; background-color: aliceblue;&#125;h1 &#123; height: 250px; margin: 0; padding: 0; background-color: saddlebrown;&#125;p &#123; height: 100px; background-color: cadetblue;&#125; inner的高度只有200px，但是inner的子元素h1和p的高度加起来超过了200px。 inner的height属性为固定值，所以高度没有被撑开，仍然是200px。 inner的overflow属性为默认值visiable，所以内容不会被修剪，会呈现在元素框之外 。 从inner往上追溯，outer的高度也是固定值，也不会被撑开。 outer的overflow属性为auto。 因此从inner溢出的内容高度被outer捕获。 注：如果outer的overflow属性也是visiable，则outer不会出现滚动条，会继续向上抛出溢出内容的高度，直到被更上一层元素捕获。 同理：如果html的overflow属性也是visiable，html会将溢出的内容高度抛给浏览器，所以会有这样的情况：整个页面出现了滚动条，但是滚动条不属于html，也不属于body。但是可以通过window.scrollTo()或者document.documentElement.scrollTop来控制滚动条的移动。]]></content>
      <tags>
        <tag>滚动条</tag>
        <tag>height</tag>
        <tag>overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html和body的背景色问题]]></title>
    <url>%2F2018%2F11%2F08%2Fhtml%E5%92%8Cbody%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[当&lt;html&gt;标签无背景样式时，&lt;body&gt;的背景色其实不是&lt;body&gt;标签的背景色，而是浏览器的。 一旦html标签含有背景色，则&lt;body&gt;的背景色变成了正常的&lt;body&gt;标签（一个实实在在，普普通通标签）的背景色，而此时的&lt;html&gt;标签最顶级，背景色被浏览器获取，成为浏览器的背景色。]]></content>
      <tags>
        <tag>html</tag>
        <tag>body</tag>
        <tag>background-color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align与line-height]]></title>
    <url>%2F2018%2F11%2F07%2Fvertical-align%E4%B8%8Eline-height%2F</url>
    <content type="text"><![CDATA[vertical-alignCSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 相对父元素的值这些值使元素相对其父元素垂直对齐： baseline 使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如textarea ，这意味着这些元素使用此值的表现因浏览器而异。 sub 使元素的基线与父元素的下标基线对齐。 super 使元素的基线与父元素的上标基线对齐。 text-top 使元素的顶部与父元素的字体顶部对齐。 text-bottom 使元素的底部与父元素的字体底部对齐。 middle 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。 height 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。 percentage 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。 相对行的值下列值使元素相对整行垂直对齐： top 使元素及其后代元素的顶部与整行的顶部对齐。 bottom 使元素及其后代元素的底部与整行的底部对齐。 注：特别重要一点，没有基线的元素，使用外边距的下边缘替代，解析如下 inline-block和baseline1The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge. 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。 line-height行内框，每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来，在没有其他因素影响的时候（padding等），行内框等于内容区域，而设定行高时行内框高度不变，半行距【（行高-字体size）/2】分别增加/减少到内容区域的上下两边（深蓝色区域） 行框（line box），行框是指本行的一个虚拟的矩形框，是浏览器渲染模式中的一个概念，并没有实际显示。行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度），当有多行内容时，每行都会有自己的行框。 123456&lt;div style="background-color:#ccc;"&gt; &lt;span style="font-size:1em;background-color:#666;"&gt;中文English&lt;/span&gt; &lt;span style="font-size:3em;background-color:#999;"&gt;中文English&lt;/span&gt; &lt;span style="font-size:3em;background-color:#999;"&gt;English中文&lt;/span&gt; &lt;span style="font-size:1em;background-color:#666;"&gt;English中文&lt;/span&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>line-height</tag>
        <tag>vertical-align</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BEM书写规范]]></title>
    <url>%2F2018%2F10%2F30%2FBEM%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[BEM命名约定使用 BEM 命名规范，理论上讲，每行 css 代码都只有一个选择器。 BEM代表 “块（block）,元素（element）,修饰符（modifier）”,我们常用这三个实体开发组件。 在选择器中，由以下三种符号来表示扩展的关系： 12345- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。__ 双下划线：双下划线用来连接块和块的子元素_ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态type-block__element_modifier 块（block）一个块是设计或布局的一部分，它有具体且唯一地意义 ，要么是语义上的要么是视觉上的。 在大多数情况下，任何独立的页面元素（或复杂或简单）都可以被视作一个块。它的HTML容器会有一个唯一的CSS类名，也就是这个块的名字。 针对块的CSS类名会加一些前缀（ ui-），这些前缀在CSS中有类似 命名空间 的作用。 一个块的正式（实际上是半正式的）定义有下面三个基本原则： CSS中只能使用类名（不能是ID）。 每一个块名应该有一个命名空间（前缀） 每一条CSS规则必须属于一个块。 例如：一个自定义列表 .list 是一个块，通常自定义列表是算在 mod 类别的，在这种情况下，一个 list 列表的block写法应该为: 1.list 元素（element）块中的子元素是块的子元素，并且子元素的子元素在 bem 里也被认为是块的直接子元素。一个块中元素的类名必须用父级块的名称作为前缀。 如上面的例子，li.item 是列表的一个子元素， 123456.list&#123;&#125;.list .item&#123;&#125;.list&#123;&#125;.list__item&#123;&#125; 修饰符（modifier）一个“修饰符”可以理解为一个块的特定状态，标识着它持有一个特定的属性。 用一个例子来解释最好不过了。一个表示按钮的块默认有三个大小：小，中，大。为了避免创建三个不同的块，最好是在块上加修饰符。这个修饰符应该有个名字（比如：size ）和值（ small，normal 或者 big ）。 如上面的例子中，表示一个选中的列表，和一个激活的列表项 12345678910.list&#123;&#125;.list.select&#123;&#125;.list .item&#123;&#125;.list .item.active&#123;&#125; .list&#123;&#125;.list_select&#123;&#125;.list__item&#123;&#125;.list__item_active&#123;&#125; LESS 书写规范使用 .less 后缀的文件来存储变量、混合代码以及最终合并压缩。 子less 注解 lib-base.less 预定义的变量，例如颜色、字号、字体 lib-mixins.less 用于混合的代码，例如渐变、半透明的混合 lib-reset.less 初始化 lib-ui.less 颗粒化ui功能 xxx.less 模块样式 .less 文件的引用顺序会对最终编译的样式的作用域和优先级产生影响，请尽量按照由底层到自定义的顺序来引用。 关于风格书写原则1. 原则上不会出现2层以上选择器嵌套使用BEM原则，用命名来解耦，所有类名都为一层，增加效率和复用性 2. 两层选择器嵌套出现在.mod-xxx__item_current子元素的情况，如下：使用推荐的嵌套写法 常规写法： 12345.xxx&#123;&#125;.xxx__item&#123;&#125;.xxx__item_current&#123;&#125;// 嵌套写法.xxx__item_current .mod-xxx__link&#123;&#125; 推荐： 1234567891011.xxx&#123;&#125;.xxx__item&#123;&#125;.xxx__item_hightlight&#123;&#125;.xxx__product-name&#123;&#125;.xxx__link&#123;&#125;.xxx__ming-zi-ke-yi-hen-chang&#123;&#125;// 嵌套写法.xxx__item_current&#123; .xxx__link&#123;&#125;&#125; 对应的HTML结构如下： 123456789101112131415&lt;ul class="xxx"&gt; &lt;li class="xxx__item"&gt;第一项 &lt;div class="xxx__product-name"&gt;我是名称&lt;/div&gt; &lt;span class="xxx__ming-zi-ke-yi-hen-chang"&gt;看类名&lt;/span&gt; &lt;a href="#" class="xxx__link"&gt;我是link&lt;/a&gt; &lt;li&gt; &lt;li class="xxx__item xxx__item_current"&gt;第二项 且 当前选择项 &lt;div class="xxx__product-name"&gt;我是名称&lt;/div&gt; &lt;a href="#" class="xxx__item-link"&gt;我是link&lt;/a&gt; &lt;li&gt; &lt;li class="xxx__item xxx__item_hightlight"&gt;第三项 且 特殊高亮 &lt;div class="xxx__product-name"&gt;我是名称&lt;/div&gt; &lt;a href="#" class="xxx__item-link"&gt;我是link&lt;/a&gt; &lt;li&gt;&lt;/ul&gt;]]></content>
      <tags>
        <tag>BEM书写规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOLID原则]]></title>
    <url>%2F2018%2F10%2F23%2FSOLID%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[S.O.L.I.D 原则面向对象的编程并不能防止难以理解或不可维护的程序。因此，Robert C. Martin 制定了五项指导原则，使开发人员很容易创建出可读性强且可维护的程序。这五项原则被称为 S.O.L.I.D 原则（这种缩写是由 Michael Feathers 提出的）： S：单一职责原则 （The Single Responsibility Principle） 相关的特性放在一起，因相同的原因而改变 O：开闭原则 （The Open Closed Principle ） 如何区别相关特性？继承 是否真的不可修改 ？可扩展时，不可修改 注：印证了“没有通过增加中间层（继承）不能解决的问题” L：里氏替换原则 （Liskov Substitution Principle ） 继承中，父类与子类的关系？子类无隙替换父类 I：接口隔离原则 （The Interface Segregation Principle ） 如果继承产生了冗余接口？定义细粒度接口 D：依赖倒置原则 （The Dependency Inversion Principle ） 不同模块之间如何产生联系？模块间的依赖是通过抽象发生 相对于细节的多变性，抽象的东西要稳定的多 单一职责原则（SRP）一个类只应该负责一件事。如果一个类有多个职责，那么它变成了耦合的。对一个职责的修改会导致对另一个职责的修改。 注意：这个原则不仅适用于类，也适用于软件组件和微服务。 例如，考虑下面的设计： 12345class Animal &#123; constructor(name: string)&#123; &#125; getAnimalName() &#123; &#125; saveAnimal(a: Animal) &#123; &#125;&#125; 上面的 Animal 就违反了单一职责原则（SRP）。它为什么违反了 SRP？ SRP 指出，类应该有一个职责，在这里，我们可以得出两个职责：动物数据库管理和动物属性管理。构造函数和 getAnimalName 管理动物属性，而 saveAnimal 管理 Animal 在数据库中的存储。 这种设计将来会带来什么问题？ 如果应用程序的修改影响了数据库管理功能，使用 Animal 属性的类就必须修改和重新编译，以适应这种新的变化。这个系统就有点像多米诺骨牌，触碰一张牌就会影响到其他牌。 为了使这个类符合 SRP，我们创建了另一个类，它负责将动物存储到数据库中这个单独的职责： 12345678class Animal &#123; constructor(name: string)&#123; &#125; getAnimalName() &#123; &#125;&#125;class AnimalDB &#123; getAnimal(a: Animal) &#123; &#125; saveAnimal(a: Animal) &#123; &#125;&#125; 在设计我们的类时，我们应该把相关的特性放在一起，这样，每当它们需要改变的时候，它们都是因为同样的原因而改变。如果它们因不同的原因而改变，我们就应该尝试将它们分开。——Steve Fenton 恰当运用这条原则，我们的应用程序就会变成高内聚的。 开闭原则（OCP） 软件实体（类、模块、函数）应该对扩展开放，对修改关闭。 让我们继续以 Animal 类为例。 1234class Animal &#123; constructor(name: string)&#123; &#125; getAnimalName() &#123; &#125;&#125; 我们希望遍历一个动物列表，发出它们的声音。 1234567891011121314//...const animals: Array&lt;Animal&gt; = [ new Animal('lion'), new Animal('mouse')];function AnimalSound(a: Array&lt;Animal&gt;) &#123; for(int i = 0; i &lt;= a.length; i++) &#123; if(a[i].name == 'lion') log('roar'); if(a[i].name == 'mouse') log('squeak'); &#125;&#125;AnimalSound(animals); 函数 AnimalSound 不符合开闭原则，因为它不能对新的动物关闭。如果我们添加一种新的动物蛇： 1234567//...const animals: Array&lt;Animal&gt; = [ new Animal('lion'), new Animal('mouse'), new Animal('snake')]//... 我们就不得不修改 AnimalSound 函数： 123456789101112//...function AnimalSound(a: Array&lt;Animal&gt;) &#123; for(int i = 0; i &lt;= a.length; i++) &#123; if(a[i].name == 'lion') log('roar'); if(a[i].name == 'mouse') log('squeak'); if(a[i].name == 'snake') log('hiss'); &#125;&#125;AnimalSound(animals); 如你所见，对于每一种新的动物，一段新的逻辑会被添加到 AnimalSound 函数。这是一个非常简单的例子。当应用程序变得庞大而复杂时，你会看到，每添加一种新动物，if 语句就得在 AnimalSound 函数中重复一遍。 如何使它（AnimalSound）符合 OCP？ 1234567891011121314151617181920212223242526class Animal &#123; makeSound(); //...&#125;class Lion extends Animal &#123; makeSound() &#123; return 'roar'; &#125;&#125;class Squirrel extends Animal &#123; makeSound() &#123; return 'squeak'; &#125;&#125;class Snake extends Animal &#123; makeSound() &#123; return 'hiss'; &#125;&#125;//...function AnimalSound(a: Array&lt;Animal&gt;) &#123; for(int i = 0; i &lt;= a.length; i++) &#123; log(a[i].makeSound()); &#125;&#125;AnimalSound(animals); Animal 现在有了一个虚方法 makeSound。我们让每一种动物扩展 Animal 类并实现 makeSound 方法。 每一种动物都加入自己的发声方法（makeSound）实现。AnimalSound 遍历动物数组并调用每种动物的 makeSound 方法。 现在，如果我们添加一种新动物，AnimalSound 不需要修改。我们需要做的就是把新动物加入到动物数组中。 AnimalSound 方法符合 OCP 原则了。 再举个例子。假如你有一家商店，你使用下面的类给自己最喜欢的客户 20% 的折扣： 12345class Discount &#123; giveDiscount() &#123; return this.price * 0.2 &#125;&#125; 当你决定给 VIP 客户双倍的折扣（40%）时，你可能会这样修改这个类： 12345678910class Discount &#123; giveDiscount() &#123; if(this.customer == 'fav') &#123; return this.price * 0.2; &#125; if(this.customer == 'vip') &#123; return this.price * 0.4; &#125; &#125;&#125; 这就违反了 OCP 原则。OCP 禁止这样做。如果想给不同类型的客户一个新的折扣百分比，就得添加一段新的逻辑。 为了使它遵循 OCP 原则，我们将新建一个类来扩展 Discount。在这个新类中，我们将重新实现它的行为： 12345class VIPDiscount: Discount &#123; getDiscount() &#123; return super.getDiscount() * 2; &#125;&#125; 如果你决定给超级 VIP 客户 80% 的折扣，那么代码是下面这个样子： 12345class SuperVIPDiscount: VIPDiscount &#123; getDiscount() &#123; return super.getDiscount() * 2; &#125;&#125; 就是这样，扩展而不修改。 里氏替换原则（LSP） 子类必须可以替换它的超类（父类）。 这个原则的目的是确保子类可以替换它的超类而没有错误。如果你发现自己的代码在检查类的类型，那么它一定违反了这个原则。 让我们以 Animal 为例。 123456789101112//...function AnimalLegCount(a: Array&lt;Animal&gt;) &#123; for(int i = 0; i &lt;= a.length; i++) &#123; if(typeof a[i] == Lion) log(LionLegCount(a[i])); if(typeof a[i] == Mouse) log(MouseLegCount(a[i])); if(typeof a[i] == Snake) log(SnakeLegCount(a[i])); &#125;&#125;AnimalLegCount(animals); 上述方法违反了 LSP 原则（也违反了 OCP 原则）。它必须知道每一种 Animal 类型，并调用相应的数腿函数。 每次创建一个新的动物类，都得修改这个函数： 123456789101112131415161718192021//...class Pigeon extends Animal &#123;&#125;const animals[]: Array&lt;Animal&gt; = [ //..., new Pigeon();]function AnimalLegCount(a: Array&lt;Animal&gt;) &#123; for(int i = 0; i &lt;= a.length; i++) &#123; if(typeof a[i] == Lion) log(LionLegCount(a[i])); if(typeof a[i] == Mouse) log(MouseLegCount(a[i])); if(typeof a[i] == Snake) log(SnakeLegCount(a[i])); if(typeof a[i] == Pigeon) log(PigeonLegCount(a[i])); &#125;&#125;AnimalLegCount(animals); 为了使这个函数符合 LSP 原则，我们将遵循 Steve Fenton 提出的 LSP 要求： 如果超类（Animal）有一个方法接受超类类型（Anima）的参数，那么它的子类（Pigeon）应该接受超类类型（Animal 类型）或子类类型（Pigeon 类型）作为参数。 如果超类返回一个超类类型（Animal）, 那么它的子类应该返回一个超类类型（Animal 类型）或子类类型（Pigeon 类型）。 现在，我们可以重新实现 AnimalLegCount 函数了： 123456function AnimalLegCount(a: Array&lt;Animal&gt;) &#123; for(let i = 0; i &lt;= a.length; i++) &#123; a[i].LegCount(); &#125;&#125;AnimalLegCount(animals); AnimalLegCount 函数并不关心传递的动物类型，它只管调用 LegCount 方法。它只知道参数必须是 Animal 类型，要么是 Animal 类，要么是它的子类。 现在，Animal 类必须实现 / 定义一个 LegCount 方法： 1234class Animal &#123; //... LegCount();&#125; 而它的子类必须实现 LegCount 方法： 12345678//...class Lion extends Animal&#123; //... LegCount() &#123; //... &#125;&#125;//... 当它被传递给 AnimalLegCount 函数时，它会返回一头狮子的腿数。 如你所见，AnimalLegCount 不需要知道动物的类型就可以返回它的腿数，它只调用了 Animal 类型的 LegCount 方法，因为根据约定，Animal 类的一个子类必须实现 LegCount 函数。 接口隔离原则（ISP） 创建特定于客户端的细粒度接口。不应该强迫客户端依赖于它们不使用的接口。 这个原则是为了克服实现大接口的缺点。让我们看看下面的 IShape 接口： 12345interface IShape &#123; drawCircle(); drawSquare(); drawRectangle();&#125; 这个接口可以绘制正方形、圆形、矩形。实现 IShape 接口的类 Circle、Square 和 Rectangle 必须定义方法 drawCircle()、drawSquare()、drawRectangle()。 123456789101112131415161718192021222324252627282930313233class Circle implements IShape &#123; drawCircle()&#123; //... &#125; drawSquare()&#123; //... &#125; drawRectangle()&#123; //... &#125; &#125;class Square implements IShape &#123; drawCircle()&#123; //... &#125; drawSquare()&#123; //... &#125; drawRectangle()&#123; //... &#125; &#125;class Rectangle implements IShape &#123; drawCircle()&#123; //... &#125; drawSquare()&#123; //... &#125; drawRectangle()&#123; //... &#125; &#125; 上面的代码很有趣。类 Rectangle 实现了它没有使用的方法 drawCircle 和 drawSquare，同样，Square 实现了 drawCircle 和 drawRectangle，Circle 实现了 drawSquare 和 drawRectangle。 如果我们向 IShape 接口添加另一个方法，比如 drawTriangle()： 123456interface IShape &#123; drawCircle(); drawSquare(); drawRectangle(); drawTriangle();&#125; 那么，这些类就必须实现新方法，否则就会抛出错误。 我们看到，不可能实现这样一种形状类，它可以画圆，但不能画矩形、正方形或三角形。我们在实现方法时可以只抛出一个错误，表明操作无法执行。 ISP 反对 IShape 接口的这种设计。客户端（这里是 Rectangle、Circle 和 Square）不应该被迫依赖于它们不需要或不使用的方法。另外，ISP 指出，接口应该只执行一个任务（就像 SRP 原则一样），任何额外的行为都应该抽象到另一个接口中。 在这里，我们的 IShape 接口执行了应该由其他接口独立处理的操作。为了使 IShape 接口符合 ISP 原则，我们将对不同接口的操作进行隔离： 12345678910111213141516171819202122232425262728293031323334353637383940interface IShape &#123; draw();&#125;interface ICircle &#123; drawCircle();&#125;interface ISquare &#123; drawSquare();&#125;interface IRectangle &#123; drawRectangle();&#125;interface ITriangle &#123; drawTriangle();&#125;class Circle implements ICircle &#123; drawCircle() &#123; //... &#125;&#125;class Square implements ISquare &#123; drawSquare() &#123; //... &#125;&#125;class Rectangle implements IRectangle &#123; drawRectangle() &#123; //... &#125; &#125;class Triangle implements ITriangle &#123; drawTriangle() &#123; //... &#125;&#125;class CustomShape implements IShape &#123; draw()&#123; //... &#125;&#125; ICircle 接口仅处理圆的绘制，IShape 处理任何形状的绘制，ISquare 只处理正方形的绘制，IRectangle 处理矩形的绘制。 或者，类（Circle、Rectangle、Square、Triangle）必须继承 IShape 接口，并实现自己的绘制行为。 1234567891011121314151617181920212223class Circle implements IShape &#123; draw()&#123; //... &#125;&#125;class Triangle implements IShape &#123; draw()&#123; //... &#125;&#125;class Square implements IShape &#123; draw()&#123; //... &#125;&#125;class Rectangle implements IShape &#123; draw()&#123; //... &#125;&#125; 然后，我们可以使用 I- 接口创建具体的形状，如半圆、直角三角形、等边三角形、钝边矩形等。 依赖倒置原则（DIP） 依赖应该是抽象的，而不是具体的。 高级模块不应该依赖于低级模块。两者都应该依赖于抽象。 抽象不应该依赖于细节。细节应该依赖于抽象。 在软件开发中，我们的应用程序最终主要是由模块组成。当这种情况出现时，我们必须使用依赖注入来解决。高级组件依赖于低级组件发挥作用。 1234567891011class XMLHttpService extends XMLHttpRequestService &#123;&#125;class Http &#123; constructor(private xmlhttpService: XMLHttpService) &#123; &#125; get(url: string , options: any) &#123; this.xmlhttpService.request(url,'GET'); &#125; post() &#123; this.xmlhttpService.request(url,'POST'); &#125; //...&#125; 这里，Http 是高级组件，而 HttpService 是低级组件。这种设计违反了 DIP A：高级模块不应该依赖于低级模块。它应该依赖于它的抽象。 该 Http 类被迫依赖于 XMLHttpService 类。如果我们要修改 Http 连接服务，也许我们想通过 Nodejs 连接到互联网，甚至模拟 http 服务。我们将不得不费力地遍历所有 Http 实例来编辑代码，这违反了 OCP 原则。 Http 类不应该关心使用的 Http 服务的类型。我们做了一个 Connection 接口： 123interface Connection &#123; request(url: string, opts:any);&#125; Connection 接口有一个 request 方法。有了这个接口，我们就可以向 Http 类传递一个 Connection 类型的参数： 12345678910class Http &#123; constructor(private httpConnection: Connection) &#123; &#125; get(url: string , options: any) &#123; this.httpConnection.request(url,'GET'); &#125; post() &#123; this.httpConnection.request(url,'POST'); &#125; //...&#125; 因此，无论传递给 Http 类的 Http 连接服务是什么类型，它都可以轻松地连接到网络，而无需知道网络连接的类型。 现在，我们重新实现 XMLHttpService 类来实现 Connection 接口： 12345678class XMLHttpService implements Connection &#123; const xhr = new XMLHttpRequest(); //... request(url: string, opts:any) &#123; xhr.open(); xhr.send(); &#125;&#125; 我们可以创建许多 Http 连接类型，并将其传递给 Http 类，而不必担心错误。 12345678910class NodeHttpService implements Connection &#123; request(url: string, opts:any) &#123; //... &#125;&#125;class MockHttpService implements Connection &#123; request(url: string, opts:any) &#123; //... &#125; &#125; 现在，我们可以看到，高级模块和低级模块都依赖于抽象。Http 类（高级模块）依赖于 Connection 接口（抽象），而 Http 服务类型（低级模块）也依赖于 Connection 接口（抽象）。 此外，DIP 原则会强制我们遵循里氏替换原则：Connection 类型 Node-XML-MockHttpService 可以替换它们的父类型连接。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。]]></content>
      <tags>
        <tag>solid</tag>
        <tag>SOLID</tag>
        <tag>S.O.L.I.D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确评估项目开发时间]]></title>
    <url>%2F2018%2F10%2F19%2F%E6%AD%A3%E7%A1%AE%E8%AF%84%E4%BC%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[前言经常遇到开发时间预估不准，当然大多数是延期，那么延期的项目是因为什么呢一般？ 常见问题部分时间未考虑一般情况下是因为我们评估的是直接的开发时间，而且是顺利情况、大家都了解需求，没有任何疑问和阻碍的情况下。实际上，这种非常顺利的场景基本不存在。 那么我们除了正常的开发时间还需要评估几类时间到你的项目时间预估中。 需求熟悉时间以及代码定位 原因 ：尽量减少大量时间找代码，少数时间修代码的场景，也能避免改错位置 时间占比： 开发时间30%~50% 开发时间：（正常时间） 原因 ：正常开发时间需要 时间占比：开发时间100% 前后端联调以及ui矫正 原因 ：一般联调是比较占时间，字段不一致、各种场景、联调高效性、来回验证、产品以及ui的校验效果 时间占比：开发时间20%~50% 等待时间以及与产品确定时间： 原因 ：某些不确定需求商榷时间，团队成员时间空档不一致，各个职能思考确定 时间占比：开发时间20%~30% Buffer 时间 原因 ：开发完成自测之后，需要对开发阶段暴露的问题进行记录甚至项目中统一优化，避免下个阶段的问题重现，个人时间的缓冲期，做下个阶段的预研以及本阶段可能遗留问题的方案的研究。 时间占比 ：开发时间20%~30% 综上：一般情况下，我们最少要留出20%的buffer时间，这是最少前提；有风险以及不确定情况，或者追加团队不熟悉项目，团队互相不熟悉情况下，建议评估时间为:正常开发时间的150%~200%，以保证在该阶段能尽快的磨合，找到合理的开发进度。（如果觉得这样的评估时间太长，可以将需求量减少，但是需求细化）。 最终目的 ：让项目估期具有可参考性；给出团队合理的磨合期以及总结缓冲时间。]]></content>
      <tags>
        <tag>开发时间</tag>
        <tag>评估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript隐式转换]]></title>
    <url>%2F2018%2F10%2F18%2Fjs%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[javascript隐式转换规则1. ToString，ToNumber，ToBoolean，ToPrimitive我们需要先了解一下js数据类型之间转换的基本规则，比如数字、字符串、布尔型、数组、对象之间的相互转换。 1.1 ToString 这里所说的ToString可不是对象的toString方法，而是指其他类型的值转换为字符串类型的操作。 这里我们讨论null、undefined、布尔型、数字、数组、普通对象转换为字符串的规则。 null：转为&quot;null&quot; undefined：转为&quot;undefined&quot; 布尔类型：true和false分别被转为&quot;true&quot;和&quot;false&quot; 数字类型：转为数字的字符串形式，如10转为&quot;10&quot;， 1e21转为&quot;1e+21&quot; 数组：转为字符串是将所有元素按照”,”连接起来，相当于调用数组的Array.prototype.join()方法 [1, 2, 3]转为&quot;1,2,3&quot; 空数组[]转为空字符串 数组中的null或undefined，会被当做空字符串处理 普通对象：转为字符串相当于直接使用Object.prototype.toString()，返回&quot;[object Object]&quot; 12345678910String(null) // 'null'String(undefined) // 'undefined'String(true) // 'true'String(10) // '10'String(1e21) // '1e+21'String([1,2,3]) // '1,2,3'String([]) // ''String([null]) // ''String([1, undefined, 3]) // '1,,3'String(&#123;&#125;) // '[object Objecr]' 对象的toString方法，满足ToString操作的规则。 注意：上面所说的规则是在默认的情况下，如果修改默认的toString()方法，会导致不同的结果 1.2 ToNumber ToNumber指其他类型转换为数字类型的操作。 null： 转为0 undefined：转为NaN 字符串：如果是纯数字形式，则转为对应的数字，空字符转为0, 否则一律按转换失败处理，转为NaN 布尔型：true和false被转为1和0 数组：数组首先会被转为原始类型，也就是ToPrimitive，然后在根据转换后的原始类型按照上面的规则处理，关于ToPrimitive，会在下文中讲到 对象：同数组的处理 12345678910Number(null) // 0Number(undefined) // NaNNumber('10') // 10Number('10a') // NaNNumber('') // 0 Number(true) // 1Number(false) // 0Number([]) // 0Number(['1']) // 1Number(&#123;&#125;) // NaN 1.3 ToBoolean ToBoolean指其他类型转换为布尔类型的操作。 js中的假值只有false、null、undefined、空字符、0和NaN，其它值转为布尔型都为true。 12345678Boolean(null) // falseBoolean(undefined) // falseBoolean('') // flaseBoolean(NaN) // flaseBoolean(0) // flaseBoolean([]) // trueBoolean(&#123;&#125;) // trueBoolean(Infinity) // true 1.4 ToPrimitive ToPrimitive指对象类型类型（如：对象、数组）转换为原始类型的操作。 当对象类型需要被转为原始类型时，它会先查找对象的valueOf方法，如果valueOf方法返回原始类型的值，则ToPrimitive的结果就是这个值 如果valueOf不存在或者valueOf方法返回的不是原始类型的值，就会尝试调用对象的toString方法，也就是会遵循对象的ToString规则，然后使用toString的返回值作为ToPrimitive的结果。 如果valueOf和toString都没有返回原始类型的值，则会抛出异常。 1234567891011121314151617181920212223242526Number([]) // 0Number(['10']) //10const obj1 = &#123; valueOf () &#123; return 100 &#125;, toString () &#123; return 101 &#125;&#125;Number(obj1) // 100const obj2 = &#123; toString () &#123; return 102 &#125;&#125;Number(obj2) // 102const obj3 = &#123; toString () &#123; return &#123;&#125; &#125;&#125;Number(obj3) // TypeError 前面说过，对象类型在ToNumber时会先ToPrimitive，再根据转换后的原始类型ToNumber Number([])， 空数组会先调用valueOf，但返回的是数组本身，不是原始类型，所以会继续调用toString，得到空字符串，相当于Number(&#39;&#39;)，所以转换后的结果为&quot;0&quot; 同理，Number([&#39;10&#39;])相当于Number(&#39;10&#39;)，得到结果10 obj1的valueOf方法返回原始类型100，所以ToPrimitive的结果为100 obj2没有valueOf，但存在toString，并且返回一个原始类型，所以Number(obj2)结果为102 obj3的toString方法返回的不是一个原始类型，无法ToPrimitive，所以会抛出错误 2. 宽松相等（==）比较时的隐式转换规则宽松相等（==）和严格相等（===）的区别在于宽松相等会在比较中进行隐式转换。现在我们来看看不同情况下的转换规则。 2.1 布尔类型和其他类型的相等比较 只要布尔类型参与比较，该布尔类型的值首先会被转换为数字类型 根据布尔类型的ToNumber规则，true转为1，false转为0 123false == 0 // truetrue == 1 // truetrue == 2 // false 之前有的人可能觉得数字2是一个真值，所以true == 2应该为真，现在明白了，布尔类型true参与相等比较会先转为数字1，相当于1 == 2，结果当然是false 我们平时在使用if判断时，一般都是这样写 1234const x = 10if (x) &#123; console.log(x)&#125; 这里if(x)的x会在这里被转换为布尔类型，所以代码可以正常执行。但是如果写成这样： 1234const x = 10if (x == true) &#123; console.log(x)&#125; 代码不会按照预期执行，因为x == true相当于10 == 1 2.2 数字类型和字符串类型的相等比较 当数字类型和字符串类型做相等比较时，字符串类型会被转换为数字类型 根据字符串的ToNumber规则，如果是纯数字形式的字符串，则转为对应的数字，空字符转为0, 否则一律按转换失败处理，转为NaN 12345670 == '' // true1 == '1' // true1e21 == '1e21' // trueInfinity == 'Infinity' // truetrue == '1' // truefalse == '0' // truefalse == '' // true 上面比较的结果和你预期的一致吗？ 根据规则，字符串转为数字，布尔型也转为数字，所以结果就显而易见了。 这里就不讨论NaN了，因为NaN和任何值都不相等，包括它自己。 2.3 对象类型和原始类型的相等比较 当对象类型和原始类型做相等比较时，对象类型会依照ToPrimitive规则转换为原始类型 12'[object Object]' == &#123;&#125; // true'1,2,3' == [1, 2, 3] // true 看一下文章开始时给出的例子 1[2] == 2 // true 数组[2]是对象类型，所以会进行ToPrimitive操作，也就是先调用valueOf再调用toString，根据数组ToString操作规则，会得到结果&quot;2&quot;， 而字符串&quot;2&quot;再和数字2比较时，会先转为数字类型，所以最后得到的结果为true。 123[null] == 0 // true[undefined] == 0 // true[] == 0 // true 根据上文中提到的数组ToString操作规则，数组元素为null或undefined时，该元素被当做空字符串处理，而空数组[]也被转为空字符串，所以上述代码相当于 123'' == 0 // true'' == 0 // true'' == 0 // true 空字符串会转换为数字0，所以结果为true。 试试valueOf方法 123456789const a = &#123; valueOf () &#123; return 10 &#125; toString () &#123; return 20 &#125;&#125;a == 10 // true 对象的ToPrimitive操作会先调用valueOf方法，并且a的valueOf方法返回一个原始类型的值，所以ToPrimitive的操作结果就是valueOf方法的返回值10。 对象每次和原始类型做==比较时，都会进行一次ToPrimitive操作，那我们是不是可以定义一个包含valueOf方法的对象，然后通过某个值的累加来实现？ 试一试 12345678const a = &#123; // 定义一个属性来做累加 i: 1, valueOf () &#123; return this.i++ &#125;&#125;a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true 结果正如你所想的，是正确的。当然，当没有定义valueOf方法时，用toString方法也是可以的。 12345678const a = &#123; // 定义一个属性来做累加 i: 1, toString () &#123; return this.i++ &#125;&#125;a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 // true 2.4 null、undefined和其他类型的比较 null和undefined宽松相等的结果为true，这一点大家都知道 其次，null和undefined都是假值，那么 12null == false // falseundefined == false // false 居然跟我想的不一样？为什么呢？ 首先，false转为0，然后呢？ 没有然后了，ECMAScript规范中规定null和undefined之间互相宽松相等（==），并且也与其自身相等，但和其他所有的值都不宽松相等（==）。 最后现在这一段代码就明了了许多 1234567891011121314151617181920212223[] == ![] // true[] == 0 // true[2] == 2 // true['0'] == false // true'0' == false // true[] == false // true[null] == 0 // truenull == 0 // false[null] == false // truenull == false // false[undefined] == false // trueundefined == false // false]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用性与适用性]]></title>
    <url>%2F2018%2F10%2F13%2F%E9%80%9A%E7%94%A8%E6%80%A7%E4%B8%8E%E9%80%82%E7%94%A8%E6%80%A7%2F</url>
    <content type="text"><![CDATA[通用性高 优点：满足多种使用场景 缺点：糅合多种使用场景，必然有相应的代价 代码逻辑会变得更加复杂，甚至难以理解 复杂的代码，不利于维护 适用性高 优点：只适用特定场景 缺点：功能单一 如何满足多种使用场景，又便于维护？ 函数单一职责 要么全职负责拧螺丝钉 要么全职负责调度 注：函数通过调度，分派任务给拧螺丝钉的其他函数。]]></content>
      <tags>
        <tag>通用性</tag>
        <tag>适用性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document.body.scrollTop与document.documentElement.scrollTop]]></title>
    <url>%2F2018%2F10%2F13%2Fbody-scrollTop%E4%B8%8EdocumentElement-scrollTop%2F</url>
    <content type="text"><![CDATA[古代浏览器间的 scrollTop差异 IE6/7/8：使用 document.documentElement.scrollTop； IE9及以上：使用window.pageYOffset或者document.documentElement.scrollTop Safari: window.pageYOffset 与document.body.scrollTop都可以； Firefox: window.pageYOffset 或者 document.documentElement.scrollTop； Chrome：只认识document.body.scrollTop; 注：document.body.scrollTop与document.documentElement.scrollTop同时只会有一个值生效。 1let sTop = document.body.scrollTop || document.documentElement.scrollTop; 2018-10-30更新：浏览器 =》古代浏览器chrome: html元素作为body元素的父类，遵行普通父元素与子元素之间的关系 document.body作为body元素dom对象的引用 document.documentElement作为html元素dom对象的引用 document.compatMode1mode = document.compatMode 如果文档处于“怪异模式”，则该属性值为&quot;BackCompat&quot; 如果文档处于“标准模式”或者“准标准模式(almost standards mode)”，则该属性为&quot;CSS1Compat&quot; 注：还有另外一种渲染模式, Gecko的”准标准模式”, 该模式和标准规范模式的区别仅为表格单元内的图片布局方式不同. 且该模式的类型字符串仍为: “CSS1Compat”. Document.scrollingElementscrollingElement （ Document 的只读属性）返回滚动文档的 Element 对象的引用。 在标准模式（Standards Mode）下, 这是文档的根元素, document.documentElement. 当在怪异模式（Quirks Mode）下， scrollingElement 属性返回 HTML body 元素（若不存在返回 null ）。 Window.scrollTo123456789// window.scrollTo(x-coord,y-coord )window.scrollTo( 0, 1000 );// window.scrollTo(options)// 设置滚动行为改为平滑的滚动window.scrollTo(&#123; top: 1000, behavior: "smooth" &#125;); x-coord 是文档中的横轴坐标。 y-coord 是文档中的纵轴坐标。 options 是一个包含三个属性的对象: top 等同于 y-coord left 等同于 x-coord behavior 类型 String，表示滚动行为。 支持参数 smooth(平滑滚动)，instant(瞬间滚动) 默认值auto，实测效果等同于instant 注：window.scrollTo滚动的容器为document.documentElement window.scrollBy12window.scrollBy(x-coord, y-coord);window.scrollBy(options) 注：window.scrollBy的参数与window.scrollTo一样，但是window.scrollBy中的x-coord 、y-coord、top、left 可以是负值。window.scrollBy是以自身为参考点，window.scrollTo以浏览器窗口为参考点。]]></content>
      <tags>
        <tag>document.body.scrollTop</tag>
        <tag>document.documentElement.scrollTop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pointfree编程风格指南]]></title>
    <url>%2F2018%2F10%2F11%2FPointfree%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[一、程序的本质为了理解 Pointfree，请大家先想一想，什么是程序？ 上图是一个编程任务，左侧是数据输入（input），中间是一系列的运算步骤，对数据进行加工，右侧是最后的数据输出（output）。一个或多个这样的任务，就组成了程序。 输入和输出（统称为 I/O）与键盘、屏幕、文件、数据库等相关，这些跟本文无关。这里的关键是，中间的运算部分不能有 I/O 操作，应该是纯运算，即通过纯粹的数学运算来求值。否则，就应该拆分出另一个任务。 注：函数单一职责原则：拆分依据（纯粹数学运算） I/O 操作往往有现成命令，大多数时候，编程主要就是写中间的那部分运算逻辑。现在，主流写法是过程式编程和面向对象编程，但是我觉得，最合适纯运算的是函数式编程。 二、函数的拆分与合成上面那张图中，运算过程可以用一个函数fn表示。 fn的类型如下。 12&gt; fn :: a -&gt; b&gt; 上面的式子表示，函数fn的输入是数据a，输出是数据b。 如果运算比较复杂，通常需要将fn拆分成多个函数。 f1、f2、f3的类型如下。 1234&gt; f1 :: a -&gt; m&gt; f2 :: m -&gt; n&gt; f3 :: n -&gt; b&gt; 上面的式子中，输入的数据还是a，输出的数据还是b，但是多了两个中间值m和n。 我们可以把整个运算过程，想象成一根水管（pipe），数据从这头进去，那头出来。 函数的拆分，无非就是将一根水管拆成了三根。 进去的数据还是a，出来的数据还是b。fn与f1、f2、f3的关系如下。 12&gt; fn = R.pipe(f1, f2, f3);&gt; 上面代码中，我用到了 Ramda 函数库的pipe方法，将三个函数合成为一个。Ramda 是一个非常有用的库，后面的例子都会使用它，如果你还不了解，可以先读一下教程。 三、Pointfree 的概念 12&gt; fn = R.pipe(f1, f2, f3);&gt; 这个公式说明，如果先定义f1、f2、f3，就可以算出fn。整个过程，根本不需要知道a或b。 也就是说，我们完全可以把数据处理的过程，定义成一种与参数无关的合成运算。不需要用到代表数据的那个参数，只要把一些简单的运算步骤合成在一起即可。 这就叫做 Pointfree：不使用所要处理的值，只合成运算过程。中文可以译作”无值”风格。请看下面的例子。 123&gt; var addOne = x =&gt; x + 1;&gt; var square = x =&gt; x * x;&gt; 上面是两个简单函数addOne和square。 把它们合成一个运算。 1234&gt; var addOneThenSquare = R.pipe(addOne, square);&gt; &gt; addOneThenSquare(2) // 9&gt; 上面代码中，addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。 四、Pointfree 的本质Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。 比如，读取对象的role属性，不要直接写成obj.role，而是要把这个操作封装成函数。 123&gt; var prop = (p, obj) =&gt; obj[p];&gt; var propRole = R.curry(prop)('role');&gt; 上面代码中，prop函数封装了读取操作。它需要两个参数p（属性名）和obj（对象）。这时，要把数据obj要放在最后一个参数，这是为了方便柯里化。函数propRole则是指定读取role属性，下面是它的用法（查看完整代码）。 1234567891011121314&gt; var isWorker = s =&gt; s === 'worker';&gt; var getWorkers = R.filter(R.pipe(propRole, isWorker));&gt; &gt; var data = [&gt; &#123;name: '张三', role: 'worker'&#125;,&gt; &#123;name: '李四', role: 'worker'&#125;,&gt; &#123;name: '王五', role: 'manager'&#125;,&gt; ];&gt; getWorkers(data)&gt; // [&gt; // &#123;"name": "张三", "role": "worker"&#125;,&gt; // &#123;"name": "李四", "role": "worker"&#125;&gt; // ]&gt; 上面代码中，data是传入的值，getWorkers是处理这个值的函数。定义getWorkers的时候，完全没有提到data，这就是 Pointfree。 简单说，Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。 五、Pointfree 的示例一下面，我们来看一个示例。 12&gt; var str = 'Lorem ipsum dolor sit amet consectetur adipiscing elit';&gt; 上面是一个字符串，请问其中最长的单词有多少个字符？ 我们先定义一些基本运算。 12345678910111213141516&gt; // 以空格分割单词&gt; var splitBySpace = s =&gt; s.split(' ');&gt; &gt; // 每个单词的长度&gt; var getLength = w =&gt; w.length;&gt; &gt; // 词的数组转换成长度的数组&gt; var getLengthArr = arr =&gt; R.map(getLength, arr); &gt; &gt; // 返回较大的数字&gt; var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;&gt; &gt; // 返回最大的一个数字&gt; var findBiggestNumber = &gt; arr =&gt; R.reduce(getBiggerNumber, 0, arr);&gt; 然后，把基本运算合成为一个函数（查看完整代码）。 12345678&gt; var getLongestWordLength = R.pipe(&gt; splitBySpace,&gt; getLengthArr,&gt; findBiggestNumber&gt; );&gt; &gt; getLongestWordLength(str) // 11&gt; 可以看到，整个运算由三个步骤构成，每个步骤都有语义化的名称，非常的清晰。这就是 Pointfree 风格的优势。 Ramda 提供了很多现成的方法，可以直接使用这些方法，省得自己定义一些常用函数（查看完整代码）。 1234567&gt; // 上面代码的另一种写法&gt; var getLongestWordLength = R.pipe(&gt; R.split(' '),&gt; R.map(R.length),&gt; R.reduce(R.max, 0)&gt; );&gt;]]></content>
      <tags>
        <tag>Pointfree</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柯里化-currying]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%9F%AF%E9%87%8C%E5%8C%96-currying%2F</url>
    <content type="text"><![CDATA[什么是柯里化？在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数且返回结果的新函数的技术。 12345678function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function() &#123; var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); &#125;;&#125; 注：柯里化主要是利用闭包，将单一参数封装起来。 123456789101112131415161718192021function square(i) &#123; return i * i;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;// 通用性写法map(square, [1, 2, 3, 4, 5]);map(square, [6, 7, 8, 9, 10]);map(square, [10, 20, 30, 40, 50]);// 柯里化写法// 固定mapSQ的单一参数，降低通用性，提高适用性var mapSQ = currying(map, square); // square 为单一参数mapSQ([1, 2, 3, 4, 5]);mapSQ([6, 7, 8, 9, 10]);mapSQ([10, 20, 30, 40, 50]);// 通用设计与专门设计相比，功能更多，但效率却更低。 柯里化的用途 降低通用性，提高适用性 延迟执行 1234567891011121314151617var add = function() &#123; var _this = this, _args = arguments; return function() &#123; if (!arguments.length) &#123; var sum = 0; for (var i = 0, c; c = _args[i++];) &#123; sum += c; &#125; return sum; &#125; else &#123; Array.prototype.push.apply(_args, arguments); return arguments.callee; &#125; &#125;&#125;add(1)(2)(3)(4)(); //10]]></content>
      <tags>
        <tag>柯里化</tag>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减少if-else和switch]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%87%8F%E5%B0%91if-else%E5%92%8Cswitch%2F</url>
    <content type="text"><![CDATA[原文 1. 使用 Array.includes 来处理多重条件举个栗子 🌰： 123456// 条件语句function test(fruit) &#123; if (fruit == 'apple' || fruit == 'strawberry') &#123; console.log('red'); &#125;&#125; 乍一看，这么写似乎没什么大问题。然而，如果我们想要匹配更多的红色水果呢，比方说『樱桃』和『蔓越莓』？我们是不是得用更多的 || 来扩展这条语句？ 我们可以使用 Array.includes(Array.includes) 重写以上条件句。 1234567function test(fruit) &#123; // 把条件提取到数组中 const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) &#123; console.log('red'); &#125;&#125; 我们把红色的水果（条件）都提取到一个数组中，这使得我们的代码看起来更加整洁。 2. 少写嵌套，尽早返回让我们为之前的例子添加两个条件： 如果没有提供水果，抛出错误。 如果该水果的数量大于 10，将其打印出来。 123456789101112131415161718192021function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1：fruit 必须有值 if (fruit) &#123; // 条件 2：必须为红色 if (redFruits.includes(fruit)) &#123; console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125; &#125; &#125; else &#123; throw new Error('No fruit!'); &#125;&#125;// 测试结果test(null); // 报错：No fruitstest('apple'); // 打印：redtest('apple', 20); // 打印：red，big quantity 遵循的一个总的规则是当发现无效条件时尽早返回 1234567891011/_ 当发现无效条件时尽早返回 _/function test(fruit, quantity) &#123; const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (!fruit) throw new Error('No fruit!'); // 条件 1：尽早抛出错误 if (!redFruits.includes(fruit)) return; // 条件 2：当 fruit 不是红色的时候，直接返回 console.log('red'); // 条件 3：必须是大量存在 if (quantity &gt; 10) &#123; console.log('big quantity'); &#125;&#125; 3. 相较于 switch，Map / Object 也许是更好的选择让我们看下面的例子，我们想要根据颜色打印出各种水果： 1234567891011121314151617function test(color) &#123; // 使用 switch case 来找到对应颜色的水果 switch (color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;//测试结果test(null); // []test('yellow'); // ['banana', 'pineapple'] 上面的代码看上去并没有错，但是它看上去很冗长。同样的结果可以通过对象字面量来实现，语法也更加简洁： 12345678910// 使用对象字面量来找到对应颜色的水果 const fruitColor = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] &#125;;function test(color) &#123; return fruitColor[color] || [];&#125; 或者，你也可以使用 Map 来实现同样的效果： 123456789// 使用 Map 来找到对应颜色的水果 const fruitColor = new Map() .set('red', ['apple', 'strawberry']) .set('yellow', ['banana', 'pineapple']) .set('purple', ['grape', 'plum']);function test(color) &#123; return fruitColor.get(color) || [];&#125;]]></content>
      <tags>
        <tag>if-else</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信问题专题]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%BE%AE%E4%BF%A1%E9%97%AE%E9%A2%98%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、微信转发分享12345朋友圈 from=timeline&amp;isappinstalled=0微信群 from=groupmessage&amp;isappinstalled=0好友分享 from=singlemessage&amp;isappinstalled=0 现象：根据不同途径的转发分享，微信浏览器会偷偷添加以上参数。 坑点：对于配置了JSSDK使用权限的网页，会导致二次分享，权限认证失败。 二、微信临时链接与永久链接搜狗微信搜索出来的文章链接均为微信的临时链接，通过客户端查看的文章链接均为永久链接 1、临时链接1临时链接：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1532856601&amp;ver=1028&amp;signature=eJN640RjdfsNhOXpOBZF9blBd4fbsYzDp9va9p8yhHGwDSc1*UPlviVRt*o2do10V-WJ-lxf8eD5FYWEC8ZMfNhyu1iTwYw9Qel1BqVhNlF8cKAxXIorsK-Bu2BcplG2&amp;new=1 特点为： 浏览有效期自生成起6个小时，超出时间直接使用浏览器访问将会显示‘链接已过期’，可以通过微信客户端访问(此时将自动转变为微信永久链接的短连接形式) 链接有效期自生成起约50天，超出该期限的链接将无法在客户端中打开，将显示‘系统错误’。这就是微信临时链接在微信客户端查看显示系统错误的原因。 临时链接直接在浏览器中浏览不显示阅读数以及点赞数，页面中仅包含biz，mid，idx，不包含sn参数（稍后解释） 快速辨识方法：链接中含有timestamp、signature字段。 2、永久链接12微信永久链接-短连接：https://mp.weixin.qq.com/s/AEfszx7uOxVgfVlmUls7UA微信永久链接-原始长链接：https://mp.weixin.qq.com/s?__biz=MzI2MjAwODM0Ng==&amp;mid=2660080082&amp;idx=1&amp;sn=f84457b8ee976e373eacc698d2b276db&amp;scene=0 特点为： 永久有效，可直接在浏览器中访问不会有时效限制 直接访问仍然没有阅读数以及点赞数，页面中包含biz，mid，idx和sn参数 短连接可以通过拼接参数的方式还原成长链接，长链接需借助客户端转为短连接 3、参数解释biz：微信公众号的唯一标识ID mid：每次推送生成一个mid，同一次推送下mid相同 idx：当次推送的位置（1为首篇，2为第二篇…） sn：每一篇文章的唯一ID，也是区别临时链接和永久链接的关键参数 临时链接的页面上是没有sn的，只能通过临时链接中本身的signature参数来找到该篇文章，但是该参数如前所述是有有效期的。因此抓取到的微信临时链接只能保证6小时内可以打开，超出时效后只能复制到微信中查看。]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise、async和await的执行顺序]]></title>
    <url>%2F2018%2F10%2F10%2Fpromise%E3%80%81async%E5%92%8Cawait%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1、题目和答案一道题题目：下面这段promise、async和await代码，请问控制台打印的顺序？ 1234567891011121314151617181920212223242526async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function() &#123; console.log('setTimeout')&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1') resolve();&#125;).then(function() &#123; console.log('promise2')&#125;)console.log('script end') 上述，在Chrome 66和node v10中，正确输出是： 12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout 2、知识点显然，这考察的是js中的事件循环和回调队列。注意以下几点： Promise优先于setTimeout宏任务。所以，setTimeout回调会在最后执行。 Promise一旦被定义，就会立即执行。 Promise的reject和resolve是异步执行的回调。所以，resolve()会被放到回调队列中，在主函数执行完和setTimeout前调用。 await执行完后，会让出线程。async标记的函数会返回一个Promise对象 3、 难点 最令人困惑的，就是async1 end在promise2之后输出 4、 猜测await表达式1[return_value] = await expression; 123456789101112// expression 可能被转换成如下代码function _expression() &#123; let result = eval(expression); let isPromise = result.toString().includes('Promise'); if (isPromise) &#123; result.then(Promise.resolve, Promise.reject); &#125; else &#123; return Promise.resolve(result); &#125;&#125;// 无果// 这段时间太忙了（2018/10/10），逃~~~]]></content>
      <tags>
        <tag>promise</tag>
        <tag>async</tag>
        <tag>await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不支持伪元素的标签]]></title>
    <url>%2F2018%2F09%2F21%2F%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[单标签不支持 伪元素 img、 input、select 这种单标签不支持::before、 ::after 注：不能包含其他元素，所以不能通过伪元素插入内容]]></content>
      <tags>
        <tag>伪元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名规则]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[项目命名全部采用小写方式， 以下划线（_）或破折号（-）连接单词 注：库文件可用逗点（.），用于体现版本或从属关系 例：my_project_name 目录命名参照项目命名规则； 有复数结构时，要采用复数命名法。 例：scripts, styles, images, data_models JS文件命名参照项目命名规则。 例：account_model.js CSS, SCSS文件命名参照项目命名规则。 例：retina_sprites.scss HTML文件命名参照项目命名规则。 例：error_report.html Demo vue.min.js vue-router.js jquery.form.js jquery-1.4.2.min.js 变量命名[强制] 变量 使用 Camel命名法。示例： 1var loadingModules = &#123;&#125;; [强制] 常量 使用 全部字母大写，单词间下划线分隔 的命名方式。示例： 1var HTML_ENTITY = &#123;&#125;; [强制] 函数 使用 Camel命名法。示例： 12function stringFormat(source) &#123;&#125; [强制] 函数的 参数 使用 Camel命名法。示例： 12function hear(theBells) &#123;&#125; [强制] 类 使用 Pascal命名法。示例： 12function TextNode(options) &#123;&#125; [强制] 类的 方法 / 属性 使用 Camel命名法。示例： 12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。示例： 123456var TargetState = &#123; READING: 1, READED: 2, APPLIED: 3, READY: 4&#125;; [强制] 命名空间 使用 Camel命名法。示例： 1equipments.heavyWeapons = &#123;&#125;; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。示例： 1234567function XMLParser() &#123;&#125;function insertHTML(element, html) &#123;&#125;var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。示例： 12function Engine(options) &#123;&#125; [建议] 函数名 使用 动宾短语。示例： 12function getStyle(element) &#123;&#125; [建议] boolean 类型的变量使用 is 或 has 开头。示例： 12var isReady = false;var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。示例： 12var loadingData = ajax.get('url');loadingData.then(callback);]]></content>
      <tags>
        <tag>命名规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css规范]]></title>
    <url>%2F2018%2F08%2F24%2Fcss%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[数值与单位 当属性值或颜色参数为 0 – 1 之间的数时，省略小数点前的 0 。 当长度值为 0 时省略单位。 十六进制的颜色属性值使用小写和尽量简写。 样式属性顺序单个样式规则下的属性在书写时，应按功能进行分组，并以 Positioning Model &gt; Box Model &gt; Typographic &gt; Visual 的顺序书写，提高代码的可读性。 如果包含 content 属性，应放在最前面； Positioning Model 布局方式、位置，相关属性包括：position / top / right / bottom / left / z-index / display / float / … Box Model 盒模型，相关属性包括：width / height / padding / margin / border / overflow / … Typographic 文本排版，相关属性包括：font / line-height / text-align / word-wrap / … Visual视觉外观，相关属性包括：color / background / list-style / transform / animation / transition / … 注： Positioning 处在第一位，因为他可以使一个元素脱离正常文本流，并且覆盖盒模型相关的样式。 盒模型紧跟其后，因为他决定了一个组件的大小和位置。 其他属性只在组件内部起作用或者不会对前面两种情况的结果产生影响，所以他们排在后面。 尽量避免使用标签名假设我们有如下 html 结构： 12345678&lt;div class="g-content"&gt; &lt;ul class="g-content-list"&gt; &lt;li class="item" /&gt; &lt;li class="item" /&gt; &lt;li class="item" /&gt; &lt;li class="item" /&gt; &lt;/ul&gt;&lt;/div&gt; 在给最里层的标签命名书写样式的时候，我们有两种选择： 1234567.g-content &#123; .g-content-list &#123; li &#123; ... &#125; &#125;&#125; 或者是 1234567.g-content &#123; .g-content-list &#123; .item &#123; ... &#125; &#125;&#125; 也就是，编译之后生成了下面这两个，到底使用哪个好呢？ .g-content .g-content-list li { } .g-content .g-content-list .item { } 基于 CSS 选择器的解析规则（从右向左），建议使用上述第二种.g-content .g-content-list .item { } ，避免使用通用标签名作为选择器的一环可以提高 CSS 匹配性能。 浏览器的排版引擎解析 CSS 是基于从右向左（right-to-left）的规则，这么做是为了使样式规则能够更快地与渲染树上的节点匹配。]]></content>
      <tags>
        <tag>css</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS为什么用TCP和UDP]]></title>
    <url>%2F2018%2F08%2F09%2FDNS%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8TCP%E5%92%8CUDP%2F</url>
    <content type="text"><![CDATA[TCP与UDP的区别 TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。 UDP—用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。不同于TCP，UDP并不能确保数据的发送和接收顺序。 UDP是一种不可靠的网络协议，但有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。 DNS分别在什么情况下使用UDP和TCPDNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。 在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 注：DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 区域传送时使用TCP 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 为什么既使用TCP又使用UDP​ UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>udp</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dns解析]]></title>
    <url>%2F2018%2F08%2F08%2Fdns%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[用户在浏览器的地址栏中敲入了网站的网址 ，会发生哪些事情呢？ 用户在浏览器的地址栏中敲入了网站的网址 浏览器查找域名的IP地址 找到ip地址后，浏览器给web服务器发送一个HTTP请求 服务器“处理”请求 服务器发回一个HTML响应 浏览器开始显示HTML DNS域名解析过程 当用户在浏览器中输入ke.qq.com并按下回车键后： 第1步，查找浏览器缓存。 浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。 第2步，查找系统缓存。 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。 第3步，查找路由器缓存。 如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。 第4步，查找ISP DNS 缓存。 运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。 第5步，递归搜索。 最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下： 本地 DNS服务器即将该请求转发到互联网上的根域。 根域将所要查询域名中的顶级域的服务器IP地址返回到本地DNS。 本地DNS根据返回的IP地址，再向顶级域发送请求。 com域服务器再将域名中的二级域的IP地址返回给本地DNS。 本地DNS再向二级域发送请求进行查询。 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。 1234&gt; . -&gt; com. -&gt; qq.com. -&gt; ke.qq.com.&gt; // .对应的是根域名服务器，默认情况下所有的网址的最后一位都是.&gt; // 为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上&gt; 注：DNS同时占用UDP和TCP端口53 DNS有关的网络性能优化1、减少DNS查找，避免重定向。浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素： 服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。 浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。 浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。 2、DNS的预解析 可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析 1&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt; 可以使用link标签来强制对DNS做预解析: 1&lt;link rel="dns-prefetch" href="http://ke.qq.com/" /&gt; 当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）。]]></content>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cursor样式]]></title>
    <url>%2F2018%2F08%2F03%2Fcursor%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[cursor样式 值 描述 url 需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。 default 默认光标（通常是一个箭头） auto 默认。浏览器设置的光标。 crosshair 光标呈现为十字线。 pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动。 e-resize 此光标指示矩形框的边缘可被向右（东）移动。 ne-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东）。 nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西）。 n-resize 此光标指示矩形框的边缘可被向上（北）移动。 se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东）。 sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西）。 s-resize 此光标指示矩形框的边缘可被向下移动（南）。 w-resize 此光标指示矩形框的边缘可被向左移动（西）。 text 此光标指示文本。 vertical-text 用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。 wait 此光标指示程序正忙（通常是一只表或沙漏）。 progress 带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。 help 此光标指示可用的帮助（通常是一个问号或一个气球）。 all-scroll 有上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。 col-resize 有左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。 row-resize 有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。 no-drop 带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。 not-allowed 禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;cursor&lt;/title&gt; &lt;style&gt; table,th,td &#123;border: 1px solid #ccc;&#125; thead tr &#123;background-color: #eee;&#125; tbody tr:nth-of-type(even) &#123;background-color: #f8f8f8;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table cellpadding="6" cellspacing="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;值&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr style="cursor: url;"&gt; &lt;td&gt;url&lt;/td&gt; &lt;td&gt;需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: default;"&gt; &lt;td&gt;default&lt;/td&gt; &lt;td&gt;默认光标（通常是一个箭头）&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: auto;"&gt; &lt;td&gt;auto&lt;/td&gt; &lt;td&gt;默认。浏览器设置的光标。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: crosshair;"&gt; &lt;td&gt;crosshair&lt;/td&gt; &lt;td&gt;光标呈现为十字线。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: pointer;"&gt; &lt;td&gt;pointer&lt;/td&gt; &lt;td&gt;光标呈现为指示链接的指针（一只手）&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: move;"&gt; &lt;td&gt;move&lt;/td&gt; &lt;td&gt;此光标指示某对象可被移动。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: e-resize;"&gt; &lt;td&gt;e-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向右（东）移动。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: ne-resize;"&gt; &lt;td&gt;ne-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向上及向右移动（北/东）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: nw-resize;"&gt; &lt;td&gt;nw-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向上及向左移动（北/西）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: n-resize;"&gt; &lt;td&gt;n-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向上（北）移动。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: se-resize;"&gt; &lt;td&gt;se-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向下及向右移动（南/东）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: sw-resize;"&gt; &lt;td&gt;sw-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向下及向左移动（南/西）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: s-resize;"&gt; &lt;td&gt;s-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向下移动（南）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: w-resize;"&gt; &lt;td&gt;w-resize&lt;/td&gt; &lt;td&gt;此光标指示矩形框的边缘可被向左移动（西）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: text;"&gt; &lt;td&gt;text&lt;/td&gt; &lt;td&gt;此光标指示文本。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: vertical-text;"&gt; &lt;td&gt;vertical-text&lt;/td&gt; &lt;td&gt;用于标示可编辑的垂直文本的光标。通常是大写字母 I 旋转90度的形状。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: wait;"&gt; &lt;td&gt;wait&lt;/td&gt; &lt;td&gt;此光标指示程序正忙（通常是一只表或沙漏）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: progress;"&gt; &lt;td&gt;progress&lt;/td&gt; &lt;td&gt;带有沙漏标记的箭头光标。用于标示一个进程正在后台运行。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: help;"&gt; &lt;td&gt;help&lt;/td&gt; &lt;td&gt;此光标指示可用的帮助（通常是一个问号或一个气球）。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: all-scroll;"&gt; &lt;td&gt;all-scroll&lt;/td&gt; &lt;td&gt;有上下左右四个箭头，中间有一个圆点的光标。用于标示页面可以向上下左右任何方向滚动。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: col-resize;"&gt; &lt;td&gt;col-resize&lt;/td&gt; &lt;td&gt;有左右两个箭头，中间由竖线分隔开的光标。用于标示项目或标题栏可以被水平改变尺寸。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: row-resize;"&gt; &lt;td&gt;row-resize&lt;/td&gt; &lt;td&gt;有上下两个箭头，中间由横线分隔开的光标。用于标示项目或标题栏可以被垂直改变尺寸。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: no-drop;"&gt; &lt;td&gt;no-drop&lt;/td&gt; &lt;td&gt;带有一个被斜线贯穿的圆圈的手形光标。用于标示被拖起的对象不允许在光标的当前位置被放下。&lt;/td&gt; &lt;/tr&gt; &lt;tr style="cursor: not-allowed;"&gt; &lt;td&gt;not-allowed&lt;/td&gt; &lt;td&gt;禁止标记(一个被斜线贯穿的圆圈)光标。用于标示请求的操作不允许被执行。&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>cursor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[层叠上下文-块格式化上下文-包含块]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87-%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87-%E5%8C%85%E5%90%AB%E5%9D%97%2F</url>
    <content type="text"><![CDATA[层叠上下文(the stacking context)职责：处理元素层叠的顺序问题 父层叠上下文：拥有层叠上下文的最近祖父元素，与position无关。 块格式化上下文(formatting-context)职责：决定了其子元素将如何定位，以及和其他元素的关系 包含块(containing-block)职责：由定位(position)决定元素大小与位置 注： 事件的捕获与冒泡仍是根据祖先元素传递，与包含块无关，与position无关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; body &#123; background-color: tan; height: 100vh; margin: 0; &#125; .outer &#123; position: absolute; background-color: #8980fc; height: 400px; margin: 30px; width: 50%; z-index: 1; &#125; .inner-fixed &#123; position: fixed; left: 0; top: 27%; width: 100%; background-color: palevioletred; padding: 30px; box-sizing: border-box; z-index: -1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 检测事件流与position属性的关系 function innerClick()&#123; let e = window.event; console.log('inner',e.stopPropagation); &#125; function outerClick()&#123; let e = window.event; console.log('outer',e); &#125; &lt;/script&gt; &lt;div onclick="outerClick(this)" class="outer"&gt; &lt;div onclick="innerClick(this)" class="inner-fixed"&gt;这是一个绝对定位了的标题&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; .inner-fixed元素的父层叠上下文是.outer，父包含块是body。 .inner-fixed元素的大小和位置由它的父包含块（body）决定。 .inner-fixed元素在body中的层叠顺序跟随父层叠上下文（.outer）。 12345678.outer &#123; position: absolute; background-color: #8980fc; height: 400px; margin: 30px; width: 50%; /*z-index: 1;*/&#125; .inner-fixed元素的父层叠上下文是body，父包含块是body .outer元素此时为一个没有层叠上下文的普通元素 .inner-fixed元素和.outer元素出于同一个层叠上下文（body）中 .inner-fixed元素的层叠顺序要比.outer元素的小]]></content>
      <tags>
        <tag>stacking-context</tag>
        <tag>containing-block</tag>
        <tag>formatting-context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[offsetParent-offsetTop-offsetHeight]]></title>
    <url>%2F2018%2F07%2F25%2FoffsetParent-offsetTop-offsetHeight%2F</url>
    <content type="text"><![CDATA[offsetParentHTMLElement.offsetParent 是一个只读属性，返回一个指向最近的包含该元素的定位元素。 如果没有定位的元素，则 offsetParent 为最近的 table, table cell 或根元素（标准模式下为 html；quirks 模式下为 body） 当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。 offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的 12parentObj = element.offsetParent;//parentObj 是一个对象引用，当前元素相对于该对象偏移（offset）。 兼容性: 在 Webkit 中，如果元素为隐藏的（该元素或其祖先元素的 style.display 为 “none”），或者该元素的 style.position 被设为 “fixed”，则该属性返回 null。 在 IE 9 中，如果该元素的 style.position 被设置为 “fixed”，则该属性返回 null。（display:none 无影响。） offsetTopHTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。 123456var d = document.getElementById("div1");var topPos = d.offsetTop; if (topPos &gt; 10) &#123; // div1 距离它的 offsetParent 元素的顶部的距离大于 10 px&#125; offsetHeightHTMLElement.offsetHeight 是一个只读属性，它返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 通常，元素的offsetHeight是一种元素CSS高度的衡量标准，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包含:before或:after等伪类元素的高度。 对于文档的body对象，它包括代替元素的CSS高度线性总含量高。浮动元素的向下延伸内容高度是被忽略的。 1这个属性值会被四舍五入为整数值，如果你需要一个浮点数值，请用 element.getBoundingClientRect(). clientHeight这个属性是只读属性，对于没有定义CSS或者内联布局盒子的元素为0，否则，它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。 clientTop一个元素上边框的宽度（以像素表示），当没有指定边框厚底时，一般为0。]]></content>
      <tags>
        <tag>offsetParent</tag>
        <tag>offsetTop</tag>
        <tag>offsetHeight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击取词-Selection和Range]]></title>
    <url>%2F2018%2F07%2F21%2F%E7%82%B9%E5%87%BB%E5%8F%96%E8%AF%8D-Selection%E5%92%8CRange%2F</url>
    <content type="text"><![CDATA[原文 一、对象Selection 对象表示用户选择的文本范围或插入符号的当前位置。它代表页面中的文本选区，可能横跨多个元素。文本选区由用户拖拽鼠标经过文字而产生。要获取用于检查或修改的Selection对象，请调用 window.getSelection()。 Range，表示包含节点和部分文本节点的文档片段，可以通过 Selection 对象的 getRangeAt 方法取得，也可以通过 Document 对象的 createRange 方法创建。 二、应用在我们日常前端开发中，可能会遇到这样的场景，实现划词翻译、点击取词翻译、编辑器中的复制、粘贴等需求，下面我们通过对这两种需求场景来介绍 Selection 对象 和 Range 对象在实际项目中的应用。 实现点击取词并翻译实现基本思路，点击时获取 Selection 对象，并创建选取，通过 Range 的 setStart 和 setEnd 方法扩大文档片段的范围，以空格或者特殊符号为临界状态，终止循环。 1.方法一实现相关逻辑如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071if (window.getSelection) &#123; let selection, range, node, start, end, text, rect, isFun, isText; // 回调函数判断 isFun = !!window.JSInvoker &amp;&amp; typeof window.JSInvoker.toggleWordTooltip === 'function'; // 文本判断 isText = function (text) &#123; return text &amp;&amp; /^[a-zA-Z]+$/.test(text); &#125; // 如果 tooltip 存在，需要先关闭 isFun &amp;&amp; window.JSInvoker.toggleWordTooltip(false); selection = window.getSelection(); range = selection.getRangeAt(0); node = selection.anchorNode; start = range.startOffset; end = range.endOffset; text = range.toString(); // &lt;&lt;&lt;向前判断非空格边界 while (!/^\s+/.test(text)) &#123; if (start === 0) &#123; range.setStart(node, start); text = range.toString(); break; &#125; else &#123; start -= 1; range.setStart(node, start); text = range.toString(); &#125; if (!isText(text)) &#123; start += 1; range.setStart(node, start); text = range.toString(); break; &#125; &#125; // &gt;&gt;&gt;向后判断非空格边界 while (!/\s+$/.test(text)) &#123; if (end === node.length) &#123; range.setEnd(node, end); text = range.toString(); break; &#125; else &#123; end += 1; range.setEnd(node, end); text = range.toString(); &#125; if (!isText(text)) &#123; end -= 1; range.setEnd(node, end); text = range.toString(); break; &#125; &#125; // 获取当前文档片段位置信息 rect = range.getBoundingClientRect(); text = text.trim(); if (isText(text) &amp;&amp; isFun &amp;&amp; rect) &#123; // 打开 tooltip window.JSInvoker.toggleWordTooltip(true, text, rect.x, rect.y, rect.width, rect.height); &#125; else &#123; alert(`Text: $&#123;text&#125;, isFun: $&#123;isFun&#125;, Rect: $&#123;JSON.stringify(rect)&#125;`); &#125;&#125; else &#123; // todo&#125; 2.方法二实现方案比较简单，实现代码逻辑如下：123456789101112131415161718if (window.getSelection) &#123; let selection, start, end, word; selection = window.getSelection(); selection.modify('extend', 'backward', 'word'); start = selection.toString(); selection.modify('extend', 'forward', 'word'); end = selection.toString(); selection.modify('move', 'forward', 'character'); word = start + end; alert(`Selected Text: $&#123;word&#125;`);&#125; else &#123; // todo&#125; 实现划词翻译1.获取划词文本123456789101112131415function getSelected () &#123; let selection; if (window.getSelection) &#123; // webkit and mozilla and IE9 + selection = window.getSelection(); &#125; else if (document.getSelection) &#123; // 同上 selection = document.getSelection(); &#125; else if (document.selection) &#123; // IE selection = document.selection.createRange().text; &#125; return selection.toString().trim();&#125; 2.清空选中文本123456789function removeSelection () &#123; if (window.getSelection) &#123; window.getSelection().removeAllRanges(); &#125; else if (document.getSelection &amp;&amp; document.getSelection.empty) &#123; document.getSelection().empty(); &#125; else if (document.selection &amp;&amp; document.selection.empty) &#123; document.selection.empty(); &#125;&#125;]]></content>
      <tags>
        <tag>Selection</tag>
        <tag>Range</tag>
        <tag>点击取词</tag>
        <tag>划词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[contenteditable与user-modify]]></title>
    <url>%2F2018%2F07%2F21%2Fcontenteditable%2F</url>
    <content type="text"><![CDATA[元素可编辑1-webkit-user-modify: read-only | read-write | read-write-plaintext-only 123456contenteditable=""contenteditable="events"contenteditable="caret"contenteditable="plaintext-only"contenteditable="true"contenteditable="false" read-only：只读 read-write ：读写，可以输入富文本 read-write-plaintext-only：读写，只能输入纯文本 注：contenteditable中默认可以输入(粘贴)富文本]]></content>
      <tags>
        <tag>contenteditable</tag>
        <tag>user-modify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版权格式]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%89%88%E6%9D%83%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[从法律角度看，版权保护是随着作品的问世的即刻就得到版权的保护的，并不是必须要声明。但是作为惯例，这一小行文字还是有很好加强意识，提醒浏览者，所观看的内容是受到版权保护的。 正确的格式应该是： 1Copyright [dates] by [author/owner] © 通常可以代替Copyright。 All Rights Reserved 在某些国家曾经是必须的，但是现在在大多数国家，都不是法律上必须有的字样。 参见下面几个正确的格式： ©1995-2004 Macromedia, Inc. All rights reserved. ©2004 Microsoft Corporation. All rights reserved. Copyright © 2004 Adobe Systems Incorporated. All rights reserved. ©1995-2004 Eric A. and Kathryn S. Meyer. All Rights Reserved.]]></content>
      <tags>
        <tag>版权格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个简单的JavaScript模板引擎]]></title>
    <url>%2F2018%2F07%2F05%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84JavaScript%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[模板12345&lt;ul&gt; &lt;% for ( var i = 0; i &lt; users.length; i++ ) &#123; %&gt; &lt;li&gt;&lt;a href="&lt;%=users[i].url%&gt;"&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt; JS数据12345678910111213141516const arr = [ &#123; "name": "google", "url": "https://www.google.com" &#125;, &#123; "name": "baidu", "url": "https://www.baidu.com/" &#125;, &#123; "name": "凯斯", "url": "https://www.zhihu.com/people/Uncle-Keith/activities" &#125;]const html = tmpl('list', arr)console.log(html) 打印出的结果为12345678"&lt;ul&gt; &lt;li&gt;&lt;a href="https://www.google.com"&gt;google&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.baidu.com/"&gt;baidu&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="https://www.zhihu.com/people/Uncle-Keith/activities"&gt;凯斯&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;" 从以上的代码可以看出，将结构和数据传入tmpl函数中，就能实现拼接。而tmpl正是我们所说的模板引擎（函数）。接下来我们就来实现一下这个函数。 实现模板引擎函数实现的本质，就是将模板中HTML结构与JavaScript语句、变量分离，通过Function构造函数 + apply(call)动态生成具有数据性的HTML代码。而如果要考虑性能的话，可以将模板进行缓存处理。 实现一个模板引擎函数，大致有以下步骤： 模板获取 模板中HTML结构与JavaScript语句、变量分离 Function + apply(call)动态生成JavaScript代码 模板缓存 模板获取 一般情况下，我们会把模板写在script标签中，赋予id属性，标识模板的唯一性；赋予type=’text/html’属性，标识其MIME类型为HTML，如下 123456789101112131415&lt;script type="text/html" id="template"&gt; &lt;ul&gt; &lt;% if (obj.show) &#123; %&gt; &lt;% for (var i = 0; i &lt; obj.users.length; i++) &#123; %&gt; &lt;li&gt; &lt;a href="&lt;%= obj.users[i].url %&gt;"&gt; &lt;%= obj.users[i].name %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125; else &#123; %&gt; &lt;p&gt;不展示列表&lt;/p&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;/script&gt; 在模板引擎中，选用&lt;% xxx %&gt;标识JavaScript语句，主要用于流程控制，无输出；&lt;%= xxx %&gt;标识JavaScript变量，用于将数据输出到模板；其余部分都为HTML代码。（与EJS类似）。 注：如果是模板放在一个独立的文件，可以先获取&lt;script&gt;的scr属性，再ajax请求获取文件内容。 HTML结构与JavaScript语句、变量分离 主要是通过replace函数替换实现的。说明一下主要流程： 创建数组arr，再拼接字符串arr.push(‘ 遇到换行回车，替换为空字符串 遇到&lt;%时，替换为’); 遇到&gt;%时，替换为arr.push(‘ 遇到&lt;%= xxx %&gt;，结合第3、4步，替换为’); arr.push(xxx); arr.push(‘ 最后拼接字符串’); return p.join(‘’); 在代码中，需要将第5步写在2、3步骤前面，因为有更高的优先级，否则会匹配出错。如下 1234567891011121314151617let tpl = ''const tmpl = (str, data) =&gt; &#123; // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %, 等）；如果是id，则需要通过getElementById获取 if (!/[\s\W]/g.test(str)) &#123; tpl = document.getElementById(str).innerHTML &#125; else &#123; tpl = str &#125; let result = `let p = []; p.push('` result += `$&#123; tpl.replace(/[\r\n\t]/g, '') .replace(/&lt;%=\s*([^%&gt;]+?)\s*%&gt;/g, "'); p.push($1); p.push('") .replace(/&lt;%/g, "');") .replace(/%&gt;/g, "p.push('") &#125;` result += "'); return p.join('');" &#125; 如果模板中出现了单引号，那会影响整个函数的执行的。还有一点，如果出现了 \ 反引号，会将单引号转义了。所以需要对单引号和反引号做一下优化处理。 模板中遇到 \ 反引号，需要转义 遇到 ‘ 单引号，需要将其转义 转换为代码，即为 12str.replace(/\\/g, '\\\\') .replace(/'/g, "\\'") 12345678910111213141516171819let tpl = ''const tmpl = (str, data) =&gt; &#123; // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %, 等）；如果是id，则需要通过getElementById获取 if (!/[\s\W]/g.test(str)) &#123; tpl = document.getElementById(str).innerHTML &#125; else &#123; tpl = str &#125; let result = `let p = []; p.push('` result += `$&#123; tpl.replace(/[\r\n\t]/g, '') .replace(/\\/g, '\\\\') .replace(/'/g, "\\'") .replace(/&lt;%=\s*([^%&gt;]+?)\s*%&gt;/g, "'); p.push($1); p.push('") .replace(/&lt;%/g, "');") .replace(/%&gt;/g, "p.push('") &#125;` result += "'); return p.join('');" &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="results"&gt;&lt;/div&gt; &lt;script type="text/html" id="user_tmpl"&gt; &lt;ul&gt; &lt;% for ( var i = 0; i &lt; users.length; i++ ) &#123; %&gt; &lt;li&gt;&lt;a href="&lt;%=users[i].url%&gt;"&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; var results = document.getElementById("results"); var users=[ &#123;"name":"Byron", "url":"http://localhost"&#125;, &#123;"name":"Casper", "url":"http://localhost"&#125;, &#123;"name":"Frank", "url":"http://localhost"&#125; ]; function tmpl(id,data)&#123; var html=document.getElementById(id).innerHTML; var result="var p=[];with(obj)&#123;p.push('" +html.replace(/[\r\n\t]/g," ") .replace(/&lt;%=(.*?)%&gt;/g,"');p.push($1);p.push('") .replace(/&lt;%/g,"');") .replace(/%&gt;/g,"p.push('") +"');&#125;return p.join('');"; var fn=new Function("obj",result); return fn(data); &#125; results.innerHTML = tmpl("user_tmpl", users); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript运行机制，从浏览器多进程到JS单线程]]></title>
    <url>%2F2018%2F07%2F04%2FjavaScript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0JS%E5%8D%95%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[区分进程和线程线程和进程区分不清，先看看下面这个形象的比喻： 123456789- 进程是一个工厂，工厂有它的独立资源- 工厂之间相互独立- 线程是工厂中的工人，多个工人协作完成任务- 工厂内有一个或多个工人- 工人之间共享空间 再完善完善概念： 123456789- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 然后再巩固下： windows中，打开任务管理器。在后台进程列表中，可以看到每个进程的内存资源信息以及cpu占有率。 所以，应该更容易理解了：进程是cpu资源分配的最小单位（系统会给它分配内存） 最后，再用较为官方的术语描述一遍： 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位） tips 不同进程之间也可以通信，不过代价较大 一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。 浏览器是多进程的理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解） 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 关于以上几点的验证，请再第一张图： 图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器都包含哪些进程？知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程） Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 页面渲染，脚本执行，事件处理等 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图 另外，可以通过Chrome的更多工具 -&gt; 任务管理器自行验证 浏览器多进程的优势相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。 当然，内存等资源消耗也会更大，有点空间换时间的意思。 重点是浏览器内核（渲染进程）那么，对于普通的前端操作来说，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程请牢记，浏览器的渲染进程是多线程的。 终于到了线程这个概念了😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）： GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识， 可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧： Browser进程和Renderer进程的通信过程看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。 如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多) Browser进程收到用户请求，先获取页面内容，将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载并渲染网页，可能需要Browser进程获取资源和需要GPU进程来帮助渲染 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来 这里绘一张简单的图：（很简化） 看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错 梳理浏览器内核中线程之间的关系GUI渲染线程与JS引擎线程互斥由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。 MDN的官方解释是： 1234567Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误 这样理解下： 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。 WebWorker与SharedWorker既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本） 为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文） 12345- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程- 浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 onload 属性是资源加载完成还是渲染完成?123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt;&lt;/head&gt;&lt;style&gt; .currentImg &#123; width: 100px; height: 100px; &#125;&lt;/style&gt;&lt;script&gt; alert('first');&lt;/script&gt;&lt;body onload="load()"&gt; &lt;img class="currentImg" onload="alert('img1')" src="0.jpg" /&gt; &lt;img class="currentImg" onload="alert('img2')" src="1.jpg" /&gt;&lt;/body&gt;&lt;script&gt; function load() &#123; alert('last') &#125;&lt;/script&gt;&lt;/html&gt; 原理：利用alert阻断浏览器渲染 结果： 输出依次是first、img2、img、last, 竟然先加载了第二个图片，说明是并行加载资源的 浏览器弹屏img2、img1时图片并未完全渲染，说明onload调用时机是资源加载而非资源渲染结束后 去掉两个&lt;img&gt;中的onload属性发现弹屏last时图片尚未完全渲染，即window.onload表示资源加载而非渲染结束后调用 将&lt;img&gt;中的URL改成错误的URL发现window.onload同样调用了，但此时发现浏览器控制台已经输出了图片加载失败的error，而该&lt;img&gt;中的onload函数未调用 将两个&lt;img&gt;中的URL都改成错误的URL，发现window.onload同样调用了，说明其表示的是资源加载完了，至于成功与否无所谓 load事件与DOMContentLoaded事件的先后你能分清楚load事件与DOMContentLoaded事件的先后么？很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 所以，顺序是：DOMContentLoaded -&gt; load css加载是否会阻塞dom树渲染？这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 普通图层和复合图层渲染步骤中就提到了composite概念。 可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 可以Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息 如下图。可以验证上述的说法 如何变成复合图层（硬件加速）将该元素变成一个复合图层，就是传说中的硬件加速技术 最常用的方式：translate3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） &lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;等元素 其它，譬如以前的flash插件 absolute和硬件加速的区别可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。 所以，就算absolute中信息改变时不会改变普通文档流中render树， 但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 复合图层的作用？一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。 硬件加速时请使用index使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染 具体的原理时这样的： webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低， 那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的）， 会默认变为复合层渲染，如果处理不当会极大的影响性能 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）： web.jobbole.com/83575/ 从Event Loop谈JS的运行机制到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。 注意，这里不谈可执行上下文，VO，scop chain等概念（这些完全可以整理成另一篇文章了），这里主要是结合Event Loop来谈JS代码是如何执行的。 读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念： JS引擎线程 事件触发线程 定时触发器线程 然后再理解一个概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看图： 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码， 所以自然有误差。 事件循环机制进一步补充这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《Help, I’m stuck in an event-loop》） 上图大致描述就是： 主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 单独说说定时器上述事件循环机制的核心是：JS引擎线程和事件触发线程 但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 譬如: 123setTimeout(function()&#123; console.log('hello!');&#125;, 1000); 这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行 12345setTimeout(function()&#123; console.log('hello!');&#125;, 0);console.log('begin'); 这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定) 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列） setTimeout而不是setInterval用setTimeout模拟定期计时和直接用setInterval是有区别的。 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差 （误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。 就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。 事件循环进阶：macrotask与microtask这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下）， 强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下： jakearchibald.com/2015/tasks-… 上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题： 12345678910111213console.log(&apos;script start&apos;);setTimeout(function() &#123; console.log(&apos;setTimeout&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;promise1&apos;);&#125;).then(function() &#123; console.log(&apos;promise2&apos;);&#125;);console.log(&apos;script end&apos;); 嗯哼，它的正确执行顺序是这样子的： 12345script startscript endpromise1promise2setTimeout 为什么呢？因为Promise里有了一个一个新的概念：microtask。或者，进一步，JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task 它们的定义？区别？简单点可以按如下理解： macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务 也就是说，在当前task任务后，下一个task之前，在渲染之前 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别很么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 参考：segmentfault.com/q/101000001… 再根据线程来理解下： macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 （这点由自己理解+推测得出，因为它是在主线程下无缝执行的） 所以，总结下运行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 如图： 另外，请注意下Promise的polyfill与官方版本的区别： 官方版本中，是标准的microtask形式 polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式 请特别注意这两点区别 注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准） 使用MutationObserver实现microtaskMutationObserver可以用来实现microtask （它属于microtask，优先级小于Promise， 一般是Promise不支持时才会这样做） 它是HTML5中的新特性，作用是：监听一个DOM变动， 当DOM对象树发生任何变动时，Mutation Observer会得到通知 像以前的Vue源码中就是利用它来模拟nextTick的， 具体原理是，创建一个TextNode并监听内容变化， 然后要nextTick的时候去改一下这个节点的文本内容， 如下：（Vue的源码，未修改） 1234567891011var counter = 1var observer = new MutationObserver(nextTickHandler)var textNode = document.createTextNode(String(counter))observer.observe(textNode, &#123; characterData: true&#125;)timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter)&#125; 对应Vue源码链接 不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）。 MessageChannel属于宏任务，优先级是：MessageChannel-&gt;setTimeout， 所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。 这里不展开，可以看下juejin.im/post/5a1af8…]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>多进程</tag>
        <tag>JS单线程</tag>
        <tag>运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript易忽略语法集]]></title>
    <url>%2F2018%2F07%2F04%2FjavaScript%E6%98%93%E5%BF%BD%E7%95%A5%E8%AF%AD%E6%B3%95%E9%9B%86%2F</url>
    <content type="text"><![CDATA[箭头函数与this箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象 。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 箭头函数转成 ES5 的代码如下 1234567891011121314// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 顶层对象的属性与全局变量顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。 12345window.a = 1;a // 1a = 2;window.a // 2 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined for与let1234567891011121314151617181920212223// es6var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6// 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量//babel es5"use strict";var a = [];var _loop = function _loop(i) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;;for (var i = 0; i &lt; 10; i++) &#123; _loop(i);&#125;a[6](); // 6 for循环父作用域1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 设置循环变量的那部分是一个父作用域 循环体内部是一个单独的子作用域 数组1、性质 javaScript将指定的数字索引值转换成字符串，然后将其作为属性名来使用（索引范围：0~(2^32)-2） 所有的数组都是对象，可以为其创建任意名字的属性。 如果使用了负数或非整数，数值转换为字符串，字符串作为属性名来用。 如果使用了非负整数，数值转换为字符串，字符串当做数组索引，而非对象属性。 2、特殊行为 如果为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1 设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或者等于n的元素将从中删除。 函数1、调用方式 作为函数 作为方法 作为构造函数 通过call()和apply()方法间接调用 2、特性 一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。而定义函数表达式时并没有声明一个变量。 如果函数表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称。 如果嵌套函数作为函数调用，其this值不是全局对象就是undefined。]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅虎前端优化的35条军规]]></title>
    <url>%2F2018%2F07%2F03%2F%E9%9B%85%E8%99%8E%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%9A%8435%E6%9D%A1%E5%86%9B%E8%A7%84%2F</url>
    <content type="text"><![CDATA[内容部分1.尽量减少HTTP请求数页面大部分的响应时间都在下载页面上的各种组件：图片，样式表，脚本等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。 合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。 CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中。 行内图片（Base64编码）用data: URL模式来把图片放在（缓存的）样式表中。 2.减少DNS查找DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。 DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表等等组件中的主机名，减少不同的主机名就可以减少DNS查找。 HTTP客户端一般对同一个服务器的并发连接个数都是有限制的 。减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，削减了避免DNS查找的响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 3.避免重定向有一种常见的极其浪费资源的重定向，就是URL尾部缺少一个斜线。 当Web服务器接收到对末尾不含斜杠的url请求时（www.abc.com/home/efg），服务器会搜索/home目录下有没有名为efg的文件，如果没有就把efg当做目录处理，然后返回efg目录下的默认首页，造成一次不必要的握手 。当Web服务器接收到的是末尾带斜杠的请求时就会直接当做目录处理。 4.Ajax可缓存 必须是GET请求 必须在response中发送正确的HTTP头信息：Expires 5.延迟加载组件 6.预加载组件预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。 通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。 7.减少DOM元素的数量一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。 8.跨域分离组件分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。 9.尽量少用iframe用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。 &lt;iframe&gt;的优点： 引入缓慢的第三方内容，比如标志和广告 安全沙箱 并行下载脚本 &lt;iframe&gt;的缺点： 代价高昂，即使是空白的iframe 阻塞页面加载 非语义 10.杜绝404HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。 css部分11.避免使用CSS表达式用CSS表达式动态设置CSS属性，是一种强大又危险的方式。例如，可以用CSS表达式把背景颜色设置成按小时交替的： 1background-color: expression( (new Date()).getHours()%2 ? "#B8D4FF" : "#F08A00" ); 12.选择&lt;link&gt;舍弃@import页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载 。 13.避免使用滤镜IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。 最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 14.把样式表放在顶部把样式表放在head里能让页面逐步渲染 。 js部分15.去除重复脚本除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。 避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签： 1&lt;script type="text/javascript" src="menu_1.0.17.js"&gt;&lt;/script&gt; 16.尽量减少DOM访问用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该： 缓存已访问过的元素的索引 先“离线”更新节点，再把它们添到DOM树上 避免用JavaScript修复布局问题 17.用智能的事件处理器太多频繁执行的事件处理器被添加到了DOM树的不同元素上会导致页面不灵敏，这就是推荐使用事件委托的原因。 18.把脚本放在底部脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。 javascript, css19.把JavaScript和CSS放到外面用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。 20.压缩JavaScript和CSS压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。 两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。 图片21.优化图片尝试把GIF格式转换成PNG格式 22.优化CSS Sprite 在Sprite图片中横向排列一般都比纵向排列的最终文件小 组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式 “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 23.不要用HTML缩放图片不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要 1&lt;img width="100" height="100" src="mycat.jpg" alt="My Cat" /&gt; 那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 24.用小的可缓存的favicon.icofavicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。 所以为了缓解favicon.ico的缺点，应该确保： 足够小，最好在1K以下 设置合适的有效期HTTP头，把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 cookie25.给Cookie减肥保证cookie尽可能的小，以最小化对用户响应时间的影响。 清除不必要的cookie 保证cookie尽可能小，以最小化对用户响应时间的影响 注意给cookie设置合适的域级别，以免影响其它子域 设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间 26.把组件放在不含cookie的域下当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。 如果域名是www.example.org，可以把静态组件部署到static.example.org。 移动端27.保证所有组件都小于25K这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 28.把组件打包到一个复合文档里把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 服务器29.Gzip组件前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。 从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。 1Accept-Encoding: gzip, deflate 如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。 1Content-Encoding: gzip 尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。 30.避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现： straight HTML 1&lt;img src=””&gt; JavaScript 12var img = new Image();img.src = ''; 这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。 31.配置ETags实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag： 1234HTTP/1.1 200 OK Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT ETag: "10c24bc-4ab-457e1c1f" Content-Length: 12195 然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。 12345GET /i/yahoo.gif HTTP/1.1 Host: us.yimg.com If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT If-None-Match: "10c24bc-4ab-457e1c1f" HTTP/1.1 304 Not Modified 32.对Ajax用GET请求Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，再发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。 POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。 33.尽早清空缓冲区 34.使用CDN（内容分发网络） 35.添上Expires或者Cache-Control HTTP头]]></content>
      <tags>
        <tag>性能优化</tag>
        <tag>35条军规</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拦截全局ajax请求与Ajax-hook源码分析]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%8B%A6%E6%88%AA%E5%85%A8%E5%B1%80ajax%E8%AF%B7%E6%B1%82%E4%B8%8EAjax-hook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、ajax-hook插件原理图 用法 引入文件 Using cdn 1&lt;script src="https://unpkg.com/ajax-hook/dist/ajaxhook.min.js"&gt;&lt;/script&gt; Using npm 1npm install ajax-hook 注册回调函数 1234567891011121314151617hookAjax(&#123; //hook callbacks onreadystatechange:function(xhr)&#123; console.log("onreadystatechange called: %O",xhr) &#125;, onload:function(xhr)&#123; console.log("onload called: %O",xhr) &#125;, //hook function open:function(arg,xhr)&#123; console.log("open called: method:%s,url:%s,async:%s",arg[0],arg[1],arg[2]) &#125;&#125;)// NPM// const ah=require("ajax-hook")// ah.hookAjax(&#123;...&#125;) 异步请求 1234// get current page source code $.get().done(function(d)&#123; console.log(d.substr(0,30)+"...")&#125;) 结果 12345&gt; open called: method:GET,url:http://localhost:63342/Ajax-hook/demo.html,async:true&gt; onload called: XMLHttpRequest&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head l... 二、源码12// index.jsrequire("./src/ajaxhook")(module.exports) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// /src/ajaxhook.js/* * author: wendu * email: 824783146@qq.com * source code: https://github.com/wendux/Ajax-hook **/// ob是index.js传入的module.exportsmodule.exports=function (ob) &#123; ob.hookAjax = function (funs) &#123; window._ahrealxhr = window._ahrealxhr || XMLHttpRequest XMLHttpRequest = function () &#123; // this是new XMLHttpRequest()返回的对象 this.xhr = new window._ahrealxhr; // 复制this.xhr的属性到this对象 for (var attr in this.xhr) &#123; var type = ""; try &#123; type = typeof this.xhr[attr] &#125; catch (e) &#123;&#125; if (type === "function") &#123; // hookfun为函数调用，this指向window（非严格模式） this[attr] = hookfun(attr); &#125; else &#123; Object.defineProperty(this, attr, &#123; get: getFactory(attr), set: setFactory(attr) &#125;) &#125; &#125; &#125; function getFactory(attr) &#123; return function () &#123; return this.hasOwnProperty(attr + "_")?this[attr + "_"]:this.xhr[attr]; &#125; &#125; function setFactory(attr) &#123; return function (f) &#123; var xhr = this.xhr; var that = this; if (attr.indexOf("on") != 0) &#123; this[attr + "_"] = f; return; &#125; if (funs[attr]) &#123; xhr[attr] = function () &#123; funs[attr](that) || f.apply(xhr, arguments); &#125; &#125; else &#123; xhr[attr] = f; &#125; &#125; &#125; function hookfun(fun) &#123; // console.log(this) // this指向hookfun调用者，此处为window return function () &#123; var args = [].slice.call(arguments) // 函数方法是否在注册回调函数的列表中 if (funs[fun] &amp;&amp; funs[fun].call(this, args, this.xhr)) &#123; return; &#125; // 匿名函数的调用者为new XMLHttpRequest()对象 return this.xhr[fun].apply(this.xhr, args); &#125; &#125; return window._ahrealxhr; &#125; // 恢复XMLHttpRequest对象 ob.unHookAjax = function () &#123; if (window._ahrealxhr) XMLHttpRequest = window._ahrealxhr; window._ahrealxhr = undefined; &#125; //for typescript ob.default=ob;&#125;]]></content>
      <tags>
        <tag>ajax</tag>
        <tag>hook</tag>
        <tag>拦截请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F2018%2F06%2F28%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、缓存类型 1、缓存类型分为强缓存和协商缓存 强缓存：在用户请求资源时，如果命中强缓存，则不向服务器请求，而直接从本地获取资源。我们可以看到200状态码，并提示from disk cache或from memory cache。 协商缓存： 在用户请求资源时，浏览器直接则向服务器发送请求，服务器根据 request header 来判断是否命中协商缓存，如果命中，则返回304和新的response header，使用本地资源；否则，返回新的资源。 2、区别 共同点：两者命中后都是从本地读取资源。 不同点： 强缓存很强势，是没有向服务器发出请求的； 而协商缓存必须要向服务器发一个请求来协商。 二、强缓存header强缓存是利用http的响应头中的Expires字段和Cache-Control两个字段来控制，用来表示使用缓存的有效时间。 1、Expires Expires是http1.0规范的，表示缓存的过期时间。 如某个资源的response heade中的字段： Expires: Fri, 18 Aug 2017 07:57:17 GMT。 表示当浏览器再次加载这个资源时，如果时间没有超过，就命中强缓存，使用内存中缓存的资源。 之所以浏览器在再次加载时可以判断出时间是否超过，是因为浏览器在缓存资源时，不仅缓存了资源，还缓存了response header相关的内容，比如这里Expires字段。 缺点：由于不能保证服务器和用户端的绝对时间保持一致，所以缓存有时可能会出现混乱的情况， 在HTTP1.1版本中开始使用Cache-Control的方法进行缓存。 2、Cache-Cntrol Cache-Control是http1.1规范的，同样表示缓存的过期时间。 其中的max-age是作为判断是否过期的主要判据，它是一个相对时间，单位为s。 如知乎上的某一张图片的response header中的字段：cache-control: public, max-age=31536000。 public代表了这张图片是可以被任何用户缓存的，包括代理服务器等； 而max-age是表示在31536000s（一年）内，如果再次请求就使用本地资源。Cache-Control除了max-age的使用之外，还有几个比较重要的字段： no-cache： 不优先使用本地缓存，而是使用协商缓存。注意： 这里并不是说一定不适用本地缓存的资源，而是需要先协商一下，如果命中，还是会使用本地缓存的。 no-store：一定不使用本地缓存，每次用户请求资源，都会下载得到服务器发来的最新的资源。 public：资源可以被任何用户缓存，包括所有普通用户和代理服务器。 private：只能被当前的特定用户缓存，其他用户无法缓存。 一般是说代理服务器不能缓存。 3、Expires、Cache-Control比较相同点： 两者都是强缓存。 不同点： Expires是http1.0规定的，而Cache-Control是http1.1规定的。 Expires的过期时间采用的是绝对时间，容易造成差错； 而Cache-Control的过期时间采用的时相对时间，在缓存上不会出现问题。 两者可以同时存在于一次请求中，但是不会同时在一次请求中起作用。 在HTTP1.0的环境下，Cache-Control不起作用，Expires起作用； 在HTTP1.1的环境之下， Expires不起作用，而Cache-Control起作用。当前一般都是http1.1的情况，所以Expires是作为一种向下兼容的形式而存在的。 Cache-Control的选择更多，功能更为强大，推荐使用。 Expires作为强缓存，功能单一，不推荐使用。 三、协商缓存header协商缓存一般是使用if-modified-since/last-modified和 f-none-match/etag 由服务器来决定浏览器缓存的资源是否可以使用。 1、if-modified-since/last-modified 在用户请求资源之后，服务器会返回这个资源，并且在response header中返回一个 last-modifed 字段，这时浏览器就会缓存这个资源以及最后的修改时间， 可以是： last-modified: Fri, 18 Aug 2017 07:27:24 GMT。 接着，当用户再次请求相同的资源时，需要在请求头中添加 if-modified-since 字段，这个字段的值就是之前存储的last-modifed 的值，服务器得到 if-modified 值之后，会和资源最近的修改时间作比较，如果命中，则返回304，让浏览器使用缓存的资源；否则，返回一个最新的资源并且在 last-modified 修改为最近的资源修改时间。 2、if-none-match/etag 在用户请求到资源之后，会返回这个资源，并且在response heade 中返回一个 etag 字段，即 entity tag，这个字段的值是一个字符串，唯一的标识了这个资源，只要资源发生了变化，这个etag值就会发生变化。 当用户再次请求资源时，会在request header中携带 if-none-match 字段，其值为上次缓存的 etag值，如果命中，则返回304，使用缓存资源；否则，服务器返回最新的资源。 3、两种协商缓存机制的比较相同点： 都是为了协商缓存。 不同点： 在精度上，Etag优于last-modified。 如果一个文件在1s内改变了很多次，通过etag是可以判断出来并返回最新的资源的，但是last-modifed的精度只能到s，是无法返回最新资源的，准确地说，UNIX记录只能精确到s。 在准确率上，Etag优于last-modified。有些文件可能整体copy等，只是在时间上发生了变化，而内容上并没有发生变化（etag变化，last-modified不变），如果使用last-modified，那么就会返回最新的资源，实际上这是不需要的。 在性能上，last-modified优于Etag。因为last-modified只需要记录时间，而etag需要重新由服务器生成一个hash值，所以在性能上etag略差。 在优先级上，Etag优于last-modified。 也就是说，etag和last-modified是可以同时使用的，但是到服务器端，会优先判断etag，如果相同，直接返回304；如果不同，就继续比较last-modified，然后再决定是否返回新的资源。 四、浏览器缓存过程 浏览器第一次加载资源，服务器返回200， 浏览器将资源下载下来，把资源和response header相关内容一并缓存。 下一次加载时，首先比较cache-control，如果没有超过时间，则命中强缓存，不发送请求，直接读取本地文件（如果不支持http1.1，则使用expires来判断）；如果时间已经过期，则发送带有if-none-match和if-modified-since的请求头。 服务器接受到请求之后，首先判断etag是否和服务器上文件的etag一致，如果一致，则命中协商缓存，返回304；如果不一致，返回新的资源并带上新的etag值返回200。 如果请求中没有etag值，则比较发送来的if-modified-since 值，如果命中，则返回304,；否则，返回新的资源带上新的last-modified的值并返回状态码200。 五、用户行为与缓存类型 地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制； F5刷新，浏览器会设置max-age=0，跳过强缓存判断，进行协商缓存判断； ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。]]></content>
      <tags>
        <tag>Expires</tag>
        <tag>Cache-Control</tag>
        <tag>modified</tag>
        <tag>etag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-limit限速]]></title>
    <url>%2F2018%2F06%2F27%2Fnginx-limit%E9%99%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[一、limit_conn语法1234Syntax: limit_conn zone number;Context: http, server, location# zone 特定键值# number 最大允许连接数 设置特定键值的共享内存区域和最大允许连接数。超过此限制时，服务器将返回错误以回复请求。 配置12345678910111213141516171819http &#123; limit_conn_zone $binary_remote_addr zone=perip:10m; limit_conn_zone $server_name zone=perserver:10m; limit_conn_zone $server_name zone=peradd:10m; ... server &#123; limit_conn perip 10; limit_conn perserver 100; ... location /download/ &#123; limit_conn peradd 1; &#125;# perip 、perserver 和 peradd 是自定义的特定键值# 分别标志着某个共享内存区域 二、limit_conn_zone语法123Syntax: limit_conn_zone key zone=name:size;Context: http# size共享内存区域大小 key为共享内存区域设置参数，该区域将保留各种键的状态。特别是，该状态包含当前的连接数。key可以包含文本，变量及其组合。在这里，客户端IP地址作为key。 size一个1M的区域可以保持大约32000个ipv4的状态或大约16000个ipv6的状态。如果区域存储耗尽，服务器会将错误返回给所有其他请求。 三、limit_rate语法1234Syntax: limit_rate rate;Default: limit_rate 0;Context: http, server, location, if in location# 限制对客户的响应传输速率 零值禁用速率限制 限制是根据请求设置的，所以如果客户端同时打开两个连接，总体速率将是指定限制的两倍 速率限制也可以在$limit_rate变量中设置 12345678server &#123; if ($slow) &#123; set $limit_rate 4k; &#125; ...&#125; 四、limit_rate_after语法123Syntax: limit_rate_after size;Default: limit_rate_after 0;Context: http, server, location, if in location 设置初始流量，超过设置的流量后将对客户进一步传送将受到速率限制。 1234location /flv/ &#123; limit_rate_after 500k; limit_rate 50k;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>limit_conn_zone</tag>
        <tag>limit_conn</tag>
        <tag>limit_rate_after</tag>
        <tag>limit_rate</tag>
        <tag>限速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[直方图拉伸和图像均衡化]]></title>
    <url>%2F2018%2F06%2F24%2F%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%8B%89%E4%BC%B8%E5%92%8C%E5%9B%BE%E5%83%8F%E5%9D%87%E8%A1%A1%E5%8C%96%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>直方图</tag>
        <tag>拉伸</tag>
        <tag>均衡化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理之亮度与对比度]]></title>
    <url>%2F2018%2F06%2F24%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[这个公式可以解释对图像的亮度和对比度操作的原理 α能使图像像素成倍数的增长或降低（α&lt;1），使图像的差值有线性变化，从而改变了图像的对比度。 β可为负，也可为正。任何一个像素加上或减去一个值会使这个像素点向白色或向黑色靠近，从而改变了图像的亮度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input onchange="f(this)" type="file"&gt; &lt;img width="250" height="250" id="scream"&gt; &lt;canvas id="myCanvas" width="250" height="250" style="border:1px solid #d3d3d3;"&gt; 您的浏览器不支持 HTML5 canvas 标签。 &lt;/canvas&gt; &lt;script&gt; function f(inputBtn) &#123; let url = URL.createObjectURL(inputBtn.files[0]); var c = document.getElementById("myCanvas"); var ctx = c.getContext("2d"); var img = document.getElementById("scream"); img.onload = function() &#123; ctx.drawImage(img, 0, 0, img.width, img.height); var imgData = ctx.getImageData(0, 0, c.width, c.height); //对比度系数 let Contrast = 1.2; //亮度增量 let brightness = 10; for (var i = 0; i &lt; imgData.data.length; i += 4) &#123; let r = imgData.data[i] * Contrast + brightness; let g = imgData.data[i + 1] * Contrast + brightness; let b = imgData.data[i + 2] * Contrast + brightness; imgData.data[i] = r; imgData.data[i + 1] = g; imgData.data[i + 2] = b; imgData.data[i + 3] = 255; &#125; ctx.putImageData(imgData, 0, 0); &#125; img.src = url; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>亮度</tag>
        <tag>对比度</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相似图片搜索原理]]></title>
    <url>%2F2018%2F06%2F23%2F%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E6%90%9C%E7%B4%A2%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[阮一峰：相似图片搜索的原理 一、颜色分布法每张图片都可以生成颜色分布的直方图(color histogram)。如果两张图片的直方图很接近，就可以认为它们很相似。 任何一种颜色都是由红绿蓝三原色（RGB）构成的，所以上图共有4张直方图（三原色直方图 + 最后合成的直方图）。 如果每种原色都可以取256个值，那么整个颜色空间共有1600万种颜色（256的三次方）。针对这1600万种颜色比较直方图，计算量实在太大了，因此需要采用简化方法。可以将0～255分成四个区：0～63为第0区，64～127为第1区，128～191为第2区，192～255为第3区。这意味着红绿蓝分别有4个区，总共可以构成64种组合（4的3次方）。 任何一种颜色必然属于这64种组合中的一种，这样就可以统计每一种组合包含的像素数量。 上图是某张图片的颜色分布表，将表中最后一栏提取出来，组成一个64维向量(7414, 230, 0, 0, 8, …, 109, 0, 0, 3415, 53929)。这个向量就是这张图片的特征值或者叫”指纹”。于是，寻找相似图片就变成了找出与其最相似的向量。这可以用皮尔逊相关系数或者余弦相似度算出。 二、内容特征法除了颜色构成，还可以从比较图片内容的相似性入手。 首先，将原图转成一张较小的灰度图片，假定为50x50像素。然后，确定一个阈值，将灰度图片转成黑白图片。 如果两张图片很相似，它们的黑白轮廓应该是相近的。于是，问题就变成了，第一步如何确定一个合理的阈值，正确呈现照片中的轮廓？ 显然，前景色与背景色反差越大，轮廓就越明显。这意味着，如果我们找到一个值，可以使得前景色和背景色各自的”类内差异最小“（minimizing the intra-class variance），或者”类间差异最大“（maximizing the inter-class variance），那么这个值就是理想的阈值。 1979年，日本学者大津展之证明了，”类内差异最小”与”类间差异最大”是同一件事，即对应同一个阈值。他提出一种简单的算法，可以求出这个阈值，这被称为“大津法”（Otsu’s method）。下面就是他的计算方法。 假定一张图片共有n个像素，其中灰度值小于阈值的像素为 n1 个，大于等于阈值的像素为 n2 个（n1 + n2 = n）。w1 和 w2 表示这两种像素各自的比重。 12w1 = n1 / nw2 = n2 / n 再假定，所有灰度值小于阈值的像素的平均值和方差分别为 μ1 和σ1，所有灰度值大于等于阈值的像素的平均值和方差分别为 μ2 和 σ2。于是，可以得到 类内差异 = w1(σ1的平方) + w2(σ2的平方) 类间差异 = w1w2(μ1-μ2)^2 可以证明，这两个式子是等价的：得到”类内差异”的最小值，等同于得到”类间差异”的最大值。不过，从计算难度看，后者的计算要容易一些。 下一步用”穷举法”，将阈值从灰度的最低值到最高值，依次取一遍，分别代入上面的算式。使得”类内差异最小”或”类间差异最大”的那个值，就是最终的阈值。具体的实例和Java算法，请看这里。 有了50x50像素的黑白缩略图，就等于有了一个50x50的0-1矩阵。矩阵的每个值对应原图的一个像素，0表示黑色，1表示白色。这个矩阵就是一张图片的特征矩阵。 两个特征矩阵的不同之处越少，就代表两张图片越相似。这可以用”异或运算”实现（即两个值之中只有一个为1，则运算结果为1，否则运算结果为0）。对不同图片的特征矩阵进行”异或运算”，结果中的1越少，就是越相似的图片。]]></content>
      <tags>
        <tag>图片</tag>
        <tag>搜索</tag>
        <tag>相似</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB、YUV和HSV]]></title>
    <url>%2F2018%2F06%2F23%2FRGB%E5%92%8CYUV%2F</url>
    <content type="text"><![CDATA[一、颜色空间模型颜色通常用三个独立的属性来描述，三个独立变量综合作用，自然就构成一个空间坐标，这就是颜色空间。但被描述的颜色对象本身是客观的，不同颜色空间只是从不同的角度去衡量同一个对象。 颜色空间按照基本机构可以分为两大类：基色颜色空间和色、亮分离颜色空间。前者典型的是RGB，后者包括YUV和HSV等等。 二、RGB颜色空间计算机和彩色电视机显示色彩的原理一样，都是采用R、G、B相加混色的原理，通过发射出三种不同强度的电子束，使屏幕内侧覆盖的红、绿、蓝磷光材料发光而产生色彩。这种色彩的表示方法称为RGB色彩空间表示。 三、YUV颜色空间YUV(亦称YCrCb)是被欧洲电视系统所采用的一种颜色编码方法。通常采用三管彩色摄像机或彩色CCD摄影机进行取像，然后把取得的彩色图像信号经分色、分别放大校正后得到RGB，再经过矩阵变换电路得到亮度信号Y和两个色差信号R-Y(即U)、B-Y(即V)，最后发送端将亮度和两个色差总共三个信号分别进行编码，用同一信道发送出去。这种色彩的表示方法就是所谓的YUV色彩空间表示。 采用YUV色彩空间的重要性是它的亮度信号Y和色度信号U、V是分离的。如果只有Y信号分量而没有U、V信号分量，那么这样表示的图像就是黑白灰度图像。彩色电视采用YUV空间正是为了用亮度信号Y解决彩色电视机与黑白电视机的兼容问题，使黑白电视机也能接收彩色电视信号。 Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异 Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之同的差异 对比度是不同像素点之间的差值，差值越大，对比度越明显 未量化转化公式12345678// RGB取值范围均为0-255Y = 0.299R + 0.587G + 0.114BU = -0.147R - 0.289G + 0.436BV = 0.615R - 0.515G - 0.100BR = Y + 1.140VG = Y - 0.395U - 0.581VB = Y + 2.032U 四、HSV颜色空间HSV是一种将RGB色彩空间中的点放在倒圆锥体中的表示方法。HSV即色相(Hue)、饱和度(Saturation)、明度(亮度Value)，又称HSB(B即Brightness)。HSV颜色空间，更类似于人类感觉颜色的方式 。 色相（H）是色彩的基本属性，如红、橙、黄、绿、蓝、靛、紫。 饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0-100%的数值。 明度（V），取0-max(计算机中HSV取值范围和存储的长度有关)。 HSV颜色空间可以用一个圆锥空间模型来描述。圆锥的顶点处，V=0，H和S无定义，代表黑色。圆锥的顶面中心处V=max，S=0，H无定义，代表白色。 色相是一组单独的概念，而纯度和明度是另一组概念。 同圆周角度的两个同心圆上的颜色一定有相同的色相，而掺白和掺黑的区别是： 掺杂了白色，颜色纯度降低，明度增加 掺杂了黑色，颜色纯度降低，明度降低 设max等于r、g和b中的最大者，min为最小者。h在0到360°之间，s在0到100%之间，v在0到max之间 关键字 色相 饱和度（纯度） 亮度（明度） 对比度 链接 RGB、YUV和HSV颜色空间模型 - pinhole - 博客园]]></content>
      <tags>
        <tag>RGB</tag>
        <tag>YUV</tag>
        <tag>HSV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鼠标事件与触摸事件]]></title>
    <url>%2F2018%2F06%2F20%2F%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E4%B8%8E%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、鼠标事件 mousedown：鼠标按钮被按下时触发。不能通过键盘触发。 mouseup：鼠标按钮被释放弹起时触发。不能通过键盘触发。 click：单击鼠标左键或者按下回车键时触发。 dblclick：双击鼠标左键时触发。 mouseover：鼠标移入目标元素或后代元素上时会触发。 mouseout：鼠标离开目标元素或后代元素时会触发 。 mouseenter：鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发。 mouseleave：鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发。 mousemove：当鼠标移入被选元素内后，任意移动一个像素点都会触发 。 注： 在一个元素上相继触发mousedown和mouseup事件，才会触发click事件。两次click事件相继触发才会触发dblclick事件。 1mousedown -&gt; mouseup -&gt; click -&gt;mousedown -&gt; mouseup -&gt; click -&gt; dblclick 如果取消 了mousedown或mouseup中的一个，click事件就不会被触发。直接或间接取消了click事件，dblclick事件就不会被触发了。 二、触摸事件 touchstart：当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。 touchmove：当手指在屏幕上滑动时连续地触发。调用preventDefault()可以阻止滚动。 touchend：当手指在屏幕上移开时触发。 touchcancel：当系统停止跟踪触摸时触发。关于此事件的确切触发时间，文档中没有明确说明。 注： 点一下的触发顺序 1touchstart -&gt; touchend -&gt; mouseover-&gt; mousedown -&gt; mouseup -&gt; click 移动端的click事件会延迟300ms左右触发事件回调。等待 300 毫秒，以判断用户是否再次点击了屏幕]]></content>
      <tags>
        <tag>鼠标事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件流与事件委托]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[原文 一、事件流事件流描述的是从页面中接收事件的顺序。 1、事件流感性认识问题：单击页面元素，什么样的元素能感应到这样一个事件？ 答案：单击目标元素的同时，也单击了目标元素的容器元素，甚至整个页面。 例子：有三个同心圆， 给每个圆添加对应的事件处理函数，弹出对应的文字。单击最里面的圆，同时也单击了外面的圆，所以外面圆的click事件也会被触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #outer&#123; position: absolute; width: 400px; height: 400px; top:0; left: 0; bottom:0; right: 0; margin: auto; background-color: deeppink; &#125; #middle&#123; position: absolute; width: 300px; height:300px; top:50%; left: 50%; margin-left: -150px; margin-top: -150px; background-color: deepskyblue; &#125; #inner&#123; position: absolute; width: 100px; height:100px; top:50%; left:50%; margin-left: -50px; margin-top: -50px;; background-color: darkgreen; text-align: center; line-height: 100px; color:white; &#125; #outer,#middle,#inner&#123; border-radius:100%; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="middle"&gt; &lt;div id="inner"&gt; click me! &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var innerCircle= document.getElementById("inner"); innerCircle.onclick= function () &#123; alert("innerCircle"); &#125;; var middleCircle= document.getElementById("middle"); middleCircle.onclick=function()&#123; alert("middleCircle"); &#125; var outerCircle= document.getElementById("outer"); outerCircle.onclick= function () &#123; alert("outerCircle"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 2、事件流事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。 1、两种事件流模型事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子 事件捕获的思想就是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="myDiv"&gt;Click me!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面这段html代码中，单击了页面中的&lt;div&gt;元素， 在冒泡型事件流中click事件传播顺序为&lt;div&gt;—》&lt;body&gt;—》&lt;html&gt;—》document 在捕获型事件流中click事件传播顺序为document—》&lt;html&gt;—》&lt;body&gt;—》&lt;div&gt; note: 所有现代浏览器都支持事件冒泡，但在具体实现中略有差别： IE5.5及更早版本中事件冒泡会跳过&lt;html&gt;元素(从body直接跳到document)。 IE9、Firefox、Chrome、和Safari则将事件一直冒泡到window对象。 IE9、Firefox、Chrome、Opera、和Safari都支持事件捕获。尽管DOM标准要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的。 由于老版本浏览器不支持，很少有人使用事件捕获。建议使用事件冒泡。 2、DOM事件流DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。 DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件捕获阶段：实际目标（&lt;div&gt;）在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3. 处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。 note: 尽管“DOM2级事件”标准规范明确规定事件捕获阶段不会涉及事件目标，但是在IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两次机会在目标对象上面操作事件。 并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。 两次机会在目标对象上面操作事件例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt; #outer&#123; position: absolute; width: 400px; height: 400px; top:0; left: 0; bottom:0; right: 0; margin: auto; background-color: deeppink; &#125; #middle&#123; position: absolute; width: 300px; height:300px; top:50%; left: 50%; margin-left: -150px; margin-top: -150px; background-color: deepskyblue; &#125; #inner&#123; position: absolute; width: 100px; height:100px; top:50%; left:50%; margin-left: -50px; margin-top: -50px;; background-color: darkgreen; text-align: center; line-height: 100px; color:white; &#125; #outer,#middle,#inner&#123; border-radius:100%; &#125;&lt;/style&gt;&lt;body&gt;&lt;div id="outer"&gt; &lt;div id="middle"&gt; &lt;div id="inner"&gt; click me! &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var innerCircle= document.getElementById("inner"); innerCircle.addEventListener("click", function () &#123; alert("innerCircle的click事件在捕获阶段被触发"); &#125;,true); innerCircle.addEventListener("click", function () &#123; alert("innerCircle的click事件在冒泡阶段被触发"); &#125;,false); var middleCircle= document.getElementById("middle"); middleCircle.addEventListener("click", function () &#123; alert("middleCircle的click事件在捕获阶段被触发"); &#125;,true); middleCircle.addEventListener("click", function () &#123; alert("middleCircle的click事件在冒泡阶段被触发"); &#125;,false); var outerCircle= document.getElementById("outer"); outerCircle.addEventListener("click", function () &#123; alert("outerCircle的click事件在捕获阶段被触发"); &#125;,true); outerCircle.addEventListener("click", function () &#123; alert("outerCircle的click事件在冒泡阶段被触发"); &#125;,false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果就是会陆续弹出6个框，为说明原理我整合成了一个图： 二、事件代理传统的事件处理中，需要为每个元素添加事件处理器。js事件代理则是一种简单有效的技巧，通过它可以把事件处理器添加到一个父级元素上，从而避免把事件处理器添加到多个子级元素上。 1、事件代理事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理。 事件代理的处理方式，代码如下： 12345678910111213141516171819202122232425&lt;body&gt; &lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;indigo&lt;/li&gt; &lt;li&gt;purple&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; (function() &#123; var colorList = document.getElementById("color-list"); colorList.addEventListener('click', showColor, false); function showColor(e) &#123; e = e || window.event; var targetElement = e.target || e.srcElement; if (targetElement.nodeName.toLowerCase() === "li") &#123; alert(targetElement.innerHTML); &#125; &#125; &#125;)(); &lt;/script&gt;&lt;/body&gt; 2、事件代理的好处 总结一下事件代理的好处： 将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。想象如果有一个100行的表格，对比传统的为每个单元格绑定事件处理器的方式和事件代理（即table上添加一个事件处理器），不难得出结论，事件代理确实避免了一些潜在的风险，提高了性能。 DOM更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。 3、事件代理的问题代码如下：事件代理同时绑定了li和span，当点击span的时候，li和span都会冒泡。 12345678910111213&lt;li&gt; &lt;span&gt;li中的span的内容&lt;/span&gt;&lt;/li&gt;&lt;script&gt; $(document).on('click', 'li', function(e)&#123; alert('li li'); &#125;); $(document).on('click', 'span', function(e)&#123; alert('li span'); &#125;)&lt;/script&gt; 解决办法： 方法一：span的事件处理程序中阻止事件继续传播（这里是冒泡） 1234$(document).on(&apos;click&apos;, &apos;span&apos;, function(e)&#123; alert(&apos;li span&apos;); e.stopPropagation(); &#125;) 方法二：li的事件处理程序中检测target元素 1234567$(document).on(&apos;click&apos;, &apos;li&apos;, function (e) &#123; if (e.target.nodeName == &apos;SPAN&apos;) &#123; e.stopPropagation(); return; &#125; alert(&apos;li li&apos;); &#125;); 4、事件代理的一个有趣应用点击一个列表时，输出对应的索引 12345678910&lt;script&gt; var ul=document.querySelector(&apos;ul&apos;); var lis=ul.querySelectorAll(&apos;ul li&apos;); ul.addEventListener(&apos;click&apos;, function (e) &#123; var target= e.target; if(target.nodeName.toUpperCase()===&apos;LI&apos;)&#123; alert([].indexOf.call(lis,target)); &#125; &#125;,false)&lt;/script&gt;]]></content>
      <tags>
        <tag>event</tag>
        <tag>事件流</tag>
        <tag>事件代理</tag>
        <tag>事件委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-this原理]]></title>
    <url>%2F2018%2F06%2F19%2FJS-this%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文 一、问题的由来学懂 JavaScript 语言，一个标志就是理解下面两种写法，可能有不一样的结果。 1234567891011var obj = &#123; foo: function () &#123;&#125;&#125;;var foo = obj.foo;// 写法一obj.foo()// 写法二foo() 上面代码中，虽然obj.foo和foo指向同一个函数，但是执行结果可能不一样。请看下面的例子。 12345678910var obj = &#123; foo: function () &#123; console.log(this.bar) &#125;, bar: 1&#125;;var foo = obj.foo;var bar = 2;obj.foo() // 1foo() // 2 这种差异的原因，就在于函数体内部使用了this关键字。很多教科书会告诉你，this指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以this指向obj；对于foo()来说，foo运行在全局环境，所以this指向全局环境。所以，两者的运行结果不一样。 这种解释没错，但是教科书往往不告诉你，为什么会这样？也就是说，函数的运行环境到底是怎么决定的？举例来说，为什么obj.foo()就是在obj环境执行，而一旦var foo = obj.foo，foo()就变成在全局环境执行？ 本文就来解释 JavaScript 这样处理的原理。理解了这一点，你就会彻底理解this的作用。 二、内存的数据结构JavaScript 语言之所以有this的设计，跟内存里面的数据结构有关系。 1var obj = &#123; foo: 5 &#125;; 上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象{ foo: 5 }，然后把这个对象的内存地址赋值给变量obj。 也就是说，变量obj是一个地址（reference）。后面如果要读取obj.foo，引擎先从obj拿到内存地址，然后再从该地址读出原始的对象，返回它的foo属性。 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。 12345678&#123; foo: &#123; [[value]]: 5 [[writable]]: true [[enumerable]]: true [[configurable]]: true &#125;&#125; 注意，foo属性的值保存在属性描述对象的value属性里面。 三、函数这样的结构是很清晰的，问题在于属性的值可能是一个函数。 1var obj = &#123; foo: function () &#123;&#125; &#125;; 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。 123456&#123; foo: &#123; [[value]]: 函数的地址 ... &#125;&#125; 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。 12345678var f = function () &#123;&#125;;var obj = &#123; f: f &#125;;// 单独执行f()// obj 环境执行obj.f() 四、环境变量JavaScript 允许在函数体内部，引用当前环境的其他变量。 123var f = function () &#123; console.log(x);&#125;; 上面代码中，函数体里面使用了变量x。该变量由运行环境提供。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。 123var f = function () &#123; console.log(this.x);&#125; 上面代码中，函数体里面的this.x就是指当前运行环境的x。 123456789101112131415var f = function () &#123; console.log(this.x);&#125;var x = 1;var obj = &#123; f: f, x: 2,&#125;;// 单独执行f() // 1// obj 环境执行obj.f() // 2 上面代码中，函数f在全局环境执行，this.x指向全局环境的x。 在obj环境执行，this.x指向obj.x。 回到本文开头提出的问题，obj.foo()是通过obj找到foo，所以就是在obj环境执行。一旦var foo = obj.foo，变量foo就直接指向函数本身，所以foo()就变成在全局环境执行。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-渲染-composite]]></title>
    <url>%2F2018%2F06%2F16%2Fcss-%E6%B8%B2%E6%9F%93-Composite%2F</url>
    <content type="text"><![CDATA[原文 利用合成层，加速渲染 防止层爆，优化性能 一、整体流程一个 Web 页面的展示，简单来说可以认为经历了以下几个步骤。 JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。 Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。(Render Tree) Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，&lt;body&gt; 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。 Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。 Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。 当然，本文我们只来关注 Composite 部分。 二、浏览器渲染原理在讨论 Composite 之前，有必要先简单了解下一些浏览器（本文只是针对 Chrome 来说）的渲染原理，方便对之后一些概念的理解。更多详细的内容可以参阅 GPU Accelerated Compositing in Chrome 在浏览器中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。这一点相信大家都很熟悉了，但其实，从 DOM 树到最后的渲染，需要进行一些转换映射。 1、从 Nodes 到 LayoutObjectsDOM 树中得每个 Node 节点都有一个对应的 LayoutObject 。LayoutObject 知道如何在屏幕上 paint Node 的内容。 2、从 LayoutObjects 到 PaintLayers一般来说，拥有相同的坐标空间的 LayoutObjects，属于同一个渲染层（PaintLayer）。PaintLayer 最初是用来实现 stacking contest（层叠上下文），以此来保证页面元素以正确的顺序合成（composite），这样才能正确的展示元素的重叠以及半透明元素等等。因此满足形成层叠上下文条件的 LayoutObject 一定会为其创建新的渲染层，当然还有其他的一些特殊情况，为一些特殊的 LayoutObjects 创建一个新的渲染层，比如 overflow != visible 的元素。根据创建 PaintLayer 的原因不同，可以将其分为常见的 3 类： NormalPaintLayer 根元素（HTML） 有明确的定位属性（relative、fixed、sticky、absolute） 透明的（opacity 小于 1） 有 CSS 滤镜（fliter） 有 CSS mask 属性 有 CSS mix-blend-mode 属性（不为 normal） 有 CSS transform 属性（不为 none） backface-visibility 属性为 hidden 有 CSS reflection 属性 有 CSS column-count 属性（不为 auto）或者 有 CSS column-width 属性（不为 auto） 当前有对于 opacity、transform、fliter、backdrop-filter 应用动画 OverflowClipPaintLayer overflow 不为 visible NoPaintLayer 不需要 paint 的 PaintLayer，比如一个没有视觉属性（背景、颜色、阴影等）的空 div。 满足以上条件的 LayoutObject 会拥有独立的渲染层，而其他的 LayoutObject 则和拥有独立渲染层的最近的祖先元素共用一个。 3、从 PaintLayers 到 GraphicsLayers某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和拥有 GraphicsLayer 的最近的祖先层公用一个。 注：根元素（html）是最外一层合成层（Compositing Layers），包含了其子合成层、子渲染层（NormalPaintLayer、OverflowClipPaintLayer、NoPaintLayer） 每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后 draw 到屏幕上，此时，我们的页面也就展现到了屏幕上。 渲染层提升为合成层的原因有一下几种： 注：渲染层提升为合成层有一个先决条件，该渲染层必须是 SelfPaintingLayer（基本可认为是上文介绍的 NormalPaintLayer）。以下所讨论的渲染层提升为合成层的情况都是在该渲染层为 SelfPaintingLayer 前提下的。 直接原因（direct reason） 硬件加速的 iframe 元素（比如 iframe 页面中有合成层）demo video 元素 覆盖在 video 元素上的视频控制栏 3D 或者 硬件加速的 2D Canvas 元素 demo：普通 2D Canvas 不会提升为合成层 demo：3D Canvas 提升为合成层 硬件加速的插件，比如 flash 等等 在 DPI 较高的屏幕上，fix 定位的元素会自动地被提升到合成层中。但在 DPI 较低的设备上却并非如此，因为这个渲染层的提升会使得字体渲染方式由子像素变为灰阶（详细内容请参考：Text Rendering） 有 3D transform backface-visibility 为 hidden 对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效） demo：animation demo：transition will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）demo 后代元素原因 有合成层后代同时本身有 transform、opactiy（小于 1）、mask、fliter、reflection 属性 demo 有合成层后代同时本身 overflow 不为 visible（如果本身是因为明确的定位因素产生的 SelfPaintingLayer，则需要 z-index 不为 auto） demo 有合成层后代同时本身 fixed 定位 demo 有 3D transfrom 的合成层后代同时本身有 preserves-3d 属性 demo 有 3D transfrom 的合成层后代同时本身有 perspective 属性 demo overlap 重叠原因 为什么会因为重叠原因而产生合成层呢？举个简单的栗子。 蓝色的矩形重叠在绿色矩形之上，同时它们的父元素是一个 GraphicsLayer。此时假设绿色矩形为一个 GraphicsLayer，如果 overlap 无法提升合成层的话，那么蓝色矩形不会提升为合成层，也就会和父元素公用一个 GraphicsLayer。 此时，渲染顺序就会发生错误，因此为保证渲染顺序，overlap 也成为了合成层产生的原因，也就是如下的正常情形。 当然 overlap 的原因也会细分为几类，接下来我们会详细看下。 重叠或者说部分重叠在一个合成层之上。 那如何算是重叠呢，最常见和容易理解的就是元素的 border box（content + padding + border） 和合成层的有重叠，比如：demo，当然 margin area 的重叠是无效的（demo）。其他的还有一些不常见的情况，也算是同合成层重叠的条件，如下： filter 效果同合成层重叠 demo transform 变换后同合成层重叠 demo overflow scroll 情况下同合成层重叠。即如果一个 overflow scroll（不管 overflow:auto 还是 overflow:scrill，只要是能 scroll 即可） 的元素同一个合成层重叠，则其可视子元素也同该合成层重叠 demo 假设重叠在一个合成层之上（assumedOverlap）。 这个原因听上去有点虚，什么叫假设重叠？其实也比较好理解，比如一个元素的 CSS 动画效果，动画运行期间，元素是有可能和其他元素有重叠的。针对于这种情况，于是就有了 assumedOverlap 的合成层产生原因，示例可见：demo。在本 demo 中，动画元素视觉上并没有和其兄弟元素重叠，但因为 assumedOverlap 的原因，其兄弟元素依然提升为了合成层。 需要注意的是该原因下，有一个很特殊的情况： 如果合成层有内联的 transform 属性，会导致其兄弟渲染层 assume overlap，从而提升为合成层。比如：demo。 4、层压缩基本上常见的一些合成层的提升原因如上所说，你会发现，由于重叠的原因，可能随随便便就会产生出大量合成层来，而每个合成层都要消耗 CPU 和内存资源，岂不是严重影响页面性能。这一点浏览器也考虑到了，因此就有了层压缩（Layer Squashing）的处理。如果多个渲染层和一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。具体可以看如下 demo。一开始，蓝色方块由于translateZ 提升为了合成层，其他的方块元素因为重叠的原因，被压缩了一起，大小就是包含这 3 个方块的矩形大小。 当我们 hover 绿色方块时，会给其设置 translateZ 属性，导致绿色方块也被提升为合成层，则剩下的两个被压缩到了一起，大小就缩小为包含这 2 个方块的矩形大小。 当然，浏览器的自动的层压缩也不是万能的，有很多特定情况下，浏览器是无法进行层压缩的，如下所示，而这些情况也是我们应该尽量避免的。（注：以下情况都是基于重叠原因而言） 无法进行会打破渲染顺序的压缩（squashingWouldBreakPaintOrder） 示例如下：demo 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; #ancestor &#123; -webkit-mask-image: -webkit-linear-gradient(rgba(0,0,0,1), rgba(0,0,0,0)); &#125; #composited &#123; width: 100%; height: 100%; transform: translateZ(0); &#125; #container &#123; position: relative; width: 400px; height: 60px; border: 1px solid black; &#125; #overlap-child &#123; position: absolute; left: 0; top: 0 ; bottom: 0px; width: 100%; height: 60px; background-color: orange; &#125;&lt;/style&gt;&lt;div id="container"&gt; &lt;div id="composited"&gt;Text behind the orange box.&lt;/div&gt; &lt;div id="ancestor"&gt; &lt;div id="overlap-child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在本例中，#overlap-child 同合成层重叠，如果进行压缩，会导致渲染顺序的改变，其父元素 #ancestor 的 mask 属性将失效，因此类似这种情况下，是无法进行层压缩的。目前常见的产生这种原因的情况有两种，一种是上述的祖先元素使用 mask 属性的情况，另一种是祖先元素使用 filter 属性的情况（demo）。 video 元素的渲染层无法被压缩同时也无法将别的渲染层压缩到 video 所在的合成层上（squashingVideoIsDisallowed）demo iframe、plugin 的渲染层无法被压缩同时也无法将别的渲染层压缩到其所在的合成层上（squashingLayoutPartIsDisallowed）demo 无法压缩有 reflection 属性的渲染层（squashingReflectionDisallowed）demo 无法压缩有 blend mode 属性的渲染层（squashingBlendingDisallowed）demo 当渲染层同合成层有不同的裁剪容器（clipping container）时，该渲染层无法压缩（squashingClippingContainerMismatch）。 示例如下：demo 123456789101112131415161718192021222324252627282930&lt;style&gt; .clipping-container &#123; overflow: hidden; height: 10px; background-color: blue; &#125; .composited &#123; transform: translateZ(0); height: 10px; background-color: red; &#125; .target &#123; position:absolute; top: 0px; height:100px; width:100px; background-color: green; color: #fff; &#125;&lt;/style&gt;&lt;div class="clipping-container"&gt; &lt;div class="composited"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="target"&gt;不会被压缩到 composited div 上&lt;/div&gt; 本例中 .target 同 合成层 .composited 重叠，但是由于 .composited 在一个 overflow: hidden 的容器中，导致 .target 和合成层有不同的裁剪容器，从而 .target 无法被压缩。 相对于合成层滚动的渲染层无法被压缩（scrollsWithRespectToSquashingLayer） 示例如下：demo 1234567891011121314151617181920212223242526272829&lt;style&gt; body &#123; height: 1500px; overflow-x: hidden; &#125; .composited &#123; width: 50px; height: 50px; background-color: red; position: absolute; left: 50px; top: 400px; transform: translateZ(0); &#125; .overlap &#123; width: 200px; height: 200px; background-color: green; position: fixed; left: 0px; top: 0px; &#125;&lt;/style&gt;&lt;div class="composited"&gt;&lt;/div&gt;&lt;div class="overlap"&gt;&lt;/div&gt; 本例中，红色的 .composited 提升为了合成层，绿色的 .overlap fix 在页面顶部，一开始只有 .composited 合成层。 当滑动页面，.overlap 重叠到 .composited 上时，.overlap 会因重叠原因提升为合成层，同时，因为相对于合成层滚动，因此无法被压缩。 当渲染层同合成层有不同的具有 opacity 的祖先层（一个设置了 opacity 且小于 1，一个没有设置 opacity，也算是不同）时，该渲染层无法压缩（squashingOpacityAncestorMismatch，同 squashingClippingContainerMismatch）demo 当渲染层同合成层有不同的具有 transform 的祖先层时，该渲染层无法压缩（squashingTransformAncestorMismatch，同上） demo 当渲染层同合成层有不同的具有 filter 的祖先层时，该渲染层无法压缩（squashingFilterAncestorMismatch，同上）demo 当覆盖的合成层正在运行动画时，该渲染层无法压缩（squashingLayerIsAnimating），当动画未开始或者运行完毕以后，该渲染层才可以被压缩 demo 三、如何查看合成层使用 Chrome DevTools 工具来查看页面中合成层的情况。 比较简单的方法是打开 DevTools，勾选上 Show layer borders 其中，页面上的合成层会用黄色边框框出来。 当然，更加详细的信息可以通过 Timeline 来查看。 每一个单独的帧，看到每个帧的渲染细节： 点击之后，你就会在视图中看到一个新的选项卡：Layers。 点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有合成层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因。 有了这个视图，你就能知道页面中到底有多少个合成层。如果你在对页面滚动或渐变效果的性能分析中发现 Composite 过程耗费了太多时间，那么你可以从这个视图里看到页面中有多少个渲染层，它们为何被创建，从而对合成层的数量进行优化。 四、性能优化提升为合成层简单说来有以下几点好处： - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层- 对于 transform 和 opacity 效果，不会触发 layout 和 paint 利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。 五、提升动画效果的元素合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，我们需要把动画效果中的元素提升为合成层。 提升合成层的最好方式是使用 CSS 的 will-change 属性。从上一节合成层产生原因中，可以知道 will-change 设置为 opacity、transform、top、left、bottom、right 可以将元素提升为合成层。 123#target &#123; will-change: transform;&#125; 其兼容如下所示： 对于那些目前还不支持 will-change 属性的浏览器，目前常用的是使用一个 3D transform 属性来强制提升为合成层： 123#target &#123; transform: translateZ(0);&#125; 但需要注意的是，不要创建太多的渲染层。因为每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。之后我们会详细讨论。 如果你已经把一个元素放到一个新的合成层里，那么可以使用 Timeline 来确认这么做是否真的改进了渲染性能。别盲目提升合成层，一定要分析其实际性能表现。 六、使用 transform 或者 opacity 来实现动画效果文章最开始，我们讲到了页面呈现出来所经历的渲染流水线，其实从性能方面考虑，最理想的渲染流水线是没有布局和绘制环节的，只需要做合成层的合并即可： 为了实现上述效果，就需要只使用那些仅触发 Composite 的属性。目前，只有两个属性是满足这个条件的：transforms 和 opacity。更详细的信息可以查看 CSS Triggers。 注意：元素提升为合成层后，transform 和 opacity 才不会触发 paint，如果不是合成层，则其依然会触发 paint。具体见如下两个 demo。 demo 1：transform demo 2：opacity 可以看到未提升 target element 为合成层，transform 和 opacity 依然会触发 paint。 七、减少绘制区域对于不需要重新绘制的区域应尽量避免绘制，以减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面内容某个区域 repaint 时，整个屏幕包括 fix 的 header 也会被重绘，见 demo，结果如下： 而对于固定不变的区域，我们期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层。 减少绘制区域，需要仔细分析页面，区分绘制区域，减少重绘区域甚至避免重绘。 八、合理管理合成层看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。 对于合成层占用内存的问题，我们简单做了几个 demo 进行了验证。 demo 1 和 demo 2 中，会创建 2000 个同样的 div 元素，不同的是 demo 2 中的元素通过 will-change 都提升为了合成层，而两个 demo 页面的内存消耗却有很明显的差别。 九、防止层爆炸通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。我们简单写了一个极端点但其实在我们的页面中比较常见的 demo。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style&gt; @-webkit-keyframes slide &#123; from &#123; transform: none; &#125; to &#123; transform: translateX(100px); &#125; &#125; .animating &#123; width: 300px; height: 30px; background-color: orange; color: #fff; -webkit-animation: slide 5s alternate linear infinite; &#125; ul &#123; padding: 5px; border: 1px solid #000; &#125; .box &#123; width: 600px; height: 30px; margin-bottom: 5px; background-color: blue; color: #fff; position: relative; /* 会导致无法压缩：squashingClippingContainerMismatch */ overflow: hidden; &#125; .inner &#123; position: absolute; top: 2px; left: 2px; font-size: 16px; line-height: 16px; padding: 2px; margin: 0; background-color: green; &#125;&lt;/style&gt;&lt;!-- 动画合成层 --&gt;&lt;div class="animating"&gt;composited animating&lt;/div&gt;&lt;ul&gt; &lt;!-- assume overlap --&gt; &lt;li class="box"&gt; &lt;!-- assume overlap --&gt; &lt;p class="inner"&gt;asume overlap, 因为 squashingClippingContainerMismatch 无法压缩&lt;/p&gt; &lt;/li&gt; ...&lt;/ul&gt; demo 中，.animating 的合成层在运行动画，会导致 .inner 元素因为上文介绍过的 assumedOverlap 的原因，而被提升为合成层，同时，.inner 的父元素 .box 设置了 overflow: hidden，导致 .inner 的合成层因为 squashingClippingContainerMismatch 的原因，无法压缩，就出现了层爆炸的问题。 这种情况平时在我们的业务中还是很常见的，比如 slider + list 的结构，一旦满足了无法进行层压缩的情况，就很容易出现层爆炸的问题。 解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。对于上述的示例，我们可以将 .animation 的 z-index 提高。修改后 demo 1234567.animating &#123; ... /* 让其他元素不和合成层重叠 */ position: relative; z-index: 1;&#125; 此时，就只有 .animating 提升为合成层，如下： 同时，内存占用比起之前也降低了很多。 如果受限于视觉需要等因素，其他元素必须要覆盖在合成层之上，那应该尽量避免无法层压缩情况的出现。针对上述示例中，无法层压缩的情况（squashingClippingContainerMismatch），我们可以将 .box 的 overflow: hidden 去掉，这样就可以利用浏览器的层压缩了。修改后 demo 此时，由于第一个 .box 因为 squashingLayerIsAnimating 的原因无法压缩，其他的都被压缩到了一起。 同时，内存占用比起之前也降低了很多。]]></content>
      <tags>
        <tag>css</tag>
        <tag>渲染</tag>
        <tag>composite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-zoom和scale的区别]]></title>
    <url>%2F2018%2F06%2F15%2Fcss-zoom%E5%92%8Cscale%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、zoom1、属性值 auto根据viewport来既定当前标签的缩放。 &lt;number&gt;非负数。1表示没有缩放，大于1表示放大的倍数，小于1亦然。 &lt;percentage&gt;非负百分比。以100%为基础进行缩放。 2、兼容性除了Firefox和Opera Mini 3、规范草案中 二、区别 zoom更全面，但是不能负数，只能等比例控制 scale只能数值，但是能负数，可以只控制1个维度 zoom的缩放是相对于左上角的 scale默认是居中缩放； zoom的缩放改变了元素占据的空间大小，页面布局重新计算，有性能问题； scale的缩放占据的原始尺寸不变，页面布局不会发生变化；]]></content>
      <tags>
        <tag>css</tag>
        <tag>zoom</tag>
        <tag>scale</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-clip-path]]></title>
    <url>%2F2018%2F06%2F15%2Fcss-clip-path%2F</url>
    <content type="text"><![CDATA[一、clip-path123456789101112131415161718192021222324252627.clip-me &#123; /* 剪裁路径来自内联SVG &lt;clipPath&gt;元素 */ clip-path: url(#c1); /* 路径来自外部SVG */ clip-path: url(path.svg#c1); /*带圆角的矩形*/ /*前四个参数代表上、右、下、左到边框的距离*/ /*后四个参数代表上、右、下、左的圆角半径大小，跟border-radius类似*/ clip-path: inset(10% 20px 30px 5% round 14px 50% 10% 50%); clip-path: inset(10% 20px 30px 5% round 14px 50% 10% 50%/10px 50% 2% 50%); /* 多边形 */ clip-path: polygon(5% 5%, 100% 0%, 100% 75%, 75% 75%, 75% 100%, 50% 75%, 0% 75%); /* 圆 */ clip-path: circle(30px at 35px 35px); /* 椭圆 */ clip-path: ellipse(65px 30px at 125px 40px);&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>clip-path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-谁家的百分比]]></title>
    <url>%2F2018%2F06%2F14%2Fcss-%E8%B0%81%E5%AE%B6%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%2F</url>
    <content type="text"><![CDATA[相对于父元素宽度的： [max/min-]width left right text-indent padding margin 注：已验证 相对于父元素高度的： [max/min-]height top bottom 注：已验证 相对于主轴长度的： flex-basis 注：已验证 相对于继承字号的： font-size 注：已验证 相对于自身字号的： line-height 注：已验证 相对于自身宽高的： border-radius background-size border-image-width transform: translate() transform-origin zoom clip-path 注：已验证 相对于自身行高的： vertical-align 注：已验证 特殊算法的： background-position （包含块宽高减去背景图宽高后的部分）验 border-image-slice （相对于图片尺寸） filter 系列函数等]]></content>
      <tags>
        <tag>css</tag>
        <tag>百分比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-position]]></title>
    <url>%2F2018%2F06%2F12%2Fcss-position%2F</url>
    <content type="text"><![CDATA[一、定位类型 相对定位元素（relatively positioned element）是计算后位置属性为 relative的元素。 绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素。 粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。 大多数情况下，height和width被设定为auto的绝对定位元素，按其内容大小调整尺寸。但是，被绝对定位的元素可以通过： 指定top和bottom，保留height未指定（即auto），来填充可用的垂直空间。 指定left和 right，并将width指定为auto，来填充可用的水平空间。 如果top和bottom都被指定（技术上，而不是auto），top 胜出。 如果指定了left 和right两侧，则在direction为ltr（英语，水平日语等）时left赢，并且在direction为rtl时right赢（阿拉伯文，希伯来文等）。 二、取值 static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index属性无效。 relative 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。 absolute 不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky 根据文档的正常流程进行定位，然后根据top、right、bottom、 left ，相对于其最近的滚动祖先和containing block （最近的块级祖先）偏移。偏移量不会影响任何其他元素的位置。 该值始终创建一个新的堆叠上下文(stacking context)。请注意，粘性元素“粘”到最近的具有“滚动机制”的祖先（overflow 是 hidden, scroll, auto, 或 overlay ），即使该祖先不是最接近的实际滚动祖先。这有效地抑制了任何“粘性”行为 。 当最近的滚动祖先和最近的块级祖先不是同一个元素时，元素大小根据最近的块级祖先计算，元素位置根据最近的滚动祖先计算。 如果最近的块级祖先的高度小于或者等于元素的高度，仍然有粘性效果，但观察不出来。因为元素本身和最近的块级祖先同时进出最近的滚动祖先。 三、确定包含块一个元素的大小和位置经常受其包含块的影响 （width、height、top等属性的百分比值是根据包含块大小计算的），确定其包含块的过程完全依赖于这个元素的 position属性： 如果 position 属性为 static、 relative、sticky ，其包含块就是由它的最近的祖先块元素**（比如说inline-block, block 或 list-item元素）或格式化上下文(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的。 如果 position 属性为 absolute ，包含块就是由它的最近的 position 的值不是 static（fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成。 如果 position 属性是 fixed，包含块就是由 viewport (in the case of continuous media) 组成的。 如果 position 属性是absolute或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的： A transform or perspective value other than none A will-change value of transform or perspective A filter value other than none or a will-change value of filter (only works on Firefox).]]></content>
      <tags>
        <tag>css</tag>
        <tag>position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-flow]]></title>
    <url>%2F2018%2F06%2F12%2Fcss-flow%2F</url>
    <content type="text"><![CDATA[in-flow和out-of-flow规范规定1An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow. 如果一个元素是浮动的(float:left/right)，绝对定位的(position:absolute/fixed)或者是根元素(html)，那么它被称之为流外的元素(out-of-flow)。如果一个元素不是流外的元素，那么它被称之为流内的元素(in-flow)。 1The flow of an element A is the set consisting of A and all in-flow elements whose nearest out-of-flow ancestor is A. 元素 A 的流是一个集合，包含 A 元素本身，以及元素 A 的流内的子元素且这些子元素最近的流外祖先是 A 元素。 示例12345678&lt;div class="A" style="position: absolute;"&gt; &lt;div class="B"&gt;&lt;/div&gt; &lt;div class="C" style="position:absolute"&gt; &lt;div class="D"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="E"&gt; &lt;div class="F"&gt;&lt;/div&gt;&lt;/div&gt; 以上示例中，A 元素的流包含分析如下： A 和 C 是流外的元素，所以 C 被排除 D 元素由于最近的流外祖先是 C，所以他也不是 A 的流 所以最终 A 元素流内的元素只剩下：ABEF]]></content>
      <tags>
        <tag>css</tag>
        <tag>flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据规范重写Promise]]></title>
    <url>%2F2018%2F06%2F01%2FJS-%E6%A0%B9%E6%8D%AE%E8%A7%84%E8%8C%83%E9%87%8D%E5%86%99Promise%2F</url>
    <content type="text"><![CDATA[零、原文链接 一、使用场景123456789101112getUserId().then(getUserJobById).then(function(job) &#123; // 对job的处理&#125;);function getUserJobById(id) &#123; return new Promise(function(resolve) &#123; http.get(baseUrl + id, function(job) &#123; resolve(job); &#125;); &#125;);&#125; 二、具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function Promise(fn) &#123; //一个promise对象有状态、值、回调callbacksList //then()可以别调用多次，所以是callbacksList var state = 'pending', value = null, callbacks = []; //then()函数必须返回一个promised对象 //then()函数功能类似于订阅者模式中的listen() this.then = function(onFulfilled, onRejected) &#123; return new Promise(function(resolve, reject) &#123; handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected, ret; if (cb === null) &#123; //如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 //如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 cb = state === 'fulfilled' ? callback.resolve : callback.reject; cb(value); return; &#125; //如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e try &#123; //cb()函数说明，只要父promise不抛出异常，子promise都成功执行 //ret也可能是一个promise对象 ret = cb(value); callback.resolve(ret); &#125; catch (e) &#123; callback.reject(e); &#125; &#125; //resolve()和reject()函数功能类似于订阅者模式中的trigger() function resolve(newValue) &#123; //newValue可能是一个promise对象 if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; //由newValue（promise）对象调用当前promise对象的resolve或reject then.call(newValue, resolve, reject); return; &#125; &#125; state = 'fulfilled'; value = newValue; execute(); &#125; function reject(reason) &#123; state = 'rejected'; value = reason; execute(); &#125; function execute() &#123; setTimeout(function() &#123; callbacks.forEach(function(callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve, reject);&#125; 注：异步处理上，没有达到要求。具体参见事件循环 三、封装的代码123456789101112131415161718192021222324252627282930313233343536373839404142// @/tool/axios.jsimport qs from 'qs';import iView from 'iview';import axios from 'axios';export default function (config) &#123; if (config.isFormData) &#123; config.data = qs.stringify(config.data); !config.headers &amp;&amp; (config.headers = &#123;&#125;); config.headers['Content-Type'] = 'application/x-www-form-urlencoded'; &#125; return axios(config).then( res =&gt; &#123; if (res.data.status &gt;= 1) &#123; config.showSuccess &amp;&amp; iView.Notice.success(&#123; duration: 2, title: '通知', desc: res.data.msg &#125;); return Promise.resolve(res); &#125; if (res.data.status === 0) &#123; !config.hiddenError &amp;&amp; iView.Notice.error(&#123; duration: 2, title: '提示', desc: res.data.msg &#125;); // 如果直接返回res，则下一个新的promise，一定会直接执行onFulfilled // 返回一个Promise.resolve(res)或Promise.reject(res)，则新的promise的状态将由返回的状态决定 return Promise.reject(res); &#125; if (res.data.status &lt; 0) &#123; location.href = `#/login?returnUrl=$&#123;location.href&#125;`; localStorage.removeItem('user'); return Promise.reject(res); &#125; &#125; );&#125; 12345678910111213141516171819202122232425262728// @/tool/Admin.jsimport Axios from '@/tool/axios.js';import &#123;dateFormat&#125; from '@/tool/transform.js';export default class Admin &#123; constructor(admin) &#123; admin = admin || &#123;&#125;; this.id = admin.id || -1; this.username = admin.username || ''; this.password = admin.password || ''; &#125; login() &#123; const that = this; return Axios(&#123; url: `/api/user/login`, method: 'put', isFormData: true, data: &#123; username: that.username, password: that.password &#125; &#125;).then( res =&gt; Promise.resolve(res), err =&gt; Promise.reject(err) ); &#125;&#125; 12345678910// login.vueimport Admin from '@/tool/Admin.js'that.admin.login().then( res =&gt; &#123; &#125;, err =&gt; &#123; console.error(err); &#125;); 123// 整体调用等同于axios(config).then().then().then();// 每一个.then()都返回一个新的promise]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise/A+规范]]></title>
    <url>%2F2018%2F05%2F31%2FJS-Promise-A-%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[零、英文原文：Promise/A+ 一、术语 Promise：是一个拥有 then 方法的对象或函数，其行为符合本规范； thenable：是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”； 值（value）：指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）； 异常（exception）：是使用 throw 语句抛出的一个值。 据因（reason）：表示一个 promise 的拒绝原因。 二、要求1、Promise 的状态一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 2、等待态（Pending）处于等待态时，promise 需满足以下条件： 可以迁移至执行态或拒绝态 3、执行态（Fulfilled）处于执行态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的终值 4、拒绝态（Rejected）处于拒绝态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的据因 这里的不可变指的是恒等（即可用 === 判断相等），而不是意味着更深层次的不可变（译者注：盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。 三、Then方法一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。promise 的 then 方法接受两个参数： 1promise.then(onFulfilled, onRejected) 1、参数可选onFulfilled 和 onRejected 都是可选参数。 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 2、onFulfilled 特性如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 3、onRejected 特性如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 4、调用时机onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 注1 5、调用要求 onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）注2 6、多次调用then 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 7、返回then 方法可以被同一个 promise 调用多次**then 方法必须返回一个 promise 对象** 注3 1promise2 = promise1.then(onFulfilled, onRejected); 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[Resolve] 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 四、Promise 解决过程Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [Resolve]，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。 运行 [Resolve] 需遵循以下步骤： 1、x 与 promise 相等如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise 2、x 为 Promise如果 x 为 Promise ，则使 promise 接受 x 的状态 注4： 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值成功执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise 3、x 为对象或函数如果 x 为对象或者函数： 把 x.then 赋值给 then 注5 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [Resolve] 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [Resolve] 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise 注6。 五、注释 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（译者注：即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。 译者注：这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。 两个类别的具体分类如下： macro-task: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering micro-task: process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver。详见 stackoverflow 解答 或 这篇博客 注2 也就是说在严格模式（strict）中，函数 this 的值为 undefined ；在非严格模式中其为全局对象。 注3 代码实现在满足所有要求的情况下可以允许 promise2 === promise1 。每个实现都要文档说明其是否允许以及在何种条件下允许 romise2 === promise1 。 注4 总体来说，如果 x 符合当前实现，我们才认为它是真正的 promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。 注5 这步我们先是存储了一个指向 x.then 的引用，然后测试并调用该引用，以避免多次访问 x.then 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。 注6 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[column实现瀑布流布局]]></title>
    <url>%2F2018%2F05%2F30%2FCSS-column%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、属性 column-count: 最理想的分栏数目 column-gap: 栏目之间的水平间隙 column-rule: 分割线，形式规则什么的等同于border break-inside: 内容盒子如何中断 12345678910111213141516171819202122/*瀑布流层*/.waterfall &#123; column-count: 4; column-gap: 1em;&#125;/*一个内容层*/.item &#123; padding: 1em; margin: 0 0 1em 0; break-inside: avoid; border: 1px solid #000;&#125;.item img &#123; width: 100%; margin-bottom: 10px;&#125; 123456&lt;div class="waterfall"&gt; &lt;div class="item"&gt; &lt;img src="https://imgsa.jpg"&gt; &lt;p&gt;1 convallis timestamp&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>css</tag>
        <tag>column，瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex瀑布流布局]]></title>
    <url>%2F2018%2F05%2F30%2FCSS-flex%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12345678910&lt;div class="masonry"&gt; &lt;div class="item"&gt; &lt;div class="item__content"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;div class="item__content item__content--small"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.masonry &#123; display: flex; flex-flow: column wrap; width: 100%; height: auto; /*缺点：需要设置一个固定的height*/ @media screen and (min-width: 400px) &#123; height: 1600px; &#125; @media screen and (min-width: 600px) &#123; height: 1300px; &#125; @media screen and (min-width: 800px) &#123; height: 1100px; &#125; @media screen and (min-width: 1100px) &#123; height: 800px; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
        <tag>瀑布流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义scrollbar]]></title>
    <url>%2F2018%2F05%2F29%2FCSS-%E8%87%AA%E5%AE%9A%E4%B9%89webkit%E6%BB%91%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[一、滚动条相关伪元素 ::-webkit-scrollbar — 整个滚动条. ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头). ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块. ::-webkit-scrollbar-track — 滚动条轨道. ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分. ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分. ::-webkit-resizer — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮). 1234567891011121314151617181920/*定义滚动条高宽及背景高宽，分别对应横、竖滚动条的尺寸*/::-webkit-scrollbar &#123; width: 16px; height: 16px; background-color: #F5F5F5;&#125;/*定义滚动条轨道内阴影+圆角*/::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3); border-radius: 10px; background-color: #F5F5F5;&#125;/*定义滑块内阴影+圆角*/::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3); background-color: #555;&#125; 123456789101112131415161718192021222324252627282930/*类与伪元素搭配*/.sidebar &#123; position: fixed; border-right: 1px solid rgba(0,0,0,.07); overflow-y: auto; position: absolute; top: 0; bottom: 0; left: 0; transition: transform .25s ease-out; width: 300px; z-index: 3;&#125;.sidebar::-webkit-scrollbar &#123; width: 4px&#125;.sidebar::-webkit-scrollbar-thumb &#123; background: transparent; border-radius: 4px&#125;.sidebar:hover::-webkit-scrollbar-thumb &#123; background: hsla(0,0%,53%,.4)&#125;.sidebar:hover::-webkit-scrollbar-track &#123; background: hsla(0,0%,53%,.1)&#125; 二、滚动条相关伪类定义滚动条就是利用伪元素与伪类相互作用 1234567891011:horizontal //适用于任何水平方向上的滚动条:vertical //适用于任何垂直方向的滚动条:decrement //适用于按钮和轨道碎片。表示递减的按钮或轨道碎片:increment //适用于按钮和轨道碎片。表示递增的按钮或轨道碎片:start //适用于按钮和轨道碎片。表示对象（按钮轨道碎片）是否放在滑块的前面:end //适用于按钮和轨道碎片。表示对象（按钮轨道碎片）是否放在滑块的后面:double-button //适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。:single-button //适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。:no-button //表示轨道结束的位置没有按钮。:corner-present //表示滚动条的角落是否存在。:window-inactive //适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。 123456789::-webkit-scrollbar-track-piece:start &#123; /*滚动条上半边或左半边*/&#125;::-webkit-scrollbar-thumb:window-inactive &#123; /*当焦点不在当前区域滑块的状态*/&#125;::-webkit-scrollbar-button:horizontal:decrement:hover &#123; /*当鼠标在水平滚动条下面的按钮上的状态*/&#125; 三、IE滚动条 12345678910body &#123; scrollbar-base-color: #C0C0C0; scrollbar-base-color: #C0C0C0; scrollbar-3dlight-color: #C0C0C0; scrollbar-highlight-color: #C0C0C0; scrollbar-track-color: #EBEBEB; scrollbar-arrow-color: black; scrollbar-shadow-color: #C0C0C0; scrollbar-dark-shadow-color: #C0C0C0;&#125; 注：IE只能修改滚动条的颜色]]></content>
      <tags>
        <tag>css</tag>
        <tag>scrillbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[line-height继承问题]]></title>
    <url>%2F2018%2F05%2F27%2FCSS-line-height%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、line-height值 normal 默认。设置合理的行间距。 number 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。 length 设置固定的行间距。 % 基于当前字体尺寸的百分比行间距。 inherit 规定应该从父元素继承 line-height 属性的值。 注：normal我们常常认为它是（或者应该是）1或者1.2，甚至也可以说，CSS规范都不清楚是哪一个。 1normal: Tells user agents to set the used value to a &quot;reasonable&quot; value based on the font of the element. The value has the same meaning as &lt;number&gt;. We recommend a used value for &apos;normal&apos; between 1.0 to 1.2. The computed value is &apos;normal&apos;. 二、继承问题 如果父级的line-height属性值有单位或百分比，那么子级继承的值则是换算后的一个具体的px级别的值； 而如果父级的line-height属性值没有单位，则子级会直接继承这个“数值”，而非计算后的具体值，此时子级的line-height会根据本身的font-size值重新计算得到新的line-height值。 三、font-size 与line-height每个元素使用相同的font-size，但使用不同的font-family，但渲染出来的line-height是不同的。 CSS 权威指南基本视觉格式化一章中讲到：对于行内非替换元素或者匿名文本来说， font-size 指定了它们的 content area的高度，由于inline box 是由 content area 加上上下的 half-leading构成的，那么如果元素的leading为 0，在这种情况下，font-size 指定了inline box 的高度。 四、leading1、英文字体有基线（baseline）和中线（meanline），这两条线之间就是所谓的x-height，即小写字母x的高度。基线之上的部分是上伸区域（ascent），基线之下的部分是下伸区域（descent）。 2、两种说法 现代排版软件 ：两行文本的基线之间的距离是现代排版软件中所说的行距（leading） CSS ： leading = line-height - font-size]]></content>
      <tags>
        <tag>css</tag>
        <tag>line-height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整页滚动]]></title>
    <url>%2F2018%2F05%2F27%2FJS-%E6%95%B4%E9%A1%B5%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324let delay = 800;let pageHeight = 500;let preNow = new Date();let el = document.getElementById('demo');let scrollTop = el.scrollTop;el.addEventListener('scroll', myFunction);function myFunction(e) &#123; //节流计时器 let now = new Date(); if (now - preNow &gt; delay) &#123; preNow = now; if (el.scrollTop &gt; scrollTop) &#123; el.scrollTop += pageHeight; &#125; else &#123; if (el.scrollTop &lt; scrollTop) &#123; el.scrollTop -= pageHeight; &#125; &#125; scrollTop = el.scrollTop; &#125; else &#123; el.scrollTop = scrollTop; &#125;&#125;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-background-clip与background-origin]]></title>
    <url>%2F2018%2F05%2F25%2FCSS-background-clip%E4%B8%8Ebackground-origin%2F</url>
    <content type="text"><![CDATA[一、CSS3新属性在CSS2中，背景图片定义的位置是相对于其包含元素的填充(padding)的外部界限的，所有的溢出都会扩展到边框之下。CSS3引入了两个新的属性，可以对其进行更精细的控制。 第一个属性是：background-clip 第二个属性是：background-origin 对于这两个新属性，其对应的属性值是相同的：border-box, padding-box, content-box。它们的最根本的区别就是：background-clip 是对背景图片的裁剪，background-origin是对背景图片设置起始点&lt;/font&gt;。 对于background-clip, 其关键字是指将背景图片以border的尺寸、以padding的尺寸，以content的尺寸进行切割，其得到的结果是不完整的背景，也就是其中的一部分(原理与截图差不多)。而且有一点要注意，background-clip的切割是对这个容器背景的切割(包括图片与背景颜色)。 对于background-origin，其关键字是指将背景图片放置到border范围内，padding范围内、content范围内，其得到的结果是完整的背景(原理与图片的缩放相似)。与background-clip不同的是，它只是单纯设置背景图片的边界，并不会对背景颜色造成影响。 下面就拿其中一个属性对比一下：1234567891011121314151617181920212223/*Compare: background-clip:content-box background-origin:content-box*/div &#123; width: 400px; height: 400px; border: solid 10px; background-color: black; background-image: url(img.jpg); background-repeat: no-repeat; padding: 100px; background-clip: content-box;&#125;.clip &#123; background-clip: content-box;&#125;.origin &#123; background-origin: content-box;&#125; 初始状态： background-clip : content-box background-origin : content-box]]></content>
      <tags>
        <tag>css</tag>
        <tag>background-clip</tag>
        <tag>background-origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-background-position]]></title>
    <url>%2F2018%2F05%2F25%2FCSS-background-position%2F</url>
    <content type="text"><![CDATA[一、先上图 图片上的标注信息已经告诉大家很详细的信息了。示例中容器具备下述特性： div容器尺寸410px x 210px，边框宽度10px 容器背景图尺寸100px x 100px 第一张背景图background-position:10px 10px；第二张背景图background-position: center 其中黑白格子尺寸是10px x 10px 二、特别注意background-position取值除了长度值（）和关键词之外，还可以取值为百分比值。 当背景图片尺寸（background-size）不做任何的重置（也就是100% 100%）时，水平百分比的值等于容器宽度百分比值减去背景图片宽度百分比值。垂直百分比的值等于容器高度百分比值减去背景图片高度百分比值。比如前面的示例，如果取值background-position: 75% 50%;，背景图片的起始位置： 水平位置（x轴）：(410 - 100) * 75% = 232.5px 垂直位置（y轴）：(210 - 100) * 50% = 55px]]></content>
      <tags>
        <tag>css</tag>
        <tag>background-position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[offsetWidth和clientWidth]]></title>
    <url>%2F2018%2F05%2F24%2FJS-offsetWidth%E5%92%8CclientWidth%2F</url>
    <content type="text"><![CDATA[一、border-box模式offsetWidth = widthclientWidth = width - border - scrollBar注： Width:盒子css属性定义的宽度 Border:盒子边框的大小 scrollBar:盒子滚动条的宽度，默认17px]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>offsetWidth</tag>
        <tag>clientWidth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-滚动条跳动问题]]></title>
    <url>%2F2018%2F05%2F24%2FCSS-%E6%BB%9A%E5%8A%A8%E6%9D%A1%E8%B7%B3%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、问题描述 信息流页面是从上往下push渲染的。开始只有头部一些信息加载，此时页面高度有限，没有滚动条；然后，更多内容显示，滚动条出现，占据可用宽度，margin: 0 auto主体元素自然会做偏移——跳动产生。 二、利用calc和vw12345678.wrap-outer &#123; margin-left: calc(100vw - 100%);&#125;/*或者：*/.wrap-outer &#123; padding-left: calc(100vw - 100%);&#125; 100vw相对于浏览器的window.innerWidth，是浏览器的内部宽度，注意，滚动条宽度也计算在内！ 100%是可用宽度，是不含滚动条的宽度。 三、只利用vw1234.wrap-outer &#123; width: 100vw; overflow-x: hidden;&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>滚动条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-vw和100%]]></title>
    <url>%2F2018%2F05%2F24%2FCSS-vw%E5%92%8C100%2F</url>
    <content type="text"><![CDATA[100vw相对于浏览器的window.innerWidth，是浏览器的内部宽度，注意，滚动条宽度也计算在内！ 100%是可用宽度，是不含滚动条的宽度。]]></content>
      <tags>
        <tag>css</tag>
        <tag>vw</tag>
        <tag>100%</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-ECMAScript和JavaScript]]></title>
    <url>%2F2018%2F05%2F22%2FJS-ECMAScript%E5%92%8CJavaScript%2F</url>
    <content type="text"><![CDATA[由 ECMA-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系。实际上，这门语言本身并不包含输 入和输出定义。ECMA-262 定义的只是这门语言的基础，而在此基础之上可以构建更完善的脚本语言。 ECMAScript规定了这 门语言的下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述。JavaScript 实现了 ECMAScript， Adobe ActionScript 同样也实现了 ECMAScript。 我们常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。宿主环境不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript 的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他 宿主环境包括 Node（一种服务端 JavaScript 平台）和 Adobe Flash。 一个完整的 JavaScript 实现应该由下列三 个不同的部分组成 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM）]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-iframe]]></title>
    <url>%2F2018%2F05%2F21%2FHTML-iframe%2F</url>
    <content type="text"><![CDATA[一、通过window获取iframewindow.frames是个伪数组，可以通过window.frames[index]或window.frames[name]来获取iframe 二、通过iframe获取window、document如果想获取iframe里的window或者document，可以使用 iframe.contentWindow iframe.contentDocument 注：跨域iframe没有操作权限 三、window获取顶级窗口、父窗口 获取顶级窗口：window.top 获取父级窗口：window.parent]]></content>
      <tags>
        <tag>html</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-节点]]></title>
    <url>%2F2018%2F05%2F21%2FHTML-%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、节点类型节点分为不同的类型：元素节点、属性节点和文本节点等。文档里几乎每一样东西都是一个节点，甚至连空格和换行符都会解释为节点。属性节点和文本节点总是被包含在元素节点的内部。 style属性只能返回拿些内嵌在HTML内容里面的样式信息。]]></content>
      <tags>
        <tag>html</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防卫性编程]]></title>
    <url>%2F2018%2F05%2F18%2F%E9%98%B2%E5%8D%AB%E6%80%A7%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、边界清晰，御敌于国门之外在模块的边界处，无论别人调用你还是你调用别人，一定要明确约定调用规范，一旦违反规范，立即启用错误处理流程（注意不是防卫流程），不要让错误在自己的模块内部流窜。 二、不给错误做二传手如果发现错误，让错误到此为止，非必要不接力传递错误码。 三、当断则断，早死早超生所有程序的正确运行都是依赖于一定的前提条件的，如果你发现外部模块不工作了，遵从系统的错误处理策略，该报异常就报异常，该立即退出就退出，重要的是搜集好现场的证据。一味的容错处理既不能解决问题还会掩盖问题，导致错误扩散，变形，拖延定位问题的时机。]]></content>
      <tags>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-作用域链与闭包]]></title>
    <url>%2F2018%2F05%2F17%2FJS-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[一、执行环境(Execution Context)每一个执行环境都关联了一个变量对象(variable Object）或者活动对象（activation object）。环境中定义的所有变量和函数都保存在这个对象中。每个函数运行时都会产生一个执行环境。活动对象是一种特殊的变量对象。 全局执行环境关联的是变量对象，函数执行环境关联的是活动对象。可以将执行环境看作是一个对象： 12345EC = &#123; VO: &#123; /*执行环境关联的变量对象（variable object）*/ &#125; this: &#123;&#125;, Scope: &#123; /*作用域链*/ &#125;&#125; 二、执行环境栈当一个函数被调用时，函数执行环境就被压入一个环境栈中。而在函数执行之后，栈将该函数执行环境弹出，把控制权交给之前的执行环境。 举个例子： 12345678910111213let scope = "global";function fn1() &#123; return scope;&#125;function fn2() &#123; return scope;&#125;fn1();fn2(); 上面代码执行情况演示： 三、作用域链当某个函数第一次被调用时，就会创建一个执行环境(execution context)以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性([scope])。然后使用this，arguments和其他命名参数的值来初始化函数的活动对象(activation object)。当前执行环境的变量对象始终在作用域链的第0位。 以上面的代码为例，当第一次调用fn1()时的作用域链如下图所示： （因为fn2()还没有被调用，所以没有fn2的执行环境） 可以看到fn1活动对象里并没有scope变量，于是沿着作用域链(scope chain)向后寻找，结果在全局变量对象里找到了scope，所以就返回全局变量对象里的scope值。 标识符解析是沿着作用域链一级一级地搜索标识符地过程。搜索过程始终从作用域链地前端开始，然后逐级向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）—-《JavaScript高级程序设计》 再来看一段代码： 123456789101112function outer() &#123; let scope = "outer"; function inner() &#123; return scope; &#125; return inner;&#125;let fn = outer();fn(); outer()内部返回了一个inner函数，当调用outer时，inner函数的作用域链就已经被初始化了（复制父函数的作用域链，再在前端插入自己的活动对象），具体如下图： 一般来说，当某个环境中的所有代码执行完毕后，该环境被销毁（弹出环境栈），保存在其中的所有变量和函数也随之销毁。但是像上面那种有内部函数的又有所不同，当outer()函数执行结束，执行环境被销毁，但是其关联的活动对象并没有随之销毁，而是一直存在于内存中，因为该活动对象被其内部函数的作用域链所引用。 具体如下图： outer执行结束，内部函数开始被调用 。 outer执行环境等待被回收，outer的作用域链对全局变量对象和outer的活动对象引用都断了 。 像上面这种内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包(closure) 。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-代码异常监控]]></title>
    <url>%2F2018%2F05%2F16%2FJS-%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[一、window.onerror1window.onerror = function(message, source, lineno, colno, error) &#123; ... &#125; 函数参数： message：错误信息（字符串）。可用于HTML onerror=””处理程序中的event。 source：发生错误的脚本URL（字符串） lineno：发生错误的行号（数字） colno：发生错误的列号（数字） error：Error对象（对象） 若该函数返回true，则阻止执行默认事件处理函数。 二、window.addEventListener(‘error’)1window.addEventListener('error', function(event) &#123; ... &#125;) **ErrorEvent 类型的event包含有关事件和错误的所有信息。 1234567891011window.onerror = function(msg, url, lineNo, columnNo, error) &#123; var message = [ 'Message: ' + msg, 'URL: ' + url, 'Line: ' + lineNo, 'Column: ' + columnNo, 'Error object: ' + JSON.stringify(error) ].join(' - '); console.log(message);&#125;;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>异常监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-blend-mode]]></title>
    <url>%2F2018%2F05%2F15%2FCSS-blend-mode%2F</url>
    <content type="text"><![CDATA[一、mix-blend-mode描述了元素的内容应该如何与元素的直接父元素和元素的背景混合。 12345678910111213141516171819mix-blend-mode: normal; //正常mix-blend-mode: multiply; //正片叠底mix-blend-mode: screen; //滤色mix-blend-mode: overlay; //叠加mix-blend-mode: darken; //变暗mix-blend-mode: lighten; //变亮mix-blend-mode: color-dodge; //颜色减淡mix-blend-mode: color-burn; //颜色加深mix-blend-mode: hard-light; //强光mix-blend-mode: soft-light; //柔光mix-blend-mode: difference; //差值mix-blend-mode: exclusion; //排除mix-blend-mode: hue; //色相mix-blend-mode: saturation; //饱和度mix-blend-mode: color; //颜色mix-blend-mode: luminosity; //亮度mix-blend-mode: initial; //初始mix-blend-mode: inherit; //继承mix-blend-mode: unset; //复原 二、background-blend-mode定义该元素的背景图片，以及背景色如何混合，属性值和mix-blend-mode一样。]]></content>
      <tags>
        <tag>css</tag>
        <tag>background-blend-mode</tag>
        <tag>mix-blend-mode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-linear-gradient]]></title>
    <url>%2F2018%2F05%2F15%2FCSS-linear-gradient%2F</url>
    <content type="text"><![CDATA[一、语法1background-image: linear-gradient([&lt;angle&gt;|&lt;side-or-corner&gt;,]?&lt;color-stop&gt;[,&lt;color-stop&gt;]+); []在正则中表示一个字符类，这里，你可以理解为一个小单元。 |表示候选。也就是“或者”的意思，要么前面的，要么就后面的。 ?为量词，表示0个或1个。 +也是量词，表示1个或者更多个。因此，终止颜色是不可缺少的。 &lt;&gt;中的是关键字，主要是让开发人员知道这里应该放些什么内容。 二、angle C点渐变容器中心点，A是过C点垂直线与过C点渐变线的夹角，这个角称为渐变角度。 三、side-or-cornerside-or-corner中文意思就是“边或角”，可选值有： [left | right] || [top | bottom]，有如下的写法或组合： left, right, top, bottom, left top, left bottom, right top, right bottom. 分别表示，从左往右，从右往左，从上往下，从下往上，从左上往右下，从…… 四、color-stop渐变关键颜色结点，语法为： [ | ] 五、角度坐标与位置关系对于斜向线性渐变，点到点的渐变不是直接把点的横坐标放上去就可以的。因为当渐变倾斜的时候，渐变的起止点的坐标也发生变化了。下图是官方规范的一张示意图，演示的是45deg渐变的起止点以及方向。 记住一个关键点，渐变的起点和终点（默认）在过中心的渐变线的垂直线上，于是，我们就可以确定起点与终点的位置了。按照这个理解，我们就可以画出400*300 div上135deg起始点在哪里，然后再确定(100,100)和(200,200)的位置就轻松多了。如下示意图： 一图顶前言，反正上面这张图我是看懂了。于是，我们的坐标起止点值其实就变成了，黑色括弧的长度以及紫色括弧的长度值分别多少！虽然很多人不喜欢数学，但是几何应该都还不错，我们来一起算一下…… 结果为，起点： 1100 * Math.sqrt(2) = 141.4213562373095; 终点为： 1200 * Math.sqrt(2) = 282.842712474619; CSS用上： 123&#123; background-image: linear-gradient(135deg, red 141.42px, yellow 282.84px);&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>linear-gradient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[drop-shadow与box-shadow]]></title>
    <url>%2F2018%2F05%2F15%2FCSS-drop-shadow%E4%B8%8Ebox-shadow%2F</url>
    <content type="text"><![CDATA[一、区别 drop-shadow没有内阴影效果 drop-shadow不能阴影叠加 drop-shadow穿透代码构建的元素的透明部分 drop-shadow 也可以穿透PNG图片的透明部分 可以利用这个特性实现css 改变图片颜色 二、利用box-shadow实现遮罩层123456789101112131415161718192021.spectiveBlur &#123; position: absolute; top: 50%; left: 50%; width: 220px; line-height: 160px; transform: translate(-50%, -50%); border-radius: 10px; overflow: hidden; background: #E91E63; color: #fff; font-size: 200%; text-align: center; cursor: pointer; transition: transform .2s;&#125;.spectiveBlur:hover &#123; box-shadow: 0 0 0 1920px rgba(0, 0, 0, .7); transform: translate(-50%, -50%) scale(1.2);&#125;]]></content>
      <tags>
        <tag>css</tag>
        <tag>drop-shadow</tag>
        <tag>box-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-dataTransfer拖拽]]></title>
    <url>%2F2018%2F05%2F09%2FJS-dataTransfer%E6%8B%96%E6%8B%BD%2F</url>
    <content type="text"><![CDATA[一、对象方法123var dsHandler = function(evt) &#123; evt.dataTransfer.setData("text/plain", "&lt;item&gt;" + evt.target.innerHTML);&#125; setData(format,data): ​ 将指定格式的数据赋值给dataTransfer对象 参数format定义数据的格式也就是数据的类型，data为待赋值的数据 getData(format): 从dataTransfer对象中获取指定格式的数据，format代表数据格式，data为数据。 clearData([format]): 从dataTransfer对象中删除指定格式的数据，参数可选。 若不给出，则为删除对象中所有的数据]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>dataTransfer</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-几个好用的属性]]></title>
    <url>%2F2018%2F05%2F08%2FCSS-%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.attr123456&lt;p data-unit="元"&gt;剩余话费40&lt;/p&gt;[data-unit]:after &#123; content: attr(data-unit); color: #3b98e0;&#125; 2. currentColor是color属性的值123456.box &#123; width: 200px; height: 200px; color: #3b98e0; border: 1px solid currentColor;&#125; 3.user-select 禁止选择文本12345.box-1 &#123; -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125; 4.selection 可设置文字被选择时的样式1234::selection &#123; background: #FE6E66; color: #FFF;&#125; 只能向 ::selection 选择器应用少量 CSS 属性：color、background、cursor 以及 outline。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-object-fit]]></title>
    <url>%2F2018%2F05%2F08%2FCSS-object-fit%2F</url>
    <content type="text"><![CDATA[一、定义123object-fit : css property specifies how the contents of a replaced element should be fitted to the box established by its used height and width.object-position : css property determines the alignment of the replaced element inside its box. 这里的object实际上指的是replaced element 。 二、替换元素 其内容不受CSS视觉格式化模型控制的元素。 比如image, 嵌入的文档(iframe之类)或者applet。 比如，img元素的内容通常会被其src属性指定的图像替换掉。 替换元素通常有其固有的尺寸：一个固有的宽度，一个固有的高度和一个固有的比率。比如一幅位图有固有用绝对单位指定的宽度和高度，从而也有固有的宽高比率。另一方面，其他文档也可能没有固有的尺寸，比如一个空白的html文档。 CSS渲染模型不考虑替换元素内容的渲染。这些替换元素的展现独立于CSS。object, video, textarea, input也是替换元素，audio和canvas在某些特定情形下为替换元素。 使用CSS的content属性插入的对象是匿名替换元素。 三、object-fitobject-fit具体有5个值： fill: 默认值，替换内容拉伸填满整个content box，不保证保持原有的比例 contain: 保持原有尺寸比例，保证替换内容尺寸一定可以在容器里面放得下 cover:保持原有尺寸比例，保证替换内容尺寸一定大于容器尺寸，宽度和高度至少有一个和容器一致 none: 保持原有尺寸比例，同时保持替换内容原始尺寸大小 scale-down: 好像依次设置了none或contain，最终呈现的是尺寸比较小的那个 四、深入理解一个图片，如果没有src，它依然是个替换元素，它在浏览器中的解析依然是正确的。 src指向的图片属于替换内容，注意，替换内容和替换元素是壳子与内容的关系，两者是独立的。 在CSS2.1时代，壳子的实际尺寸（如果没有CSS或HTML设置），则是跟随内容的实际尺寸，因此，网页加载的时候，我们会看到图片占据的高度从0到图片实际高度跳动的过程； 如果壳子，也就是img有尺寸限制，则替换内容fill拉伸适应于 img替换元素的设定尺寸。总而言之，壳子与内容的尺寸永远是一样的。于是，我们就会误认为图片就是那个图片，唯一的存在，导致我们理解object-fit的特性表现出现了障碍。 在CSS3时代，object-fit的世界里，object-fit控制的永远是替换内容的尺寸表现，注意，是替换内容的尺寸表现，不是img替换元素。 五、object-positionobject-position要比object-fit单纯的多，就是控制替换内容位置的。默认值是50% 50%。 与background-position类似，object-position的值类型为类型值。]]></content>
      <tags>
        <tag>css</tag>
        <tag>object-fit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-调用摄像头]]></title>
    <url>%2F2018%2F05%2F08%2FJS-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[一、用法1234567navigator.mediaDevices.getUserMedia(constraints) .then(function(stream) &#123; /* 使用这个stream stream */ &#125;) .catch(function(err) &#123; /* 处理error */ &#125;); MediaDevices.getUserMedia()会提示用户给予使用媒体输入的许可。它返回一个 Promise 对象，成功后会resolve回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise会reject回调一个 PermissionDeniedError 或者 NotFoundError 。 二、参数Constraints 以下同时请求不带任何参数的音频和视频： 1234&#123; audio: true, video: true&#125; 当由于隐私保护的原因，无法访问用户的摄像头和麦克风信息时，应用可以使用额外的constraints参数请求它所需要或者想要的摄像头和麦克风能力。下面演示了应用想要使用1280x720的摄像头分辨率： 12345678&#123; audio: true, video: &#123; width: 1280, height: 720 &#125;&#125; 浏览器会试着满足这个请求参数，但是如果无法准确满足此请求中参数要求或者用户选择覆盖了请求中的参数时，有可能返回其它的分辨率。 强制要求获取特定的尺寸时，可以使用关键字min, max, 或者 exact(就是 min == max). 以下参数表示要求获取最低为1280x720的分辨率。 1234567891011121314&#123; audio: true, video: &#123; width: &#123; min: 1280 &#125;, height: &#123; min: 720 &#125; &#125;&#125; 如果摄像头不支持请求的或者更高的分辨率，返回的Promise会处于rejected状态，NotFoundError作为rejected回调的参数，而且用户将不会得到要求授权的提示。 当请求包含一个ideal（应用最理想的）值时，这个值有着更高的权重，意味着浏览器会先尝试找到最接近指定的理想值的设定或者摄像头（如果设备拥有不止一个摄像头）。 123456789101112131415161718&#123; audio: true, video: &#123; width: &#123; min: 1024, ideal: 1280, max: 1920 &#125;, height: &#123; min: 776, ideal: 720, max: 1080 &#125; &#125;&#125; 并不是所有的constraints 都是数字。例如, 在移动设备上面，如下的例子表示优先使用前置摄像头： 1234567&#123; audio: true, video: &#123; facingMode: "user" &#125;&#125; 强制使用后置摄像头，请用： 12345678910&#123; audio: true, video: &#123; facingMode: &#123; exact: "environment" &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style type="text/css"&gt; body &#123; display: flex; justify-content: center; flex-wrap: wrap; align-items: center; &#125; video &#123; width: 100vw; height: 60vw; &#125; button &#123; display: inline-block; width: 200px; line-height: 2; font-size: 20px; margin: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;video controls&gt;&lt;/video&gt; &lt;button onclick="setFront()"&gt;front&lt;/button&gt; &lt;button onclick="setRear()"&gt;rear&lt;/button&gt; &lt;button onclick="pause()"&gt;stop&lt;/button&gt; &lt;script&gt; let constraints = &#123; audio: true, video: true &#125;; let recorder = null; let video = null; function pause() &#123; recorder.stop(); &#125; function setFront() &#123; constraints = &#123; audio: true, video: &#123; facingMode: "user" &#125; &#125;; author(); &#125; function setRear() &#123; constraints = &#123; audio: true, video: &#123; facingMode: &#123; exact: "environment" &#125; &#125; &#125;; author(); &#125; function author() &#123; constraints.video.frameRate = &#123; ideal: 10, max: 15 &#125;; navigator.mediaDevices.getUserMedia(constraints) .then(function(mediaStream) &#123; console.log('mediaStream') video = document.querySelector('video'); video.src = URL.createObjectURL(mediaStream); video.onloadedmetadata = function(e) &#123; recorder = new MediaRecorder(mediaStream); recorder.ondataavailable = function() &#123; video.pause(); video.src = URL.createObjectURL(event.data); video.onloadedmetadata = function(e) &#123; video.play(); &#125;; &#125; video.play(); recorder.start(); &#125;; &#125;) .catch(function(err) &#123; console.log(err.name + ": " + err.message); &#125;); &#125; author(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>摄像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-标签语句]]></title>
    <url>%2F2018%2F05%2F07%2FJS-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[12345678910111213//label: statement;outPoint: if (true) &#123; for (var j = 0; j &lt; all.length; j++) &#123; for (var k = 0; k &lt; all[j].length; k++) &#123; if (all[j][k].id == itemsId[i]) &#123; console.log(all[j][k]); break outPoint; //直接跳出最外层循环 &#125; &#125; &#125; &#125; JavaScript中任何地方都可以定义语句标签 break和continue是JavaScript中唯一可以使用语句标签的语句 控制权无法越过函数的边界]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-ln链接]]></title>
    <url>%2F2018%2F04%2F30%2Flinux-ln%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[一、使用方式：ln [option] source_file dist_file -f 建立时，将同档案名删除 -i 删除前进行询问 12345#建立abc的软连接 ln -s abc cde#建立abc的硬连接ln abc cde 二、软链接与硬链接的区别硬链接可认为是一个文件拥有两个文件名，而软链接则是系统新建一个链接文件，此文件指向其所要指的文件 1ln -s /root/lntest/source/ /root/lntest/dist/ （1）软连接可以跨文件系统 ，硬连接不可以 。实践的方法就是用共享文件把windows下的 aa.txt文本文档连接到linux下/root目录下。ln -s aa.txt /root连接成功 。ln aa.txt /root失败 。 （2）关于 I节点的问题 。硬连接不管有多少个，都指向的是同一个I节点，会把 结点连接数增加，只要结点的连接数不是 0，文件就一直存在，不管你删除的是源文件还是 连接的文件 。只要有一个存在 ，文件就存在（其实也不分什么源文件连接文件的 ，因为他们指向都是同一个 I节点）。 当你修改源文件或者连接文件任何一个的时候 ，其他的文件都会做同步的修改。 （3）软链接不直接使用i节点号作为文件指针,而是使用文件路径名作为指针。所以删除连接文件对源文件无影响，但是删除源文件，连接文件就会找不到要指向的文件 。软链接有自己的inode,并在磁盘上有一小片空间存放路径名. ​]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ln</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-replace]]></title>
    <url>%2F2018%2F04%2F29%2FJS-replace%2F</url>
    <content type="text"><![CDATA[一、语法1stringObject.replace(regexp/substr,replacement); 在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 二、replacement作为函数replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 123456789101112name = "Doe, John";name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");let _dete = '20180408000000'function formatStr(str, type) &#123; let i = 0, _type = type || "xxxx-xx-xx xx:xx:xx"; return _type.replace(/x/g, () =&gt; str[i++]);&#125;formatStr(_dete);result: "2018-04-08 00:00:00"]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>replace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-开放封闭原则]]></title>
    <url>%2F2018%2F04%2F29%2FJS-%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[一、两个主要特性 它们 “面向扩展开放（Open For Extension）”。 模块的行为是能够被扩展的。当应用程序的需求变化时，我们可以使模块表现出全新的或与以往不同的行为，以满足新的需求。 它们 “面向修改封闭（Closed For Modification）”。 模块的源代码是不能被侵犯的，任何人都不允许修改已有源代码。 123456789101112131415161718192021222324252627//检测字符串//checkType('165226226326','mobile')let checkType = function(str, type) &#123; switch (type) &#123; case 'email': return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case 'mobile': return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str); case 'tel': return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str); case 'number': return /^[0-9]$/.test(str); case 'english': return /^[a-zA-Z]+$/.test(str); case 'text': return /^\w+$/.test(str); case 'chinese': return /^[\u4E00-\u9FA5]+$/.test(str); case 'lower': return /^[a-z]+$/.test(str); case 'upper': return /^[A-Z]+$/.test(str); default: return true; &#125;&#125; 这个 API 看着没什么毛病，能检测常用的一些数据。但是有以下两个问题。 但是如果想到添加其他规则的呢？就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。 还有一个问题就是，比如A页面需要添加一个金额的校验，B页面需要一个日期的校验，但是金额的校验只在A页面需要，日期的校验只在B页面需要。如果一直添加 case 。就是导致A页面把只在B页面需要的校验规则也添加进去，造成不必要的开销。B页面也同理。 建议的方式是给这个 API 增加一个扩展的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let checkType = (function() &#123; let rules = &#123; email(str) &#123; return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); &#125;, mobile(str) &#123; return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str); &#125;, tel(str) &#123; return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str); &#125;, number(str) &#123; return /^[0-9]$/.test(str); &#125;, english(str) &#123; return /^[a-zA-Z]+$/.test(str); &#125;, text(str) &#123; return /^\w+$/.test(str); &#125;, chinese(str) &#123; return /^[\u4E00-\u9FA5]+$/.test(str); &#125;, lower(str) &#123; return /^[a-z]+$/.test(str); &#125;, upper(str) &#123; return /^[A-Z]+$/.test(str); &#125; &#125;; //暴露接口 return &#123; //校验 check(str, type) &#123; return rules[type] ? rules[type](str) : false; &#125;, //添加规则 addRule(type, fn) &#123; rules[type] = fn; &#125; &#125;&#125;)();//调用方式//使用mobile校验规则console.log(checkType.check('188170239', 'mobile'));//添加金额校验规则checkType.addRule('money', function(str) &#123; return /^[0-9]+(.[0-9]&#123;2&#125;)?$/.test(str)&#125;);//使用金额校验规则console.log(checkType.check('18.36', 'money'));]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-加载模块]]></title>
    <url>%2F2018%2F04%2F29%2FJS-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425//防止多文件集成成一个文件后 前面的文件忘记写；的情况;(function(factory) &#123; var registeredInModuleLoader; if (typeof define === 'function' &amp;&amp; define.amd) &#123; console.log('a') define(factory); registeredInModuleLoader = true; &#125; if (typeof exports === 'object') &#123; console.log('b') module.exports = factory(); registeredInModuleLoader = true; &#125; if (!registeredInModuleLoader) &#123; console.log('c') var OldCookies = window.Cookies; var api = window.Cookies = factory(); api.noConflict = function() &#123; window.Cookies = OldCookies; return api; &#125;; &#125; &#125;(function() &#123; return &#123; a: 1 &#125; &#125;));]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-函数单一职责原则]]></title>
    <url>%2F2018%2F04%2F29%2FJS-%E5%87%BD%E6%95%B0%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[​ 函数违反单一原则最大一个后果就是会导致逻辑混乱。如果一个函数承担了太多的职责。 不妨试下：函数单一原则 – 一个函数只做一件事 。 埋头就是干：1234567891011121314//图片预加载函数let delayload = (function() &#123; let img = document.querySelector("#img"); img.src = "loading.gif"; let newImg = document.createElement("img"); newImg.onload = function() &#123; img.src = newImg.src; &#125; return function(src) &#123; newImg.src = src; &#125;&#125;)();delayload("jimmy.jpg"); 遵循一个函数只做一件事后：12345678910111213141516171819202122232425//将背景图设置，和图片加载的src修改分开let delayload = (function() &#123; let img = document.querySelector("#img"); img.src = "loading.gif"; return &#123; setSrc: function(src) &#123; img.src = src; &#125; &#125;&#125;)();let proxy = (function() &#123; let img = document.createElement('img'); img.onload = function() &#123; delayload.setSrc(img.src); &#125; return &#123; setSrc: function(src) &#123; img.src = src; &#125; &#125;&#125;)();proxy.setSrc("jimmy.jpg");]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>单一职责</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass入门语法]]></title>
    <url>%2F2018%2F04%2F25%2FSass%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、变量123456789101112$fontStack : Helvetica,sans-serif;$primaryColor: #333;body &#123; font-family: $fontStack; color: $primaryColor;&#125;/*编译结果*/body &#123; font-family: Helvetica, sans-serif; color: #333;&#125; 二、嵌套12345678910111213141516171819202122232425262728293031323334nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125;/*编译结果*/nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; 三、mixin123456789101112131415161718@mixin box-sizing ($sizing) &#123; -webkit-box-sizing: $sizing; -moz-box-sizing: $sizing; box-sizing: $sizing;&#125;.box-border &#123; border: 1px solid #ccc; @include box-sizing(border-box);&#125;/*编译结果*/.box-border &#123; border: 1px solid #ccc; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 1234567891011@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; 为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成： 12345678=apply-to-ie6-only * html @content+apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。 四、扩展/继承123456789101112131415161718192021222324252627282930313233343536373839.message &#123; border: 1px solid #ccc; padding: 10px; color: #333;&#125;.success &#123; @extend .message; border-color: green;&#125;.error &#123; @extend .message; border-color: red;&#125;.warning &#123; @extend .message; border-color: yellow;&#125;/*编译结果*/.message, .success, .error, .warning &#123; border: 1px solid #cccccc; padding: 10px; color: #333;&#125;.success &#123; border-color: green;&#125;.error &#123; border-color: red;&#125;.warning &#123; border-color: yellow;&#125; 五、运算12345678910111213141516171819202122232425262728.container &#123; width: 100%;&#125;article[role="main"] &#123; float: left; width: 600px / 960px * 100%;&#125;aside[role="complimentary"] &#123; float: right; width: 300px / 960px * 100%;&#125;/*编译结果*/.container &#123; width: 100%;&#125;article[role="main"] &#123; float: left; width: 62.5%;&#125;aside[role="complimentary"] &#123; float: right; width: 31.25%;&#125;]]></content>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[庞氏骗局]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%BA%9E%E6%B0%8F%E9%AA%97%E5%B1%80%2F</url>
    <content type="text"><![CDATA[金融有一个很重要的原则，应该是金融守恒，金融是一个守恒零和游戏。资金在流动的过程中，价值不会无缘无故产生，也不会无缘无故消失。真正产生价值的应该是制造业。只有实业，在生产经营的过程中才产生财富。因此，金融和实业之间的关系应该是，金融帮助实业提高效率，实业帮助金融创造价值。 将新投资人的钱向老投资者支付利息和短期回报以造成骗局赚钱的假象从而吸引更多投资者进入骗局 庞氏骗局，一般人说就是“拆东墙补西墙”。利用新投资人的钱来向老投资者支付利息和短期回报，以制造赚钱的假象进而骗取更多的投资。而这种拆东补西的做法，本身不一定是错的。因为这就是金融。 拿了钱却做不到这个承诺回报的收益，那就是骗局了。 是否骗局，最大的导向点在于最上线。最上线如果一直稳如泰山，那就不是骗局 庞氏骗局在中国又称“拆东墙补西墙”，“空手套白狼”。简言之就是利用新投资人的钱来向老投资者支付利息和短期回报，以制造赚钱的假象进而骗取更多的投资。]]></content>
      <tags>
        <tag>庞氏骗局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-作用域插槽]]></title>
    <url>%2F2018%2F04%2F17%2FVue-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[作用域插槽是一种特殊类型的插槽，用作一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将 prop 传递数据给子组件一样，传递到父组件： 123&lt;div class="child"&gt; &lt;slot text="hello from child"&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊特性 slot-scope 的 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象： 12345678&lt;div class="parent"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 如果我们渲染上述模板，得到的输出会是： 123456&lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>vue</tag>
        <tag>插槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-检测字体]]></title>
    <url>%2F2018%2F04%2F15%2FJS-%E6%A3%80%E6%B5%8B%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[一、实现原理根据用户设置的字体将某一个字符绘制在canvas上（fillText()），并提取像素信息（getImageData()），然后和默认字体进行比对，如果像素不一致，说明字体生效，说明字体不生效。 12345678910111213141516171819202122232425262728293031323334353637383940414243let isSupportFontFamily = function(fontFamily) &#123; if (typeof fontFamily !== 'string') &#123; return false; &#125; let defaultFontFamily = 'Arial'; if (fontFamily.toLowerCase() === defaultFontFamily.toLowerCase()) &#123; return true; &#125; let defaultLetter = 'a'; let defaultFontSize = 100; // 使用该字体绘制的canvas let width = 100; let height = 100; let canvas = document.createElement('canvas'); let context = canvas.getContext('2d'); canvas.width = width; canvas.height = height; // 全局一致的绘制设定 context.textAlign = 'center'; context.fillStyle = 'black'; context.textBaseline = 'middle'; let getFontData = function(fontFamily) &#123; context.clearRect(0, 0, width, height); context.font = defaultFontSize + 'px ' + fontFamily + ', ' + defaultFontFamily; context.fillText(defaultLetter, width / 2, height / 2); let data = context.getImageData(0, 0, width, height).data; return [].slice.call(data).filter(function(value) &#123; return value !== 0; &#125;); &#125;; return getFontData(defaultFontFamily).join('') !== getFontData(fontFamily).join('');&#125;;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-帆布指纹识别]]></title>
    <url>%2F2018%2F04%2F14%2FJS-%E5%B8%86%E5%B8%83%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一、利用canvas标签一般情况下，网站或者广告联盟都会非常想要一种技术方式可以在网络上精确定位到每一个个体，这样可以通过收集这些个体的数据，通过分析后更加精准的去推送广告（精准化营销）或其他有针对性的一些活动。 Cookie技术是非常受欢迎的一种。当用户访问一个网站时，网站可以在用户当前的浏览器Cookie中永久植入一个含有唯一标示符（UUID）的信息，并通过这个信息将用户所有行为关联起来。 帆布指纹识别使用到了HTML5标签的一个特点：在绘制canvas图片时，同样的canvas绘制代码，不同机器和浏览器绘制的图片特征是相同并且独一无二的，这样以来，提取最简单的md5值便可以唯一标识和跟踪这个用户。 12345678910111213var canvas = document.createElement('canvas');var ctx = canvas.getContext('2d');var txt = 'http://security.tencent.com/';ctx.textBaseline = "top";ctx.font = "14px 'Arial'";ctx.textBaseline = "tencent";ctx.fillStyle = "#f60";ctx.fillRect(125,1,62,20);ctx.fillStyle = "#069";ctx.fillText(txt, 2, 15);ctx.fillStyle = "rgba(102, 204, 0, 0.7)";ctx.fillText(txt, 4, 17);var b64 = canvas.toDataURL().replace("data:image/png;base64,",""); 二、配合navigator和screen等属性 navigator.userAgent navigator.mimeTypes navigator.plugins navigator.language screen.height screen.width screen.colorDepth window.devicePixelRatio 检测已安装的字体种类 注:使用hash获取字符标识，封装得比较好的框架 fingerprintjs 三、应用除了可以追踪用户习惯，还可以用来防止用户信息受XSS攻击影响。一般用户的登录状态使用cookie记录，如果被黑客使用XSS攻击或者其他途径获取，可以使用UUID和cookie来做双重验证。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-事务]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务控制语句 BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT或COMMIT WORK，COMMIT提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK或ROLLBACK WORK，结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 123456789101112131415begin; # 开始事务insert into runoob_transaction_test value(5);insert into runoob_transaction_test value(6);commit; # 提交事务begin; # 开始事务insert into runoob_transaction_test values(7);rollback; # 回滚select * from runoob_transaction_test; # 因为回滚所以数据没有插入+------+| id |+------+| 5 || 6 |+------+]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-regexp]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-regexp%2F</url>
    <content type="text"><![CDATA[REGEXP 操作符 模式 描述 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配&#39;\n&#39;或&#39;\r&#39; 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$也匹配 &#39;\n&#39;或&#39;\r&#39;之前的位置。 . 匹配除&quot;\n&quot;之外的任何单个字符。要匹配包括 &#39;\n&#39;在内的任何字符，请使用象 &#39;[.\n]&#39;的模式。 [...] 字符集合。匹配所包含的任意一个字符。例如， &#39;[abc]&#39;可以匹配 &quot;plain&quot;中的&#39;a&#39;。 [^...] 负值字符集合。匹配未包含的任意字符。 `p1\ p2\ p3` 匹配 p1 或 p2 或 p3。例如，`’z\ food’ 能匹配“z” 或“food”。‘(z\ f)ood’ 则匹配“zood” 或“food”`。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配&quot;z&quot;以及 &quot;zoo&quot;。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，&#39;zo+&#39;能匹配 &quot;zo&quot;以及&quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于{1,}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，&#39;o{2}&#39; 不能匹配 &quot;Bob&quot;中的 &#39;o&#39;，但是能匹配 &quot;food&quot; 中的两个 o。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 12-- 查找name字段中以元音字符开头或以&apos;ok&apos;字符串结尾的所有数据SELECT name FROM person_tbl WHERE name REGEXP &apos;^[aeiou]|ok$&apos;;]]></content>
      <tags>
        <tag>正则表达式</tag>
        <tag>mysql</tag>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-limit-offset]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-limit-offset%2F</url>
    <content type="text"><![CDATA[1select _column,_column from _table [where Clause] [limit N][offset M] limit N : 返回 N 条记录 offset M : 跳过 M 条记录, 默认 M=0 limit N offset M :从第 M条记录开始, 返回N 条记录 limit M,N : 相当于 limit N offset M , 从第 M 条记录开始, 返回 N 条记录]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>limit</tag>
        <tag>offset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-where比较运算]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-where%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[一、运算符 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 And 同时满足两个条件的值 Or 满足其中一个条件的值 Not 满足不包含该条件的值 is null 空值判断 between and 在某个范围内 LIKE 模糊查询（ % 表示多个字值，_下划线表示一个字符； ） IN 指定针对某个列的多个可能值 二、通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列 12345-- LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串-- LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称-- LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson-- LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称-- LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称 三、例子1234567891011121314151617181920212223-- 搜索 empno 等于 7900 的数据Select * from emp where empno=7900;-- SMITH 用单引号引起来，表示是字符串，字符串要区分大小写-- 使用 BINARY 关键字来设定WHERE子句的字符串比较是区分大小写的Select * from emp where ename=&apos;SMITH&apos;;SELECT * from emp WHERE BINARY ename=&apos;SMITH&apos;;Select * from emp where sal &gt; 2000 and sal &lt; 3000;Select * from emp where sal &gt; 2000 or comm &gt; 500;select * from emp where not sal &gt; 1500;-- 查询 emp 表中 comm 列中的空值Select * from emp where comm is null;-- 大于等于 1500 且小于等于 3000Select * from emp where sal between 1500 and 3000;-- 查询 EMP 表 SAL 列中等于 5000，3000，1500 的值Select * from emp where sal in (5000,3000,1500);-- Like模糊查询Select * from emp where ename like &apos;_M%&apos;; 四、不带比较运算符WHERE子句并不一定带比较运算符，当不带运算符时，会执行一个隐式转换。当0时转化为 false，当其他值是转化为true。 123456-- 返回一个空集，因为每一行记录WHERE都返回falseSELECT studentNO FROM student WHERE 0;-- 返回student表所有行记录的studentNO列。因为每一行记录WHERE都返回true。SELECT studentNO FROM student WHERE 1;SELECT studentNO FROM student WHERE &apos;abc&apos;;]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>where</tag>
        <tag>运算符</tag>
        <tag>通配符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-If-Not-Exists]]></title>
    <url>%2F2018%2F04%2F14%2Fmysql-If-Not-Exists%2F</url>
    <content type="text"><![CDATA[一、创建数据库1CREATE DATABASE IF NOT EXISTS RUNOOB DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 数据库的校验规则 utf8_bin：将字符串中的每一个字符用二进制数据存储，大小写敏感 utf8_genera_ci：大小写不敏感（ci:case insensitive） utf8_general_cs：大小写敏感（cs:case sensitive） 二、创建数据表1234567CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8; ENGINE=InnoDB：使用innodb引擎 三、判断数据库存在, 则删除1drop database if exists db_name; 四、判断数据表存在, 则删除1drop table if exists table_name;]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>If-Not-Exists</tag>
        <tag>If-Exists</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2-cookie]]></title>
    <url>%2F2018%2F04%2F12%2Fkoa2-cookie%2F</url>
    <content type="text"><![CDATA[koa 提供了从上下文直接读取、写入 cookie 的方法 12ctx.cookies.get(name, [options]) // 读取上下文请求中的 cookiectx.cookies.set(name, value, [options]) //在上下文中写入 cookie options 的配置如下： signed：cookie 是否加密（如果加密的话必须用 app.keys 指定加密短语） maxAge：cookie 有效时长 expires：cookie 何时过期 path：cookie 的路径，默认为 ‘/’ domain：cookie 的域名 secure：cookie 是否只有 https 请求下才发送 httpOnly：是否只有服务器可以去到 cookie，默认为 true overwrite：是否允许重写 12345678910111213141516171819202122232425262728293031const Koa = require('koa');const app = new Koa();// 指定加密短语app.keys = ['secret1', 'secret2'];app.use(async (ctx) =&gt; &#123; if(ctx.url === '/index')&#123; ctx.cookies.set( 'cid', 'hello worls', &#123; signed:true, domain: '127.0.0.1', path: '/index', maxAge: 10 * 60 * 1000, expores: new Date('2017-09-09'), httpOnly: false, overwrite: false, secure: false &#125; ); ctx.body = 'cookies is ok'; &#125; else &#123; ctx.body = 'hello world'; &#125;&#125;);app.listen(3000, () =&gt; &#123; console.log('[demo] cookie is starting at port 3000')&#125;)]]></content>
      <tags>
        <tag>koa2</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2-获取请求数据]]></title>
    <url>%2F2018%2F04%2F12%2Fkoa2-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[零、对象ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象。 同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP请求对象。 一、GET请求在koa中，获取GET请求数据源头是koa中request对象中的query方法或querystring方法。query返回是格式化好的参数对象，querystring返回的是请求字符串。 1234567891011121314151617181920212223242526const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; let url = ctx.url // 从上下文的request对象中获取 let request = ctx.request let req_query = request.query let req_querystring = request.querystring // 从上下文中直接获取 let ctx_query = ctx.query let ctx_querystring = ctx.querystring ctx.body = &#123; url, req_query, req_querystring, ctx_query, ctx_querystring &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('[demo] request get is starting at port 3000')&#125;) 二、post请求对于POST请求的处理，koa2没有封装获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req，将POST表单数据解析成query string（例如：a=1&amp;b=2&amp;c=3），再将query string 解析成JSON格式（例如：{“a”:”1”, “b”:”2”, “c”:”3”}） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === '/' &amp;&amp; ctx.method === 'GET' ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method="POST" action="/"&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name="userName" /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name="nickName" /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name="email" /&gt;&lt;br/&gt; &lt;button type="submit"&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === '/' &amp;&amp; ctx.method === 'POST' ) &#123; // 当POST请求的时候，解析POST表单里的数据，并显示出来 let postData = await parsePostData( ctx ) ctx.body = postData &#125; else &#123; // 其他请求显示404 ctx.body = '&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;' &#125;&#125;) // 解析上下文里node原生请求的POST参数function parsePostData( ctx ) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postdata = ""; ctx.req.addListener('data', (data) =&gt; &#123; postdata += data &#125;) ctx.req.addListener("end",function()&#123; let parseData = parseQueryStr( postdata ) resolve( parseData ) &#125;) &#125; catch ( err ) &#123; reject(err) &#125; &#125;)&#125; // 将POST请求参数字符串解析成JSONfunction parseQueryStr( queryStr ) &#123; let queryData = &#123;&#125; let queryStrList = queryStr.split('&amp;') console.log( queryStrList ) for ( let [ index, queryStr ] of queryStrList.entries() ) &#123; let itemList = queryStr.split('=') queryData[ itemList[0] ] = decodeURIComponent(itemList[1]) &#125; return queryData&#125;app.listen(3000, () =&gt; &#123; console.log('[demo] request post is starting at port 3000')&#125;)]]></content>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2-中间组件middleware]]></title>
    <url>%2F2018%2F04%2F12%2Fkoa2-%E4%B8%AD%E9%97%B4%E7%BB%84%E4%BB%B6middleware%2F</url>
    <content type="text"><![CDATA[一、中间组件Koa2通过app.use()把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用await next()来调用下一个async函数。我们把每个async函数称为middleware。 1234567891011121314151617181920212223242526// 在koa2中，我们导入的是一个class，因此用大写的Koa表示:const Koa = require('koa');// 创建一个Koa对象表示web app本身:const app = new Koa();app.use(async (ctx, next) =&gt; &#123; console.log(`$&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); // 打印URL await next(); // 调用下一个middleware&#125;);app.use(async (ctx, next) =&gt; &#123; const start = new Date().getTime(); // 当前时间 await next(); // 调用下一个middleware const ms = new Date().getTime() - start; // 耗费时间 console.log(`Time: $&#123;ms&#125;ms`); // 打印耗费时间&#125;);app.use(async (ctx, next) =&gt; &#123; await next(); ctx.response.type = 'text/html'; ctx.response.body = '&lt;h1&gt;Hello, koa2!&lt;/h1&gt;';&#125;);// 在端口3000监听:app.listen(3000); 二、数据传递koa约定了一个中间件的存储空间ctx.state，通过这个state可以共享一些的数据。]]></content>
      <tags>
        <tag>koa2</tag>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2-mysql连接池]]></title>
    <url>%2F2018%2F04%2F12%2Fkoa2-mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[一、创建数据库会话mysql.js 1234567891011121314151617const mysql = require('mysql')const connection = mysql.createConnection(&#123; host : '127.0.0.1', // 数据库地址 user : 'root', // 数据库用户 password : '123456' // 数据库密码 database : 'my_database' // 选中数据库&#125;)connection.connect(); // 执行sql脚本对数据库进行读写 connection.query('SELECT * FROM my_table', (error, results, fields) =&gt; &#123; if (error) throw error // connected! // 结束会话 connection.release() &#125;); 二、创建数据连接池一般情况下操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数。所以这时候就需要连接池管理会话。 12345678910111213141516171819const mysql = require('mysql')// 创建数据池const pool = mysql.createPool(&#123; host : '127.0.0.1', // 数据库地址 user : 'root', // 数据库用户 password : '123456' // 数据库密码 database : 'my_database' // 选中数据库&#125;)// 在数据池中进行会话操作pool.getConnection(function(err, connection) &#123; connection.query('SELECT * FROM my_table', (error, results, fields) =&gt; &#123; // 结束会话 connection.release(); // 如果有错误就抛出 if (error) throw error; &#125;)&#125;)]]></content>
      <tags>
        <tag>koa2</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2-session]]></title>
    <url>%2F2018%2F04%2F12%2Fkoa2-session%2F</url>
    <content type="text"><![CDATA[一、session应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require('koa')const session = require('koa-session-minimal')// koa-mysql-session为koa-session-minimal中间件提供MySQL数据库的session数据读写操作// koa-session-minimal默认使用内存保存session对象const MysqlSession = require('koa-mysql-session')const app = new Koa()// 配置存储session信息的mysqllet store = new MysqlSession(&#123; user: 'root', password: 'abc123', database: 'koa_demo', host: '127.0.0.1',&#125;)// 存放sessionId的cookie配置let cookie = &#123; maxAge: '', // cookie有效时长 expires: '', // cookie失效时间 path: '', // 写cookie所在的路径 domain: '', // 写cookie所在的域名 httpOnly: '', // 是否只用于http请求中获取 overwrite: '', // 是否允许重写 secure: '', sameSite: '', signed: ''&#125;// 使用session中间件app.use(session(&#123; key: 'SESSION_ID', store: store, cookie: cookie&#125;))app.use( async ( ctx ) =&gt; &#123; // 设置session if ( ctx.url === '/set' ) &#123; ctx.session = &#123; user_id: Math.random().toString(36).substr(2), count: 0 &#125; ctx.body = ctx.session &#125; else if ( ctx.url === '/' ) &#123; // 读取session对象 ctx.session.count = ctx.session.count + 1 ctx.body = ctx.session &#125;&#125;)app.listen(3000)console.log('[demo] session is starting at port 3000') 二、koa-session-minimal源码1、目录结构 session.js memory_store.js store.js 2、session.jssession.js做两件事 请求进来时，根据cookies中的sid来初始化ctx.session对象 请求返回时，根据ctx.session的变化，更新ctx.session对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889const uid = require('uid-safe')const deepEqual = require('deep-equal')const Store = require('./store')const MemoryStore = require('./memory_store')const ONE_DAY = 24 * 3600 * 1000 // one day in millisecondsconst cookieOpt = (cookie, ctx) =&gt; &#123; const obj = cookie instanceof Function ? cookie(ctx) : cookie const options = Object.assign(&#123; maxAge: 0, // default to use session cookie path: '/', httpOnly: true, &#125;, obj || &#123;&#125;, &#123; overwrite: true, // overwrite previous session cookie changes signed: false, // disable signed option &#125;) if (!(options.maxAge &gt;= 0)) options.maxAge = 0 return options&#125;const deleteSession = (ctx, key, cookie, store, sid) =&gt; &#123; const tmpCookie = Object.assign(&#123;&#125;, cookie) delete tmpCookie.maxAge ctx.cookies.set(key, null, tmpCookie) store.destroy(`$&#123;key&#125;:$&#123;sid&#125;`)&#125;const saveSession = (ctx, key, cookie, store, sid) =&gt; &#123; const ttl = cookie.maxAge &gt; 0 ? cookie.maxAge : ONE_DAY ctx.cookies.set(key, sid, cookie) store.set(`$&#123;key&#125;:$&#123;sid&#125;`, ctx.session, ttl)&#125;const cleanSession = (ctx) =&gt; &#123; if (!ctx.session || typeof ctx.session !== 'object') ctx.session = &#123;&#125;&#125;module.exports = (options) =&gt; &#123; const opt = options || &#123;&#125; const key = opt.key || 'koa:sess' const store = new Store(opt.store || new MemoryStore()) const getCookie = ctx =&gt; cookieOpt(opt.cookie, ctx) return async (ctx, next) =&gt; &#123; // initialize session id and data // 根据cookies中的sid初始化ctx.session对象 const oldSid = ctx.cookies.get(key) let sid = oldSid const regenerateId = () =&gt; &#123; sid = uid.sync(24) &#125; if (!sid) &#123; regenerateId() ctx.session = &#123;&#125; &#125; else &#123; ctx.session = await store.get(`$&#123;key&#125;:$&#123;sid&#125;`) cleanSession(ctx) &#125; const oldData = JSON.parse(JSON.stringify(ctx.session)) // expose session handler to ctx ctx.sessionHandler = &#123; regenerateId, &#125; await next() // 保存更新后的ctx.session对象 cleanSession(ctx) const hasData = Object.keys(ctx.session).length &gt; 0 if (sid === oldSid) &#123; // session id not changed if (deepEqual(ctx.session, oldData)) return // session data not changed const cookie = getCookie(ctx) const action = hasData ? saveSession : deleteSession action(ctx, key, cookie, store, sid) // update or delete the existing session &#125; else &#123; // session id changed const cookie = getCookie(ctx) if (oldSid) deleteSession(ctx, key, cookie, store, oldSid) // delete old session if (hasData) saveSession(ctx, key, cookie, store, sid) // save new session &#125; &#125;&#125; 3、memory_store.js1234567891011121314151617181920212223242526272829module.exports = class MemoryStore &#123; constructor() &#123; this.sessions = &#123;&#125; // data this.timeouts = &#123;&#125; // expiration handler &#125; get(sid) &#123; return this.sessions[sid] &#125; set(sid, val, ttl) &#123; if (sid in this.timeouts) clearTimeout(this.timeouts[sid]) this.sessions[sid] = val this.timeouts[sid] = setTimeout(() =&gt; &#123; delete this.sessions[sid] delete this.timeouts[sid] &#125;, ttl) &#125; destroy(sid) &#123; if (sid in this.timeouts) &#123; clearTimeout(this.timeouts[sid]) delete this.sessions[sid] delete this.timeouts[sid] &#125; &#125;&#125; 4、store.js12345678910111213141516171819const co = require('co')module.exports = class Store &#123; constructor(store) &#123; this.store = store &#125; get(sid) &#123; return co(this.store.get(sid)) &#125; set(sid, val, ttl) &#123; return co(this.store.set(sid, val, ttl)) &#125; destroy(sid) &#123; return co(this.store.destroy(sid)) &#125;&#125;]]></content>
      <tags>
        <tag>koa2</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-连续赋值]]></title>
    <url>%2F2018%2F04%2F11%2FJS-%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、先看问题12345var a = &#123;n:1&#125;; var b = a; a.x = a = &#123;n:2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; [object Object] 二、逐步分析下面来分析下这段简单代码的工作步骤，从而进一步理解js引用类型“赋值”的工作方式。首先是： 12var a = &#123;n:1&#125;; var b = a; 在这里a指向了一个对象{n:1}（我们姑且称它为对象A），b指向了a所指向的对象，也就是说，在这时候a和b都是指向对象A的。这一步很好理解，接着继续看下一行非常重要的代码： 1a.x = a = &#123;n:2&#125;; 我们知道js的赋值运算顺序永远都是从右往左的，不过由于“.”是优先级最高的运算符，所以这行代码先解析了a.x。这时候发生了这个事情——a指向的对象{n:1}新增了属性x（虽然这个x是undefined的）： 从图上可以看到，由于b跟a一样是指向对象A的，要表示A的x属性除了用a.x，自然也可以使用b.x来表示了。 接着，依循“从右往左”的赋值运算顺序先执行 a={n:2} ，这时候，a指向的对象发生了改变，变成了新对象{n:2}（我们称为对象B）： 接着继续执行 1a.x = a; 很多人会认为这里是“对象B也新增了一个属性x，并指向对象B自己”。但实际上并非如此，由于（ . 运算符最先计算）一开始js已经先计算了a.x，便已经解析了这个a.x是对象A的x，所以在同一条公式的情况下再回来给a.x赋值，也不会重新解析这个a.x为对象B的x。所以 a.x=a 应理解为对象A的属性x指向了对象B:]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-路径问题]]></title>
    <url>%2F2018%2F04%2F10%2Fwebpack-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、contextcontext 是 webpack 编译时的基础目录，webpack会根据此目录去查找入口起点（entry）。 若不配置，默认值为当前目录，webpack设置 context 默认值代码： 1this.set("context", process.cwd()); process.cwd()即webpack运行所在的目录（等同package.json所在目录）。 context 应该配置为绝对路径，假如入口起点为src/main.js，则可以配置： 1234&#123; context: path.resolve('./src'), entry: './main.js'&#125; 此时 entry 不能再配置为’./src/main.js’，因为 webpack 会相对于 context 配置的 src 目录区查找入口起点（main.js），而 main.js 就在此目录下，所以应当将 entry 配置为当前目录（./）。 context 有什么实际作用？官方文档的解释是使得你的配置独立于工程目录 「This makes your configuration independent from CWD (current working directory)」。怎么理解？举个例子，在分离开发生产配置文件时候，一般把 webpack.config 放到 build 文件夹下，此时 entry 却不用考虑相对于 build 目录来配置，仍然要相对于 context 来配置，这也就是所谓的独立于工程目录。 需要注意的是，output 的配置项和 context 没有关系，但是有些插件的配置项和 context 有关，后面会说明。 二、output1、output.path打包文件输出的目录，建议配置为绝对路径（相对路径不会报错），默认值和 context 的默认值一样，都是process.cwd()。除了常规的配置方式，还可以在 path 中用使用 [hash] 模板，比如配置： 1234output: &#123; path: path.resolve('./dist/[hash:8]/'), filename: '[name].js' &#125; 这里的 hash 值是编译过程的 hash，如果被打包进来的内容改变了，那么 hash 值也会发生改变。这个可以用于版本回滚。为方便做持续集成等，你也可以配置： 1234output: &#123; path: path.resolve(`./dist/$&#123;Date.now()&#125;/`), filename: '[name].js' &#125; 2、ouput.publicPath静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径 12345678910111213141516171819202122output.publicPath = '/static/'// 图片 url-loader 配置&#123; name: 'img/[name].[ext]'&#125;// 那么图片最终的访问路径为// output.publicPath + 'img/[name].[ext]' = '/static/img/[name].[ext]'// JS output.filename 配置&#123; filename: 'js/[name].js'&#125;// 那么JS最终访问路径为 // output.publicPath + 'js/[name].js' = '/static/js/[name].js'// CSS new ExtractTextPlugin("css/style.css")// 那么最终CSS的访问路径为// output.publicPath + 'css/style.css' = '/static/css/style.css' publicPath 默认值为空字符串，接下来看其他各种常见的 publicPath 配置的实际意义。 三、webpack-dev-server1、publicPath我们知道 webpack-dev-server 打包的内容是放在内存中，通过express匹配请求路径，然后读取对应的资源输出。这些资源对外的根目录就是publicPath，可以理解为和 outpu.path 的功能一样，将所有资源放在此目录下，在浏览器可以直接访问此目录下的资源。 但是这个路径仅仅只是为了提供浏览器访问打包资源的功能，webpack中的loader和插件仍然是取ouput.publicPath，比如CSS里面的图片最终的路径仍是”/static/img/xxxx.png”，这也是为什么官方推荐 publicPath 和 webpack 配置的保持一致（除了http地址），配置一致才能正常访问其他静态资源。 上面的解释可能还是比较生硬，还是举几个例子来说明。本例将两处 publicPath 配置成不一样的，这样更容易对比理解。 1234567891011121314151617// webpack.config.jsoutput: &#123; path: path.resolve(`./dist/`), filename: 'js/[name].js', publicPath: '/static/'&#125; // api 调用 webpack-dev-servervar webpack = require('webpack');var webpackDevServer = require('webpack-dev-server');var config = require("./webpack.config");var compiler = webpack(config);var server = new webpackDevServer(compiler, &#123; hot: true, publicPath: '/web/'&#125;);server.listen(8282, "0.0.0.0") 如何查看 webpack-dev-server 所有启动后的资源访问路径呢？有个简单的方法，就是访问/webpack-dev-server，本例访问截图如下： 上面的资源可以点击查看，你会发现，资源的路径都是/web/*，所以在index.html中引入JS的路径应为/web/js/main.js，同时也能看到，style.css中的图片路径仍然为/static/img/**.png，而不是/web/。 四、html-webpack-plugin这个插件的几处配置受路径配置影响，因此需要专门说明下。 1、templatetemplate的路径是相对于 output.context，源码如下： 1this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); 因此 template 对应的文件需要放在 ouput.context 配置的目录下才能被识别。 2、Filenamefilename的路径是相对于 output.path，源码如下： 1this.options.filename = path.relative(compiler.options.output.path, filename); 在 webpack-dev-server 中，则相对于 webpack-dev-server 配置的 publicPath。 3、衍生问题若 webpack-dev-server 中的 publicPath 和 ouput.publicPath 不一致，在这种配置下使用html-webpack-plugin是有如下问题： 自动引用的路径仍然以 ouput.publicPath 为准，和 webpack-dev-server 提供的资源访问路径不一致，从而不能正常访问； 浏览 index.html 需要加上 webpack-dev-server 配置的 publicPath 才能访问（http://localhost:8282/web/）。 这两个问题也反推出了最方便的配置为： ouput.publicPath 和 webpack-dev-server 的publicPath 均配置为’/‘，vue-cli 就是这种配置 template 放在根目录，html-webpack-plugin 不用修改参数的路径，filename 采用默认值。 五、记录曾经用过的配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//webpack.base.config.jsmodule.exports = &#123; entry: &#123; // 入口文件的默认路径为context，而不是当前文件路径 // main: './src/main', // 使用path.join，从当前文件路径算起，感觉更符合逻辑些 main: path.join(__dirname, '../src/main'), vendors: path.join(__dirname, '../src/vendors') &#125;, output: &#123; // 定义了文件build后放置的位置 path: path.join(__dirname, '../dist/static') &#125;, module: &#123; rules:[&#123; test: /\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/, loader: 'url-loader?limit=1024', query: &#123; limit: 10000, // 定义了文件的名字，以及相对于output.path路径的位置 // build后，引用文件自带img前缀 // 放置在dist/static/img/目录下 name: 'img/[name].[hash:7].[ext]' &#125; &#125;, &#123; test: /\.jpeg$/, use: 'url-loader?limit=1024&amp;name=[path][name].[ext]&amp;outputPath=img/&amp;publicPath=output/', &#125; ] &#125;,&#125;;//webpack.prod.config.jsmodule.exports = merge(webpackBaseConfig, &#123; output: &#123; // 定义了index.html中引用js、css、img等资源的引用路径，可以为相对路径或者绝对路径 publicPath: '/static', // 定义了文件的名字，以及相对于path路径的位置 // build后，引用文件自带js前缀 // 放置在dist/static/js/目录下 filename: 'js/[name].[hash].js', chunkFilename: 'js/[name].[hash].chunk.js' &#125;, plugins: [ new ExtractTextPlugin(&#123; filename: 'css/[name].[hash].css', allChunks: true &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendors', filename: 'js/vendors.[hash].js' &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), new HtmlWebpackPlugin(&#123; // 定义了build后的index.html文件的位置 filename: path.join(__dirname, '../dist/index_prod.html'), template: path.join(__dirname, '../src/template/index.ejs'), inject: false &#125;) ]&#125;);]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-rewrite]]></title>
    <url>%2F2018%2F04%2F10%2Fnginx-rewrite%2F</url>
    <content type="text"><![CDATA[一、ngx_http_rewrite_modulerewrite模块即ngx_http_rewrite_module模块，主要功能是改写请求URI，是Nginx默认安装的模块。rewrite模块会根据PCRE正则匹配重写URI，或者直接返回资源（200|404），或者发起内部跳转再匹配location，或者直接做30x重定向返回客户端。 ngx_http_rewrite_module模块的指令有break, if, return, rewrite, set。 二、rewrite语法123rewrite &lt;regex&gt; &lt;replacement&gt; [flag] # 关键字 正则 替代内容 flag标记# 可以在server, location, if flag标记说明： last #本条规则匹配完成后，继续向下匹配新的location URI规则 跳转的总次数不能超过10次 break #本条规则匹配完成即终止，不再匹配后面的任何规则。 请求内容存在，返回200；请求内容不存在，则返回404。 redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址 permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址 1234rewrite ^/(.*) http://www.czlun.com/$1 permanent;# regex部分是 ^/(.*) ，这是一个正则表达式，匹配完整的域名和后面的路径地址# replacement部分是http://www.czlun.com/$1，$1是取自regex部分()里的内容。匹配成功后跳转到的URL。# flag部分 permanent表示永久301重定向标记，即跳转到新的 http://www.czlun.com/$1 地址上 123456789101112131415rewrite /test/.* /index.html break;location /test/ &#123; return 508;&#125; location /break/ &#123; rewrite ^/break/(.*) /test/$1 break; return 402;&#125;location /last/ &#123; rewrite ^/last/(.*) /test/$1 last; return 403;&#125; 123456请求1： http://test.com/break/index.php 返回：404 请求2： http://test.com/last/index.php 返回：508 请求3： http://test.com/test/index.php 返回：200 (返回index.html) 当请求break时，如匹配内容存在的话，可以直接请求成功，返回200；而如果请求内容不存在，则返回404当请求为last的时候，会对重写的新uri重新发起请求，只是重新查找location匹配，如请求2返回508 三、return语法12return code [text] | code URL | URL;# 可以在server, location, if 停止任何的进一步处理，并且将指定状态码返回给客户端 return的参数有四种形式： return code 此时，响应内容就是nginx所默认的，比如503 Service Temporarily Unavailable return code text 因为要带响应内容，因此code不能是具有跳转功能的30x return code URL 此时URI可以为URI做内部跳转，也可以是具有http://或者https://等协议的绝对URL，直接返回客户端，而code是30x return URL 此时code默认为302，而URL必须是带http://等协议的绝对URL 四、PCRE正则表达式 字符 描述 \ 转义字符。如“\n”匹配一个换行符 ^ 匹配输入字符串的起始位置 $ 匹配输入字符串的结束位置 * 匹配前面的字符零次或多次。如“ol*”能匹配“o”及“ol”、“oll” + 匹配前面的字符一次或多次。如“ol+”能匹配“ol”及“oll”、“oll”，但不能匹配“o” ? 匹配前面的字符零次或一次，例如“do(es)?”能匹配“do”或者“does”，”?”等效于”{0,1}” . 匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[.\n]”之类的模式。 (pattern) 匹配括号内pattern并可以在后面获取对应的匹配。常用$0…$9属性获取小括号中的匹配内容，要匹配圆括号字符需要(Content) 12345678910111213server &#123; listen 80; server_name abc.com www.abc.com; if ( $host != 'www.abc.com' ) &#123; rewrite ^/(.*) http://www.abc.com/$1 permanent; &#125; location / &#123; root /data/www/www; index index.html index.htm; &#125; error_log logs/error_www.abc.com.log error; access_log logs/access_www.abc.com.log main;&#125; 五、逻辑判断 操作符 含义 =，!= 比较的一个变量和字符串。 ~，~* 与正则表达式匹配的变量，如果这个正则表达式中包含 }，; 则整个表达式需要用“或’包围。 -f，!-f 检查一个文件是否存在。 -d，!-d 检查一个目录是否存在。 -e，!-e 检查一个文件、目录、符号链接是否存在。 -x，!-x 检查一个文件是否可执行。 六、常用变量 变量 含义 $args 这个变量等于请求行中的参数，同$query_string $content_length 请求头中的Content-length字段。 $content_type 请求头中的Content-Type字段。 $document_root 当前请求在root指令中指定的值。 $host 请求主机头字段，否则为服务器名称。 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $limit_rate 这个变量可以限制连接速率。 $request_method 客户端请求的动作，通常为GET或POST。 $remote_addr 客户端的IP地址。 $remote_port 客户端的端口。 $remote_user 已经经过Auth Basic Module验证的用户名。 $request_filename 当前请求的文件路径，由root或alias指令与URI请求生成。 $scheme HTTP方法（如http，https）。 $server_protocol 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。 $server_addr 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name 服务器名称。 $server_port 请求到达服务器的端口号。 $request_uri 包含请求参数的原始URI，不包含主机名，如”/foo/bar.php?arg=baz”。 $uri 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。 $document_uri 与$uri相同。 12345678910111213141516171819202122232425262728293031# 限制浏览器访问 if ($http_user_agent ~ Firefox) &#123; rewrite ^(.*)$ /firefox/$1 break; &#125;if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break; &#125; if ($http_user_agent ~ Chrome) &#123; rewrite ^(.*)$ /chrome/$1 break; &#125; # 限制IP访问 if ($remote_addr = 192.168.197.142) &#123; return 403; &#125;# set指令是设置变量用的,可以用来达到多条件判断时作标志用# 判断IE并重写,且不用break;我们用set变量来达到目的if ($http_user_agent ~* msie) &#123; set $isie 1; &#125;if ($fastcgi_script_name = ie.html) &#123; set $isie 0; &#125; if ($isie 1) &#123; rewrite ^.*$ ie.html; &#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-CORS跨域]]></title>
    <url>%2F2018%2F04%2F10%2Fnginx-CORS%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一、CORSCORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。 Origin（本域）表示浏览器当前页面的域。当JavaScript向外域发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。 上面这种跨域请求，称之为“简单请求”。若请求满足所有下述条件，则该请求可视为“简单请求”： 1.使用下列方法之一 GET HEAD POST 2.Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为 Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width 3.Content-Type的值仅限于下列三者之一 text/plain multipart/form-data application/x-www-form-urlencoded 4.请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器 XMLHttpRequestUpload对象可以使用 XMLHttpRequest.upload属性访问 5.请求中没有使用 ReadableStream 对象 二、非简单请求对于PUT、DELETE以及其他类型（如application/json的POST请求），在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受： 1234OPTIONS /path/to/resource HTTP/1.1Host: bar.comOrigin: http://my.comAccess-Control-Request-Method: POST 服务器必须响应并明确指出允许的Method： 1234HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://my.comAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONSAccess-Control-Max-Age: 86400 浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。 三、Access-Control- 参数（1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （2.1）withCredentials 属性如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段；另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12let xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 注：如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 四、nginx配置例子12345678910111213141516171819202122232425262728293031location / &#123; if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; # # Custom headers and headers various browsers *should* be OK with but aren't # add_header 'Access-Control-Allow-Headers' 'User-Agent,Cache-Control,Content-Type'; # # Tell client that this pre-flight info is valid for 20 days # add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; &#125; if ($request_method = 'POST') &#123; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'User-Agent,Cache-Control,Content-Type'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; &#125; if ($request_method = 'GET') &#123; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'User-Agent,Cache-Control,Content-Type'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; &#125;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>CORS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html-不使用table布局]]></title>
    <url>%2F2018%2F04%2F09%2Fhtml-%E4%B8%8D%E4%BD%BF%E7%94%A8table%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Table要比其它html标记占更多的字节 Tablle会阻挡浏览器渲染引擎的渲染顺序 table是中的内容是自适应的，它要计算嵌套最深的节点以满足自适应，所以会出现空白后才显示内容。 在某些浏览器中Table里的文字的拷贝会出现问题。 Table会影响其内部的某些布局属性的生效(比如里的元素的height:100%) table对对于页面布局来说，从语义上看是不正确的。]]></content>
      <tags>
        <tag>html</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-响应式表单]]></title>
    <url>%2F2018%2F03%2F29%2Fcss-%E5%93%8D%E5%BA%94%E5%BC%8F%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[css3的@media检测到屏幕尺寸，将表格元素设置为block块状，并且隐藏表头，将td设置下边框看起来跟一行行的一样。最后我们使用css3的:before { content: “姓名”; }生成每行对应的标签定义，这样就能知道每行数据的意义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@media only screen and (max-width: 760px),(min-device-width: 768px) and (max-device-width: 1024px) &#123; /* Force table to not be like tables anymore */ table, thead, tbody, th, td, tr &#123; display: block; &#125; thead tr &#123; position: absolute; top: -9999px; left: -9999px; &#125; tr &#123; border: 1px solid #ccc; &#125; td &#123; /* Behave like a "row" */ border: none; border-bottom: 1px solid #eee; position: relative; padding-left: 50%; &#125; td:before &#123; /* Now like a table header */ position: absolute; /* Top/left values mimic padding */ top: 6px; left: 6px; width: 45%; padding-right: 10px; white-space: nowrap; &#125; /*Label the data*/ td:nth-of-type(1):before &#123; content: "姓名"; &#125; td:nth-of-type(2):before &#123; content: "性别"; &#125; td:nth-of-type(3):before &#123; content: "出生年月"; &#125;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-自定义事件]]></title>
    <url>%2F2018%2F03%2F26%2FJS-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1var event = document.createEvent(type) event 就是被创建的 Event 对象. type 是一个字符串，表示要创建的事件类型。事件类型可能包括”UIEvents”, “MouseEvents”, “MutationEvents”, 或者 “HTMLEvents”。请查看 Notes 章节获取详细信息 1234567891011121314151617// 创建事件var event = document.createEvent('Event'); // 定义事件名为'build'.// 事件类型，是否冒泡，是否阻止浏览器的默认行为event.initEvent('build', true, true); // 监听事件elem.addEventListener('build', function (e) &#123; // e.target matches elem&#125;, false); // 触发对象可以是任何元素或其他事件目标elem.dispatchEvent(event);]]></content>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-原型链]]></title>
    <url>%2F2018%2F03%2F25%2FJS-%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[一. 无中生有起初，什么都没有。 造物主说：没有东西本身也是一种东西啊，于是就有了null： 现在我们要造点儿东西出来。但是没有原料怎么办？ 有一个声音说：不是有null嘛？ 另一个声音说：可是null代表无啊。 造物主说：那就无中生有吧！ 于是： JavaScript中的1号对象产生了，不妨把它叫做No. 1。 这个No. 1对象可不得了，No. 1是真正的万物始祖。它拥有的性质，是所有的对象都有的。 proto是什么呢？是“生”的意思，或者叫做继承。 二. 制造对象的机器既然已经有了一个对象，剩下就好办了，因为一生二，二生三，三生万物嘛。 不过造物主很懒，他不想一个一个地亲手制造对象。于是他做了一台能够制造对象的机器： 12Object.prototype.__proto__ === null;// true 他给这台机器起了一个名字：Object。 这台机器并不能凭空造出对象，它需要一个模板对象，按照这个模板对象来制造对象。很自然的，它把目前仅有的No. 1对象作为模板。图中的prototype就代表机器的模板对象。 机器如何启动呢？通过new命令。你对着机器喊一声：“new！”，对象就造出来了。 机器的产生，实现了对象的批量化自动化生产，解放了造物主的双手。于是造物主忙别的去了。 如果机器只是按照模板的样子，机械地复制出一模一样的对象，那就太笨了。 人类的后代在继承了父辈的性状的基础上，可以产生父辈没有的性状。同样地，机器在制造对象时，除了继承模板对象的属性外，还可以添加新的属性。这使得JavaScript世界越来越多样化。 比如说，有一天Object机器制造一个对象，它有一个特殊的属性，叫做flag，属性值是10。用图形表示是这样的： 写成代码就是： 1var obj = new Object(&#123; flag: 10 &#125;); 轰轰烈烈的造物运动开始了…… 三. 更多制造对象的机器一天天过去了，造物主来视察工作。看到Object制造出了好多好多对象，他非常高兴。 同时他还发现：根据“物以类聚”的原则，这些对象可以分成很多类。聪明的造物主想，我何不多造几台机器，让每一台机器专门负责制造某一类对象呢？于是，他动手造出了几台机器并给它们起了名字。它们分别是： String：用来制造表示一段文本的对象。 Number：用来制造表示一个数字的对象。 Boolean：用来制造表示是与非的对象。 Array：用来制造有序队列对象。 Date：用来制造表示一个日期的对象。 Error：用来制造表示一个错误的对象。 …… 多台机器齐开动，各司其责，造物运动进入了一个新的阶段…… 造物主又开始思考了：虽然机器是用来制造对象的，但是机器本身实际上也是一种特殊对象啊。现在有了这么多机器，我得好好总结一下它们的共同特征，把它们也纳入对象体系。 于是，造物主基于No. 1对象，造出了一个No. 2对象，用它来表示所有机器的共同特征。换句话说，把No. 2对象作为所有机器的原型对象。 （注：proto写起来太麻烦了，后面我们用[p]来代替） 当然了，和Object一样，这些机器也需要各自有一个模板对象，也就是它们的prototype属性指向的那个对象。显然它们的模板对象应该是继承自No. 1对象的，即 12345678Object.__proto__.__proto__.__proto__ === null;// trueNumber.__proto__ === Object.__proto__;// trueNumber.prototype.__proto__.__proto__ === null;// true 这张图显示了JavaScript世界中那些最基本的机器本身的原型链，以及它们的模板对象的原型链。不过看起来太复杂了，所以后面我们就不再把它们完整地画出来了。 四. 制造机器的机器造物主高兴地想：这下可好了，我造出了Object机器，实现了对象制造的自动化。然后又造出了String、Number等机器，实现了特定类别的对象制造的自动化。但是，为啥总感觉似乎还缺点什么呢？ 对啦，还缺少一台制造机器的机器啊！ 很快，万能的造物主就把它造了出来，并把它命名为Function。有了Function机器后，就可以实现自动化地制造机器了。 让我们来观察一下Function： 首先，Function是一台机器，所以它的原型对象也是No. 2对象。 其次，Function又是一台制造机器的机器，所以它的模板对象也是No. 2对象。 所以我们得到了Function的一个非常特别的性质： 12Function.__proto__ === Function.prototype;// true 哇，太奇妙了！ 不要奇怪，这个性质不过是”Function是一台制造机器的机器“这个事实的必然结果。 于是JavaScript的世界的变成了下面的样子： 从这张图中，我们发现：所有的函数(包括Function)的原型都是No. 2对象，而同时Function.prototype也是No. 2对象。这说明了： 从逻辑上，我们可以认为所有机器(包括Function自己)都是由Function制造出来的。 同时，如果再仔细瞧瞧，你会发现： Object作为一个机器可以看做是有由Function制造出来的，而Function作为一个对象可以看做是由Object制造出来的。 这就是JavaScript世界的“鸡生蛋，蛋生鸡”问题。那么到底是谁生了谁呢？Whatever！]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-权重]]></title>
    <url>%2F2018%2F03%2F23%2Fcss-%E6%9D%83%E9%87%8D%2F</url>
    <content type="text"><![CDATA[权重等级根据选择器种类的不同可以分为四类，也决定了四种不同等级的权重值。 0、!important（10,000）1、行内样式style（1,000）2、ID选择器（100）3、类、属性选择器、伪类选择器（10）伪类选择器 :hover :focus 4、元素、伪元素（1）伪元素选择器: ::after ::before ::first-letter ::first-line ::selecton 伪元素跟伪类都是选择器的补充，但是，伪类表示的是一种“状态”。比如hover，active等等，而伪元素表示文档的某个确定部分的表现，比如::first-line 伪元素只作用于你前面元素选择器确定的一个元素的第一行。 注意，伪元素选择器选择出来的“部分”不在dom里，也不能对其绑定事件。如果你对伪元素前面的选择器定义的元素绑定了事件，伪元素同样会生效。 永远记得伪元素生成的是“表现”。 注意： 通配选择符（universal selector）(*), 关系选择符（combinators） (+, &gt;, ~, ‘ ‘) 和 否定伪类（negation pseudo-class）(:not()) 对优先级没有影响。（但是，在 :not() 内部声明的选择器是会影响优先级）。 @media媒体查询相当于逻辑if的作用，但不影响优先级。媒体查询主要利用属性覆盖产生效果，因此媒体查询样式的位置特别重要。 1234567891011@media screen and (max-width: 500px) &#123; body &#123; background-color:red; &#125;&#125;body &#123; background-color:lightgreen;&#125;/*如果媒体查询放在普通样式之前，样式无法进行覆盖，没有起到相应的效果*/]]></content>
      <tags>
        <tag>css</tag>
        <tag>权重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-transform-skew]]></title>
    <url>%2F2018%2F03%2F23%2Fcss-transform-skew%2F</url>
    <content type="text"><![CDATA[一、skewskew所用的坐标系，纵向是X轴，横向是Y轴，与常见的坐标系是反着的。比如： skewX(30deg) 表示X轴朝逆时针方向旋转30deg，坐标系上的物体也会随着X轴旋转。 skewY(10deg) 表示Y轴朝顺时针方向旋转10deg，坐标系上的物体也会随着Y轴旋转。 skewX(30deg) skewY(10deg) 加在一起的效果是 二、对比 skewX(30deg)：X轴逆时针方向旋转30deg（X轴旋转） rotateX(30deg) ：坐标系上的点绕着X轴旋转30deg（点旋转） translateX(30px) ：X轴沿着轴方向平移30px（X轴平移） scaleX(2) ：X轴放大2倍（X轴缩放） 注：transform-origin（坐标系原点）不同，视觉效果往往大不一样]]></content>
      <tags>
        <tag>css</tag>
        <tag>transform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-渲染过程]]></title>
    <url>%2F2018%2F03%2F22%2Fcss-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、浏览器渲染原理关于浏览器工作原理之前有一篇非常出名的文章《浏览器的工作原理：新式网络浏览器幕后揭秘》。文章详细阐述了浏览器工作原理，下面用两张图来分别描述Firefox和Chrome浏览器对Web页面的渲染过程。 二、Chrome渲染过程 有关于Chrome浏览器渲染的详细内容，可以参考《图解浏览器渲染过程 - 基于Webkit/Blink内核Chrome浏览器》一文。 三、Firefox渲染过程 特别声明：接下来的内容都是针对于Chrome浏览器进行讨论。 四、Chrome渲染部分的实际含义从上面的流程图中不难看出，Chrome渲染主要包括Parse Html、Recalculate Style、Layout、Rasterizer、Paint、Image Decode、Image Resize和Composite Layers等。简单了解一下其含义，以便后续内容的更好理解。 1、Parse Html发送一个http请求，获取请求的内容，然后解析HTML的过程。 有一个经典的前端面试题：当你在浏览器中输入google.com并且按下回车之后发生了什么？ 这个面试题或许能帮助大家更好的理解Parse Html，甚至是浏览器渲染的其他几个部分。 2、Recalculate Style重新计算样式，它计算的是Style，和Layout做的事情完全不同。Layout计算的是一个元素绝对的位置和尺寸，或者说是“Compute Layout”。 Recalculate被触发的时候做的事情就是处理JavaScript给元素设置的样式而已。Recalculate Style会计算Render树（渲染树）,然后从根节点开始进行页面渲染，将CSS附加到DOM上的过程。 任何企图改变元素样式的操作都会触发Recalculate。同Layout一样，它也是在JavaScript执行完成后才触发的。 3、Layout计算页面上的布局，即元素在文档中的位置及大小。正如前面所述，Layout计算的是布局位置信息。任何有可能改变元素位置或大小的样式都会触发这个Layout事件。 触发Layout的属性非常的多，如果想了解什么属性会触发Layout事件，可以在CSS Triggers网站查阅。下图截了一部分： 4、Rasterizer光栅化，一般的安卓手机都会进行光栅化，光栅主要是针对图形的一个栅格化过程。低端手机在这部分耗时还是蛮多的。 5、Paint页面上显示东西有任何变动都会触发Paint。包括拖动滚动条，鼠标选择中文字等这些完全不改变样式，只改变显示结果的动作都会触发Paint。 Paint的工作就是把文档中用户可见的那一部分展现给用户。Paint是把Layout和Recalculate的计算的结果直接在浏览器视窗上绘制出来，它并不实现具体的元素计算。 6、Image Decode图片解码，将图片解析到浏览器上显示的过程。 7、Image Resize图片的大小设置，图片加载解析后，若发现图片大小并不是实际的大小（CSS改变了宽度），则需要Resize。Resize越大，耗时越久，所以尽量以图片的原始大小输出。 8、Composite Layers最后合并图层，输出页面到屏幕。浏览器在渲染过程中会将一些含有特殊样式的DOM结构绘制于其他图层，有点类似于PhotoShop的图层概念。一张图片在PotoShop是由多个图层组合而成，而浏览器最终显示的页面实际也是有多个图层构成的。 下面这些因素都会导致新图层的创建： 进行3D或者透视变换的CSS属性 使用硬件加速视频解码的元素 具有3D（WebGL）上下文或者硬件加速的2D上下文的元素 组合型插件（即Flash） 具有有CSS透明度动画或者使用动画式Webkit变换的元素 具有硬件加速的CSS滤镜的元素 有关于Composite方面的深入剖析，可以阅读《无线性能优化：Composite》一文。 五、像素渲染流水线通过前面的介绍，在屏幕上最终呈现的页面，是类似于图层一样合并输出到屏幕上的。其实所写的Web页面最终以像素的形式在浏览器屏幕上呈现。这样一来，我们需要理解所写的页面代码是如何被转换成屏幕上显示的像素。这个转换过程可以归纳为这样的一个流水线，主要包含五个关键步骤： JavaScript：一般来说，我们会使用JavaScript来实现一些视觉变化的效果。比如CSS Animation、Transition和Web Animation API。 Style：计算样式。这个过程是根据CSS选择器，对每个DOM元素匹配对应的CSS样式。这一步结束之后，就确定了每个DOM元素上应该应用什么CSS样式规则。 (Recalculate Style) Layout：布局。上一步确定了每个DOM元素的样式规则，这一步就是具体计算每个DOM元素最终在屏幕上显示的大小和位置。Web页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，元素的width变化会影响其后代元素的宽度。因此，对于浏览器而言，布局过程是经常发生的。 (Compute Layout) Paint：绘制。本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个DOM元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。 Composite：渲染层合并。前面也说过，对于页面中DOM元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后在屏幕上呈现。对于有位置重叠的元素的页面，这个过程尤其重要，因为一量图层的合并顺序出错，将会导致元素显示异常。 上述过程的每一步都有可能会发生，因此一定要弄清楚自己的代码将会运行在哪一步。 虽然在理论上，页面的每一帧都是结过上述的流水线处理之后渲染出来的，但并不意味着页面每一帧的渲染都需要经过上述五个步骤的处理。实际上，对视觉变化效果的一个帧的渲染，有三种常用的流水线。 1、JavaScript/CSS =&gt;计算样式=&gt;布局=&gt;绘制=&gt;渲染层合并 如果你修改一个DOM元素的“Layout”属性，也就是改变了元素的样式（比如width、height或者position等），那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个reflow（重排）过程完成重新布局。被reflow（重排）的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。 reflow又叫重排,是指浏览器计算页面的全部或部分布局所做的处理。reflow必定会引发重绘，这对于Web的性能影响是极大的。 2、JavaScript/CSS =&gt; 计算样式 =&gt;绘制 =&gt;渲染层合并 如果你修改一个DOM元素的“Paint Only”属性，比如背景图片、文字颜色或阴影等，这些属性不会影响页面的布局，因此浏览器会在完成样式计算之后，跳过布局过程，只会绘制和渲染层合并过程。 3、JavaScript/CSS =&gt; 计算样式 =&gt;渲染层合并 如果你修改一个非样式且非绘制的CSS属性，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并。这种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用第三种渲染过程。 通过前面这么多的内容介绍，我们可以得知，影响Web性能主要过程包括Layout、Paint和Composite。那么对于CSS Animation而言，我们的所有操作都是通过CSS的样式控制动画，言外之意，只要是会触发Layout、Paint和Composite的CSS属性都会直接影响动画的性能。在CSS中所有影响Layout、Paint和Composite的属性都可以通过CSS Triggers**网站查阅。那么如何避免达到前面所述的，整个动画尽量避开重排和重绘，只做渲染层合并呢？暂且先不讨论，把这部分放到最后面来讨论。接下来接着先看看其他相关的知识点。 六、渲染性能在理解渲染性能之前，我们有必要先了解前面提到的两个概念重排（也就是回流）和重绘。因为这两者与前面介绍的像素渲染流水线中的Layout和Paint都有关系，而且Layout和Paint对性能的渲染又有莫大的关系。 1、Reflow（重排）Reflow（重排）指的是计算页面布局（Layout）。某个节点Reflow时会重新计算节点的尺寸和位置，而且还有可能触其后代节点Reflow。在这之后再次触发一次Repaint（重绘） 当Render Tree中的一部分（或全部）因为元素的尺寸、布局、隐藏等改变而需要重新构建。这就称为回流，每个页面至少需要一次回流，就是页面第一次加载的时候。 在Web页面中，很多状况下会导致回流： 调整窗口大小 改变字体 增加或者移除样式表 内容变化 激活CSS伪类 操作CSS属性 JavaScript操作DOM 计算offsetWidth和offsetHeight 设置style属性的值 CSS3 Animation或Transition 2、Repaint（重绘）Repaint（重绘）或者Redraw遍历所有节点，检测节点的可见性、颜色、轮廓等可见的样式属性，然后根据检测的结果更新页面的响应部分。 当Render Tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格、而不会影响布局的。就是重绘。 将重排和重绘的介绍结合起来，不难发现：重绘（Repaint）不一定会引起回流（Reflow重排），但回流必将引起重绘（Repaint）。 既然如此，那么什么情况之下会触发浏览器的Repaint和Reflow呢？ 页面首次加载 DOM元素添加、修改(内容)和删除(Reflow + Repaint) 仅修改DOM元素的颜色(只有Repaint，因为不需要调整布局) 应用新的样式或修改任何影响元素外观的属性 Resize浏览器窗口和滚动页面 读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、getComputedStyle()等) 可以说Reflow和Repaint都很容易触发，而它们的触发对性能的影响都非常大，但非常不幸的是，我们无法完全避免，只能尽量不去触发浏览器的Reflow和Repaint。 从前面的内容可以了解到，Reflow和Repaint对性能影响很大，那么具体哪些点会影响到渲染性能呢？ 3、影响Layout的属性当你改变页面上某个元素的时候，浏览器需要做一次重新布局的操作，这次操作会包括计算受操作影响所有元素的几何数，比如每个元素的位置和尺寸。如果你修改了html这个元素的width属性，那么整个页面都会被重绘。 由于元素相覆盖，相互影响，稍有不慎的操作就有可能导致一次自上而下的布局计算。所以我们在进行元素操作的时候要一再小心尽量避免修改这些重新布局的属性。 具体有关于会影响Layout的CSS属性可以在CSS Triggers网站中查阅。 4、影响Repaint的属性有些属性的修改不会触发重排，但会触Repaint（重绘）,现代浏览器中主要的绘制工作主要用光栅化软件来完成。所以重新会制的元素是否会很大程度影响你的性能，是由这个元素和绘制层级的关系来决定的，如果这个元素盖住的元素都被重新绘制，那么代价自然就相当地大。 具体有关于会影响Layout的CSS属性可以在CSS Triggers网站中查阅。 如果你在动画里面使用了上述某些属性，导致重绘，这个元素所属的图层会被重新上传到GPU。在移动设备上这是一个很昂贵耗资源的操作，因为移动设备的CPU明显不如你的电脑，这也意味着绘制的工作会需要更长的时间；而上传线CPU和GPU的带宽并非没有限制，所以重绘的纹理上传就自然需要更长的时间。 CSS Triggers网站中可以得知哪些属性会触发重排、哪些属性会触发重绘以及哪些属性会触合成。但并不是CSS中所有的属性都可以用于CSS Animation和Transition中的。在W3C官方规范中明确定了哪些CSS属性可以用于Animation和Transition中。@Rodney Rehm还对这些属性做过一个兼容测试。如果你想深入的了解这方面的知识，建议您阅读下面两篇文章： CSS animatable properties Thank God We Have A Specification! 如此一来，我们知道可用于CSS Animation或者Transition的CSS属性之后，再配合CSS Triggers网站，可以轻易掌握哪些CSS属性会触发重排、重绘和合成等。虽然无法避免，但我们可以尽量控制。 七、性能优化如果我们知道浏览器是如何渲染一个页面的，并且去优化渲染过程中的关键步骤，不是是就能事半功倍呢？ 有关于这部分的介绍，建议大家阅读《渲染性能》。 在像素渲染流水线中，得知，如果我们能幸运的避免Layout和Paint，那么性能是最好的，言外之意，动画性能也将变得最佳。那么在CSS中可能通过不同的方式来创建新图层。其实这也就是大家常说的，通过CSS的属性来触发GPU加速。浏览器会为此元素单独创建一个“层”。当有单独的层之后，此元素的Repaint操作将只需要更新自己，不用影响到别人。你可以将其理解为局部更新。所以开启了硬件加速的动画会变得流畅很多。 为什么开启硬件加速动画就会变得流畅，那是因为开启硬件加速动画的元素都有一个独立的Render进程。Render进程中包含了主线程和合成线程，主线程负责： JavaScript的执行 CSS样式计算 计算Layout 将页面元素绘制成位图(Paint) 发送位图给合成线程 合成线程则主要负责： 将位图发送给GPU 计算页面的可见部分和即将可见部分(滚动) 通知GPU绘制位图到屏幕上(Draw) 我们可以得到一个大概的浏览器线程模型： 我们可以将页面绘制的过程分为三个部分：Layout、Paint和合成。Layout负责计算DOM元素的布局关系，Paint负责将DOM元素绘制成位图，合成则负责将位图发送给GPU绘制到屏幕上（如果有transform、opacity等属性则通知GPU做处理）。 GPU加速其实是一直存在的，而如同translate3D这种hack只是为了让这个元素生成独立的 GraphicsLayer ， 占用一部分内存，但同时也会在动画或者Repaint的时候不会影响到其他任何元素，对高刷新频率的东西，就应该分离出单独的一个 GraphicsLayer。 GPU对于动画图形的渲染处理比CPU要快。 RenderLayer 树，满足以下任意一点的就会生成独立一个 RenderLayer 页面的根节点的RenderObject 有明确的CSS定位属性（relative，absolute或者transform） 是透明的 有CSS overflow、CSS alpha遮罩（alpha mash）或者CSS reflection 有CSS 滤镜（fliter） 3D环境或者2D加速环境的canvas元素对应的RenderObject video元素对应的RenderObject 每个RenderLayer 有多个 GraphicsLayer 存在 有3D或者perspective transform的CSS属性的层 使用加速视频解码的video元素的层 3D或者加速2D环境下的canvas元素的层 插件，比如flash（Layer is used for a composited plugin） 对opacity和transform应用了CSS动画的层 使用了加速CSS滤镜（filters）的层 有合成层后代的层 同合成层重叠，且在该合成层上面（z-index）渲染的层 每个GraphicsLayer 生成一个 GraphicsContext, 就是一个位图，传送给GPU，由GPU合成放出。 那么就是说，GraphicsLayer过少则每次repaint大整体的工作量巨大，而过多则repaint小碎块的次数过多。这种次数过多就称为 层数爆炸 ，为了防止这个爆炸 Blink 引擎做了一个特殊处理。 有关于这部分内容的详细介绍，可以阅读《无线性能优化：Composite》一文。 扯了这么多，我们可以稍微总结一下下： 不是所有属性动画消耗的性能都一样，其中消耗最低的是transform和opacity两个属性（当然还有会触发Composite的其他CSS属性），其次是Paint相关属性。所以在制作动画时，建议使用transform的translate替代margin或position中的top、right、bottom和left，同时使用transform中的scaleX或者scaleY来替代width和height。 为了确保页面的流程，必须保证60fps内不发生两次渲染树更新，比如下图，16ms内只发生如下几个操作则是正常及正确的： 页面滚动时，需要避免不必要的渲染及长时间渲染。其中不必要的渲染包括： position:fixed;。fixed定位在滚动时会不停的进行渲染，特别是页面顶部有一个fixed，页面底部有个类似返回顶部的fixed，则在滚动时会对整个页面进行渲染，效率非常低。可以通过transform: translateZ(0)或者transform: translate3d(0,0,0)来解决 overflow:scroll。前面说了，而在滚动也会触发Repaint和Reflow。在调试过程中注意到一个有趣的现象，有时打开了页面并不会导致crash，但快速滑动的时候却会。由于crash是页面本身内存占比过高，只要优化了页面的内存占用，滑动自然也不会是很大的问题。无论你在什么时候滑动页面，页面滚动都是一个不断重新组合重新绘制的过程。所以减少渲染区域在滚动里就显得非常重要。 CSS伪类触发。有些CSS伪类在页面滚动时会不小心触发到。比如:hover效果有box-shadow、border-radius等比较耗时的CSS属性时，建议页面滚动时，先取消:hover效果，滚动停止后再加上:hover效果。这个可以通过在外层添加类名进行控制。但添加类名、删除类名也会改变元素时，浏览器就会要重新做一次计算和布局。所以千万要小心这种无意触发重新布局的操作，有的时候可能不是动画，但去付出的代价要比做一个动画更加昂贵。也就是说classname变化了，就一定会出现一次rendering计算，如果一定需要这么做，那可以使用 classlist 的方法。 touch事件的监听 长时间渲染包括： 复杂的CSS Image Decodes：特别是图片的Image Decodes及Image Resize这两个过程在移动端是非常耗时的 Large Empty Layers: 大的空图层]]></content>
      <tags>
        <tag>css</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-transform-matrix]]></title>
    <url>%2F2018%2F03%2F22%2Fcss-transform-matrix%2F</url>
    <content type="text"><![CDATA[一、矩阵先看一段 css 代码： 12345/* 2D */transform: matrix(1, 0, 0, 1, 0, 0);/* 3D */transform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); 上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。 大多数人在使用 transform 变换时很少直接使用 matrix 矩阵，更多的时候，我们会使用类似如下语法： 1transform: translateX(100px) rotateZ(30deg); 但其实，这只是一个语法糖，其底层依然使用的是 matrix。如果想要理解矩阵为何可以应用到 2D/3D 变换，需要从几何的角度去理解矩阵。不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量。 二、向量用一句话描述向量是什么：向量是空间中的箭头 。这个箭头由两个因素决定：方向 和 长度，我们先把目光局限在二维空间下，如图： 上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。 下面我们再进一步，我们重新用一句话来描述向量： 向量是有序的数字列表。 假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图： 在坐标系中，由于坐标通常用来标示一个点，如 P(2, 8) 表示点 P 的坐标为 (2, 8)，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的： 在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示： 对于向量，你只需要知道它是空间中的箭头或者有序的数字列表这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 基向量。 基向量，也叫单位向量，是单位长度为1的向量，如下图中：i帽 和j帽 就是这个二维坐标系的基向量： 对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。 三、线性变换我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图： 变换前： 变换后： 不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件： - 直线在变换后仍然为直线，不能有所弯曲- 原点不能移动 如下变换，就不是一个线性变换，因为直线变成了曲线： 四、如何用数值描述线性变换？在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换后，必然会引起有序数字列表的变换，那么我们是否可以用数字去描述变换呢？ 之前在向量一节中，我们了解过基向量，单位长度为1，其实空间中的任意一个向量我们都可以看做是：基向量变换后的和向量，如下图： 向量 v 的坐标是 如果我们把 3 和 -2 看做两个标量，也就是纯数字，那么向量 v可以看做是基向量被标量缩放后相加得到的和向量： v = 3i + (-2j)。 了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量v = -1i + 2j，如下图： 此时，基向量 i的坐标是(1, 0)，基向量 j 的坐标是 (0, 1)，假设经过了某些变换之后，基向量 i 的坐标变为(1， -2)，基向量 j 的坐标变为 (3， 0)，如下图： 那么变换后的向量 v 依然满足 v = -1i + 2j，如下： 以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。 既然线性变换前后都满足该线性关系：v = -1i + 2j 那么很容易根据变换后 i帽 和 j帽 的坐标推算出变换后 v 的坐标： 也就是(5, 2)，即： 那么我们是否可以认为，给定任意一个向量，其坐标(x, y)，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 i帽 和j帽 如下图： 那么任意向量 (x, y) 在经过变换后的坐标计算如下： 这告诉我们另外一个事实，二维空间的线性变换仅由四个数字完全确定，这四个数字就是基向量 i 变换后 i帽 的坐标，以及基向量 j 变换后 j帽 的坐标，如下图： 是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 2 x 2 的格子中，我们称之为 2 x 2 矩阵： 现在，当你再看到 2 x 2 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。 我们把情况一般化，如下图： 我们有一个 2 x 2 的矩阵 [a, c][b, d]，其中 [a, c] 是基向量 i 变换后的坐标，[b, d] 是基向量 j 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 [x, y] 变换后的坐标： 实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。 到了这里，让我们整理一下思路，首先，对于一个 2 x 2 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 i 的变换，第二列的两个数是对基向量 j 的变换，这四个数字组成的 2 x 2 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。 其实我么你还可以换一个角度考虑，我们就单纯的把 2 x 2 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。 五、回到 CSS 的 transform说了一大堆，是时候回到 CSS 的 transform，我们来看一下2D变换下 transform 属性的 matrix 写法： 1transform: matrix(a, b, c, d, e, f); 在文章开始，我们知道各个参数默认值如下： 1transform: matrix(1, 0, 0, 1, 0, 0); 有的同学可能会问：说好的 2 x 2 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，transform 2D变换是一个 3 * 3 的矩阵，为什么是这样？因为：位移(translate)，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 2 x 2 矩阵满足不了需求，只能再加一列，也就是 3 x 3 的矩阵。 把 matrix 中的 a b c d e f 放到一个 3 x 3 的矩阵中应该是这样的： 其实，在没有位移(translate)的情况下，[a, b][c, d]四个数字组成的 2 x 2 矩阵是完全可以描述2D变换的，现在我们只看由 [a, b][c, d]组成的 2 x 2 矩阵： 我们把 a b c d 四个数字使用默认值替换一下，即：a = 1，b = 0，c = 0，d = 1，如下： 通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标(1, 0) 应该是基向量 i 变换后的坐标，但是基向量 i 在变换前的坐标就是(1, 0)，也就是说没有任何变换，同理，基向量 j 也没有任何变换，所以说，这就是 a b c d 默认值设定为下面代码所示的值的原因： 123transform: matrix(a, b, c, d, e, f);// a b c d 默认值为 1 0 0 1transform: matrix(1, 0, 0, 1, e, f); 那么大家想想一下，我们把 a 的值从 1 变为 2 会发生什么？如果把 a 的值从 1 变为 2 那么矩阵如下： 也就是说，基向量 i 的坐标从(1, 0)变成了(2, 0)，这是在干什么？是不是基向量 i 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 a 的值从 1 变为 0.5 则意味着把基向量 i 缩小为原来的一半。事实上：在 transform: matrix() 中，修改 a 的值，就是在改变 x 轴方向的缩放比例： 123transform: matrix(2, 0, 0, 1, 0, 0);/* 等价于 */transform: scaleX(2); 相信大家已经知道了，修改 d 的值，就是改变 y 轴的缩放比例： 123transform: matrix(1, 0, 0, 4, 0, 0);/* 等价于 */transform: scaleY(4); 那么旋转要如何修改 matrix 中的值呢？其实，想要知道如何修改 a b c d 的值，只需要知道，旋转后基向量 i 和 j 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 i 和 j 的坐标。 我们知道，在 web 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下： 而在 web 开发中，坐标系的正方向选取是这样的： 假设我们将其顺时针旋转 45 度，如下图： 假设，上图中我们旋转的是单位向量，那么旋转后单位向量 i 的坐标应该是(cosθ, sinθ)，单位向量 j 的坐标应该是 (-sinθ, cosθ)，所以如果用矩阵表示的话，应该是这样的： 如果写到 matrix 里，自然就是下面这个样子： 1transform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0) 所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的： 12345678/* * Math.cos(Math.PI / 180 * 45) = 0.707106 * Math.sin(Math.PI / 180 * 45) = 0.707106 */transform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)/* 等价于 */transform: rotate(45deg); 通过上面缩放和旋转的例子，我们已经知道了，2 x 2 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 transform 中，除了缩放(scale)、旋转(rotate) 还有倾斜(skew)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则： 1transform: matrix(1, tan(θy), tan(θx), 1, 0, 0); 大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。 无论 缩放(scale)、旋转(rotate) 还是倾斜(skew)，他们都不会是原点发生改变，所以使用 a b c d 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(translate)，这时，就不得不提到 e f 了，我想我不说大家也都知道了，e f 分别代表了 x y 方向的位移，事实也如大家所想： 123transform: matrix(1, 0, 0, 1, 100, 200)/* 等价于 */transform: translateX(100px) translateY(200px); 至此，transform 使用 3 x 3 矩阵： 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。 除了2D变换，还有3D变换，在 transform 中，使用 4 x 4 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 3 x 3 的矩阵就可以描述了，那么为什么搞了一个 4 x 4矩阵呢？实际上这和我们在将二维空间的变换使用 3 x 3 矩阵的道理是一样的，那就是位移。 我们来看一下3D变换的 matrix 默认值： 12transform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);transform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); 这十六个数字就是 4 x 4 矩阵的 16 个数值： 如果换成对应数字，是这样的： 类似于我们讲解 2D 变换一样，其中由 组成的 3 x 3 矩阵用来描述空间的 3D 线性变换，如：rotateX rotateY scaleZ 等等，注意：rotateZ 是 2D 变换哦。 而 m n o 则分别用来描述位移：translateX translateY translateZ。]]></content>
      <tags>
        <tag>css</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-transform与坐标系统]]></title>
    <url>%2F2018%2F03%2F21%2Fcss-transform%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一、 坐标系统我们很熟悉的网页是平面的，一个DOM元素会有一个初始坐标系（initial coordinate system）： 每一个DOM元素都有一个这样的初始坐标系。其中，原点位于元素的左上角，z轴指向观察者。初始坐标系的z轴并不算是三维空间，而是像z-index那样作为参照，决定网页元素的绘制顺序，绘制顺序靠后的元素将覆盖绘制顺序靠前的。 在使用transform的时候，情况则有所不同。transform所参照的并不是初始坐标系，而是一个新的坐标系： transform所用的这个坐标系，相比初始坐标系，x、y、z轴的指向都不变，只是原点位置移动到了元素的正中心。如果想要改变这个坐标系的原点位置，使用transform-origin。transform-origin的默认值是50% 50%，因此，默认情况下，transform坐标系的原点位于元素中心。 二、变换函数顺序我们都可能像 1transform: rotateY(45deg) translateX(100px); 这样使用多个变换函数。这种时候，需要意识到变换函数的顺序。这是因为，每一个变换函数不仅改变了元素，同时也会改变和元素关联的transform坐标系，当变换函数依次执行时，后一个变换函数总是基于前一个变换后的新transform坐标系。 三、transform-origintransform-origin属性是所有矩阵计算的一个重要依据点 1234567891011121314151617181920212223242526272829.anim_image &#123; -webkit-transition: all 1s ease-in-out; -moz-transition: all 1s ease-in-out; -o-transition: all 1s ease-in-out; transition: all 1s ease-in-out; cursor:pointer;&#125;.anim_image_top &#123; position: absolute; -webkit-transform: scale(0, 0); opacity: 0; filter: Alpha(opacity=0);&#125;.anim_box:hover .anim_image_top , .anim_box_hover .anim_image_top &#123; opacity: 1; filter: Alpha(opacity=100); -webkit-transform: scale(1, 1); -webkit-transform-origin: top right; &#125; .anim_box:hover .anim_image_bottom, .anim_box_hover .anim_image_bottom &#123; -webkit-transform: scale(0, 0); -webkit-transform-origin: bottom left;&#125; 1234&lt;div id="testBox" class="demo anim_box"&gt; &lt;img class="anim_image anim_image_top" src="/ps6.jpg" /&gt; &lt;img class="anim_image anim_image_bottom" src="/ps4.jpg" /&gt;&lt;/div&gt; Demo ：http://www.zhangxinxu.com/study/201011/css3-transition-animate-demo-11.html]]></content>
      <tags>
        <tag>css</tag>
        <tag>transform</tag>
        <tag>坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-视差滚动效果]]></title>
    <url>%2F2018%2F03%2F19%2Fcss-%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223.demo &#123; perspective: 2px; padding: 0; height: 600px; height: calc(100vh - 300px); overflow: auto;&#125;.box &#123; height: 1280px; transform-style: preserve-3d; position: relative;&#125;.iphone &#123; position: absolute; left: 50%; transform: translate3D(-50%, -120px, -4px) scale(3);&#125; .smile, .flower, .music, .pdf &#123; /* 略... */ &#125; 123456789&lt;div class="demo"&gt; &lt;div class="box"&gt; &lt;img src="mobile_1_iphone.jpg" class="iphone"&gt; &lt;i class="smile"&gt;&lt;/i&gt; &lt;i class="flower"&gt;&lt;/i&gt; &lt;i class="music"&gt;&lt;/i&gt; &lt;i class="pdf"&gt;&lt;/i&gt; &lt;/div&gt;&lt;/div&gt; 3D视角示意图 当我们在屏幕前面2个单位(perspective: 2px; )的地方，看屏幕后面4个单位(transform: translate3D(-50%, -120px, -4px) scale(3);)的元素，肉眼所见的画面大小只有实际的1/3，即所谓的近大远小。此时scale(3)让内容放大到原来3倍，正好在平面上看上去好像是原来大小。 虽然肉眼所见体积似乎是1:1，但是，滚动时候的位移变化还是1:3。网页中的3D就是模拟真实世界的3D效果，因此，也会有这种视差体验。]]></content>
      <tags>
        <tag>css</tag>
        <tag>视差</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-简单工厂模式]]></title>
    <url>%2F2018%2F03%2F18%2Fjs-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、工厂模式12345678910function createBlog(name, url) &#123; let obj = new Object(); obj.name = name; obj.url = url; obj.sayUrl= function() &#123; alert(this.url); &#125; return obj;&#125;var blog1 = createBlog('wuyuchang', 'http://www.jb51.net/'); 二、构造函数模式123456789function Blog(name, url) &#123; this.name = name; this.url = url; this.alertUrl = function() &#123; alert(this.url); &#125;&#125;let blog = new Blog('wuyuchang', 'http://www.jb51.net/'); 三、原型模式1234567891011function Blog() &#123;&#125;Blog.prototype.name = 'wuyuchang';Blog.prototype.url = 'http://tools.jb51.net/';Blog.prototype.friend = ['fr1', 'fr2', 'fr3', 'fr4'];Blog.prototype.alertInfo = function() &#123; alert(this.name + this.url + this.friend);&#125; 四、混合模式（原型模式 + 构造函数模式）123456789function Blog(name, url, friend) &#123; this.name = name; this.url = url; this.friend = friend;&#125;Blog.prototype.alertInfo = function() &#123; alert(this.name + this.url + this.friend);&#125; 五、动态原型模式12345678910111213function Blog(name, url) &#123; this.name = name; this.url = url; if (typeof this.alertInfo !== 'function') &#123; Blog.prototype.alertInfo = function() &#123; alert(thia.name + this.url); &#125; &#125;&#125;var blog = new Blog('wuyuchang', 'http://tools.jb51.net'); ​]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-单例模式]]></title>
    <url>%2F2018%2F03%2F18%2Fjs-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单体模式提供了一种将代码组织为一个逻辑单元的手段，这个逻辑单元中的代码可以通过单一变量进行访问。单体模式的优点是： 可以用来划分命名空间，减少全局变量的数量 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护 可以被实例化，且实例化一次 12345678910111213141516171819202122232425262728// 单体模式var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;CreateDiv.prototype.init = function() &#123; var div = document.createElement("div"); div.innerHTML = this.html; document.body.appendChild(div);&#125;;// 代理实现单体模式var ProxyMode = (function() &#123; var instance; return function(html) &#123; if (!instance) &#123; instance = new CreateDiv("我来测试下"); &#125; return instance; &#125;&#125;)();var a = new ProxyMode("aaa");var b = new ProxyMode("bbb");]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化上下文-BFC-IFC]]></title>
    <url>%2F2018%2F03%2F17%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87-BFC-IFC%2F</url>
    <content type="text"><![CDATA[想要理解BFC与IFC，首先要理解另外两个概念：Box 和 FC（即 formatting context） 一、Box一个页面是由很多个 Box 组成的，元素的类型和 display 属性决定了这个 Box 的类型。不同类型的 Box，会参与不同的 Formatting Context。 Block level的box会参与形成BFC，比如display值为block，list-item，table的元素。 Inline level的box会参与形成IFC，比如display值为inline，inline-table，inline-block的元素。 二、FC（Formatting Context）它是W3C CSS2.1规范中的一个概念，定义的是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 常见的Formatting Context 有： Block Formatting Context（BFC | 块级格式化上下文） Inline Formatting Context（IFC |行内格式化上下文） 三、IFC布局规则 在行内格式化上下文中，框(boxes)一个接一个地水平排列，起点是包含块的顶部 水平方向上的 margin，border 和 padding在框之间得到保留 框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐 包含那些框的长方形区域，会形成一行，叫做行框 四、BFC布局规则 内部的Box会一个接一个地垂直放置 每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动子元素也参与计算 五、形成一个BFC下列方式会创建块格式化上下文： 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、`table-row、table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或inline-table`） overflow 值不为 visible 的块元素 display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 `column-count为1`） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug） 六、外边距合并块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing） 注：浮动元素和绝对定位元素的外边距不会折叠（触发了 块格式化上下文 Block Formatting Context， BFC） 下面列出了会发生外边距折叠的三种基本情况： 相邻元素之间 毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动）。 父元素与其第一个或最后一个子元素之间 如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开； 或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。 空的块级元素 如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。 七、BFC用处1. 清除浮动1234&lt;div class="wrap"&gt; &lt;section&gt;1&lt;/section&gt; &lt;section&gt;2&lt;/section&gt;&lt;/div&gt; 1234567891011.wrap &#123; border: 2px solid yellow; width: 250px;&#125;section &#123; background-color: pink; float: left; width: 100px; height: 100px;&#125; 可以看到，由于子元素都是浮动的，受浮动影响，边框为黄色的父元素的高度塌陷了。 解决方案：为 .wrap 加上 overflow: hidden;使其形成BFC，根据BFC规则第六条，计算高度时就会计算float的元素的高度，达到清除浮动影响的效果。 2. 防止垂直margin合并12&lt;section class="top"&gt;1&lt;/section&gt;&lt;section class="bottom"&gt;2&lt;/section&gt; 12345678910section &#123; background-color: pink; margin-bottom: 100px; width: 100px; height: 100px;&#125;.bottom &#123; margin-top: 100px;&#125; 可以看到，明明.top和.bottom中间加起来有200px的margin值，但是我们只能看到100px。这是因为他们的外边距相遇发生了合并。 怎样解决：为其中一个元素的外面包裹一层元素。并为这个外层元素设置 overflow: hidden;，使其形成BFC。因为BFC内部是一个独立的容器，所以不会与外部相互影响，可以防止margin合并。 1234&lt;section class="top"&gt;1&lt;/section&gt;&lt;div class="wrap"&gt; &lt;section class="bottom"&gt;2&lt;/section&gt;&lt;/div&gt; 123.wrap &#123; overflow: hidden;&#125; 2. 布局：自适应两栏布局1234&lt;div&gt; &lt;aside&gt;&lt;/aside&gt; &lt;main&gt;我是好多好多文字会换行的那种蛤蛤蛤蛤蛤蛤蛤蛤蛤蛤蛤蛤蛤&lt;/main&gt;&lt;/div&gt; 1234567891011121314div &#123; width: 200px;&#125;aside &#123; background-color: yellow; float: left; width: 100px; height: 50px;&#125;main &#123; background-color: pink;&#125; 可以看到右侧元素的一部分跑到了左侧元素下方 注： float元素的特点：背景重叠，文字环绕 float元素和main发生了重叠，如果float元素背景色为透明，可以看到main的背景色。 解决方案：为main设置 overflow: hidden; 触发main元素的BFC，根据规则第4、5条，BFC的区域是独立的，不会与页面其他元素相互影响，且不会与float元素重叠，因此就可以形成两列自适应布局]]></content>
      <tags>
        <tag>BFC</tag>
        <tag>IFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-观察者模式]]></title>
    <url>%2F2018%2F03%2F17%2Fjs-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。事实上，只要你曾经在DOM节点上绑定过事件函数，那么你就曾经使用过观察者模式了 123document.body.addEventListener('click', function () &#123; alert(2);&#125;); 但是这只是对观察者模式最简单的使用，在很多场景下我们经常会实现一些自定义事件来满足我们的需求。 1234举个例子：你去一家公司应聘，谈了一顿下来，hr跟你说:"好了，你回去等通知吧！"。这个时候，把自己的手机号留给hr，然后等他给你打电话。那么这个时候，hr就相当于一个发布者，而你就是一个订阅者啦！ 那么一个简单的观察者模式应该怎么实现呢？ 要指定一个发布者； 给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者； 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发订阅者回调函数； 1234567891011121314151617181920var event = &#123;&#125;; //发布者（hr）event.clietList = []; //发布者的缓存列表（应聘者列表）event.listen = function(fn) &#123; //增加订阅者函数 this.clietList.push(fn);&#125;;event.trigger = function() &#123; //发布消息函数 for (var i = 0; i &lt; this.clietList.length; i++) &#123; var fn = this.clietList[i]; fn.apply(this, arguments); &#125;&#125;;event.listen(function(time) &#123; //某人订阅了这个消息 console.log('正式上班时间：' + time);&#125;);event.trigger('2016/10', yes); //发布消息//输出 正式上班时间:2016/10 到这里，我们已经实现了一个最简单的观察者模式了！ 但是上面的函数其实存在一个问题，那就是发布者没办法选择自己要发布的消息类型！比如这家公司同时在招php，web前端，如果使用上面的函数就没办法区分职位了！只能一次性把全部订阅者都发送一遍消息。 对上面的代码进行改写： 1234567891011121314151617181920212223242526272829303132var event = &#123;&#125;; //发布者（hr）event.clietList = []; //发布者的缓存列表（应聘者列表）event.listen = function(key, fn) &#123; //增加订阅者函数 if (!this.clietList[key]) &#123; this.clietList[key] = []; &#125; this.clietList[key].push(fn);&#125;;event.trigger = function() &#123; //发布消息函数 var key = Array.prototype.shift.call(arguments); fns = this.clietList[key]; for (var i = 0; i &lt; fns.length; i++) &#123; var fn = fns[i]; fn.apply(this, arguments); &#125;&#125;;event.listen('web前端', function(time) &#123; //小强订阅了这个消息。 console.log('姓名：小强'); console.log('正式上班时间：' + time);&#125;);event.listen('php', function(time) &#123; //大大强订阅了这个消息 console.log('姓名：大大强'); console.log('正式上班时间：' + time);&#125;);//发布者发布消息event.trigger('web前端', '2016/10'); //姓名：小强 正式上班时间：2016/10 event.trigger('php', '2016/15'); //姓名：大大强 正式上班时间：2016/15 通过添加了一个key，我们实现了对职位的判断。有了订阅事件，我们怎么能少了取消订阅事件呢？ 12345678910111213141516171819202122232425262728293031323334event.remove = function(key, fn) &#123; var fns = this.clietList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; //如果没有传入fn回调函数，直接取消key对应消息的所有订阅 this.clietList[key] = []; &#125; else &#123; for (var i = 0; i &lt; fns.length; i++) &#123; //遍历回调函数列表 var _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); //删除订阅者的回调函数 &#125; &#125; &#125;&#125;;//这时候必须指定回调函数，否则无法在remove函数中进行对比删除。event.listen('web前端', fn1 = function(time) &#123; //小强订阅了这个消息。 console.log('姓名：小强'); console.log('正式上班时间：' + time);&#125;);event.listen('web前端', fn2 = function(time) &#123; //大大强订阅了这个消息 console.log('姓名：大大强'); console.log('正式上班时间：' + time);&#125;);event.remove('web前端', fn1);//发布者发布消息event.trigger('web前端', '2016/10');//输出 姓名：大大强 正式上班时间：2016/10 对上面代码进行改进，创建一个全局对象来实现观察者模式，使用闭包实现私有变量，仅暴露必须的API给使用者： 12345678910111213141516171819202122232425262728293031323334353637383940414243var event = (function() &#123; var clietList = []; //发布者的缓存列表（应聘者列表） var listen = function(key, fn) &#123; //增加订阅者函数 if (!this.clietList[key]) &#123; this.clietList[key] = []; &#125; this.clietList[key].push(fn); &#125;; var trigger = function() &#123; //发布消息函数 var key = Array.prototype.shift.call(arguments), fns = this.clietList[key]; for (var i = 0; i &lt; fns.length; i++) &#123; var fn = fns[i]; fn.apply(this, arguments); &#125; &#125;; var remove = function(key, fn) &#123; var fns = this.clietList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; //如果没有传入fn回调函数，直接取消key对应消息的所有订阅 this.clietList[key] = []; &#125; else &#123; for (var i = 0; i &lt; fns.length; i++) &#123; //遍历回调函数列表 var _fn = fns[i]; if (_fn === fn) &#123; fns.splice(i, 1); //删除订阅者的回调函数 &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Promise-all-race]]></title>
    <url>%2F2018%2F03%2F13%2FJS-Promise-all-race%2F</url>
    <content type="text"><![CDATA[一、Promise.all()1const p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况 : 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 三、Promise.race()1const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); 如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-几点原则]]></title>
    <url>%2F2018%2F03%2F10%2Fcss-%E5%87%A0%E7%82%B9%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1.不要写不需要的样式定义 减少CSS文件的长度，以便浏览。 明确你的CSS类需要做什么，而不是定义一堆已经产生的垃圾。 2.将CSS看作可重用组件定义可重用的CSS和组件以供自己使用，则可以减少很多复杂性，重用类的作用： 确保你的设计风格在不同的页面之间保持一致 提高编写CSS效率 123456789101112131415161718192021222324252627282930313233343536373839.hide &#123; display: none;&#125;.text-center &#123; text-align: center;&#125;.padding-0 &#123; padding: 0;&#125;.padding-xxs &#123; padding: 5px;&#125;.padding-xs &#123; padding: 10px;&#125;.padding-sm &#123; padding: 20px;&#125;.padding-md &#123; padding: 30px;&#125;.padding-lg &#123; padding: 40px;&#125;.padding-xl &#123; padding: 50px;&#125;.padding-xxl &#123; padding: 60px;&#125; 3.除非绝对需要，否则避免嵌套12345678910a &#123; color: blue; &amp;:hover &#123; color: black; &#125;&#125;.link--red &#123; color: red;&#125; 4.利用BEM防止嵌套防止过度嵌套的一个策略是名为BEM（Block Element Modifier）的命名策略 BEM的意思就是块（block）、元素（element）、修饰符（modifier），是由Yandex团队提出的一种CSS Class 命名方法。 类似于： 1234567891011.block&#123;&#125; .block__element&#123;&#125; .block--modifier&#123;&#125;.block__element--modifie&#123;&#125; /**或者*/.type-block&#123;&#125;.type-block__elementr&#123;&#125;.type-block_modifier&#123;&#125;.type-block__element_modifier&#123;&#125; block：封装一个独立的实体，它本身是有意义的。尽管块可以嵌套并相互交互，但在语义上它们保持平等; 没有优先级或层次结构 。 块的一部分，没有独立的含义。任何元素都在语义上与其块相关联。 在块或元素上的标志。使用它们来改变外观，行为或状态。 123&lt;div class=”profile”&gt; &lt;img src=”person.jpg” class=”profile__photo”/&gt;&lt;/div&gt; 123456789.profile &#123; background-color: white; border: 1px solid #ccc;&#125;.profile__photo &#123; border-radius: 50%; border: 1px solid #000;&#125; 5.只使用 inportant 作为最后的手段]]></content>
      <tags>
        <tag>css</tag>
        <tag>原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[video与audio对象]]></title>
    <url>%2F2018%2F03%2F09%2Fvideo%E4%B8%8Eaudio%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[对象属性 autoplay 设置或返回是否在就绪（加载完成）后随即播放视频 buffered 返回表示视频已缓冲部分的 TimeRanges 对象 controls 设置或返回视频是否应该显示控件（比如播放/暂停等） currentSrc 返回当前视频的 URL src 设置或返回视频的 src 属性的值 currentTime 设置或返回视频中的当前播放位置（以秒计） duration 返回视频的长度（以秒计） defaultPlaybackRate 设置或返回视频的默认播放速度 playbackRate 设置或返回视频播放的速度 ended 返回视频的播放是否已结束 height 设置或返回视频的 height 属性的值 width 设置或返回视频的 width 属性的值 loop 设置或返回视频是否应在结束时再次播放 mediaGroup 设置或返回视频所属媒介组合的名称 muted 设置或返回是否关闭声音 volume 设置或返回视频的音量 networkState 返回视频的当前网络状态 readyState 返回视频当前的就绪状态 load() 重新加载视频元素 play() 开始播放视频 pause() 暂停当前播放的视频]]></content>
      <tags>
        <tag>video</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html-meta]]></title>
    <url>%2F2018%2F03%2F07%2Fhtml-meta%2F</url>
    <content type="text"><![CDATA[一、name属性name属性主要用于描述网页，与之对应的属性值为content content中的内容是对name填入类型的具体描述，便于搜索引擎查找以及分类信息 meta标签中name属性语法格式是： 1&lt;meta name="参数" content="具体的描述"&gt; A. keywords(关键字)说明：用于告诉搜索引擎，你网页的关键字 1&lt;meta name="keywords" content="Lxxyx,博客，文科生，前端"&gt; B. description(网站内容的描述)说明：用于告诉搜索引擎，你网站的主要内容。 1&lt;meta name="description" content="文科生，热爱前端与编程。目前大二，这是我的前端博客"&gt; C. viewport(移动端的窗口)说明：这个属性常用于设计移动端网页 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; D. robots(定义搜索引擎爬虫的索引方式)说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 1&lt;meta name="robots" content="none"&gt; 具体参数如下： none : 搜索引擎将忽略此网页，等价于noindex，nofollow。 noindex : 搜索引擎不索引此网页。 nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。 all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。 index : 搜索引擎索引此网页。 follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 E. author(作者)说明：用于标注网页作者 1&lt;meta name="author" content="Lxxyx,841380530@qq.com"&gt; F. generator(网页制作软件)说明：用于标明网页是什么软件做的 1&lt;meta name="generator" content="Sublime Text3"&gt; G. copyright(版权)说明：用于标注版权信息 1&lt;meta name="copyright" content="Lxxyx"&gt; H. revisit-after(搜索引擎爬虫重访时间)说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。 如果重访时间过短，爬虫将按它们定义的默认时间来访问。 1&lt;meta name="revisit-after" content="7 days" &gt; I. renderer(双核浏览器渲染方式)说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。 123&lt;meta name="renderer" content="webkit"&gt; //默认webkit内核&lt;meta name="renderer" content="ie-comp"&gt; //默认IE兼容模式&lt;meta name="renderer" content="ie-stand"&gt; //默认IE标准模式 二、 http-equiv属性http-equiv传回一些有用的信息，以帮助浏览器正确和精确地显示网页内容 meta标签中http-equiv属性语法格式是： 1&lt;meta http-equiv="参数" content="具体的描述"&gt; A. content-Type(设定网页字符集)说明：用于设定网页字符集，便于浏览器解析与渲染页面 12&lt;meta http-equiv="content-Type" content="text/html;charset=utf-8"&gt; //旧的HTML，不推荐&lt;meta charset="utf-8"&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)说明：用于告知浏览器以何种版本来渲染页面 12//如果安装了GCF插件，则使用GCF来渲染页面，否则使用最高版本的IE内核进行渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt; 注： http-equiv=”X-UA-Compatible”是IE8的专用标记，是用来指定IE8浏览器模拟某个特定版本IE浏览器的渲染方式，以此来解决IE浏览器的兼容问题。 X-UA-Compatible 中的IE=edge指令，可以让IE或者调用IE内核的浏览器，使用标准模式渲染网页，注意这里和“Edge浏览器”无关，只是恰巧重名罢了。 Google Chrome Frame(谷歌内嵌浏览器框架GCF)：使用的是Google Chrome浏览器内核来渲染，而且支持IE6、7、8等多个版本的IE浏览器 X-UA-Compatible值 说明 IE=5 让浏览器使用Quirks mode来显示，实际上是使用Internet Explorer 7 的 Quirks 模式来显示内容，这个模式和IE5非常相似。 IE=edge 这个设置是让IE使用当前的最高版本进行文档的解析，官方文档指明，edge模式仅适用在测试环境，不建议在生产环境中使用 IE=7 使用标准IE7来处理 IE=EmulateIE7 模拟IE7来处理，遵循 &lt;!DOCTYPE&gt; 指令，如果文档有当前有一个合法的&lt;!DOCTYPE&gt;，就使用IE7模式，否者使用Quirks模式（Internet Explorer 5 Quirks），对于大部分网站来说，这是首选的兼容性模式 IE=8 标准IE8 IE=EmulateIE8 模拟IE8，遵循 &lt;!DOCTYPE&gt; 指令，参照IE=EmulateIE7说明 IE=9 标准IE9 IE=EmulateIE9 模拟IE9，遵循 &lt;!DOCTYPE&gt; 指令，参照IE=EmulateIE7说明 chrome=1 强制使用Chrome，需要IE下Chrome插件支持 IE=EmulateIE10 模拟IE10 IE=10 标准IE10，遵循 &lt;!DOCTYPE&gt; 指令，参照IE=EmulateIE7说明 C. cache-control(指定请求和响应遵循的缓存机制)说明：指导浏览器如何缓存某个响应以及缓存多长时间 1&lt;meta http-equiv="cache-control" content="no-cache"&gt; 共有以下几种用法： no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。 no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private : 只为单个用户缓存，因此不允许任何中继进行缓存。 maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。 例如：max-age=60表示响应可以再缓存和重用 60 秒。 D. expires(网页到期时间)说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。 1&lt;meta http-equiv="expires" content="Sunday 26 October 2016 01:00 GMT" /&gt; E. refresh(自动刷新并指向某页面)说明：网页将在设定的时间内，自动刷新并调向设定的网址。 12//意思是2秒后跳转向我的博客&lt;meta http-equiv="refresh" content="2；URL=http://www.lxxyx.win/"&gt; F. Set-Cookie(cookie设定)说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。 12&lt;meta http-equiv="Set-Cookie" content="name, date"&gt; //格式&lt;meta http-equiv="Set-Cookie" content="path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT"&gt;]]></content>
      <tags>
        <tag>html</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-变量]]></title>
    <url>%2F2018%2F03%2F07%2Fcss-%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[一、变量的声明声明变量的时候，变量名前面要加两根连词线--，变量名大小写敏感 1234body &#123; --foo: #7F583F; --bar: #F7EFD2;&#125; 上面代码中，body选择器里面声明了两个变量：--foo和--bar。它们与正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做”CSS 自定义属性”（CSS custom properties）。因为变量与自定义的 CSS 属性其实是一回事。 各种值都可以放入 CSS 变量 12345678910111213141516171819:root &#123; --main-color: #4d4e53; --main-bg: rgb(255, 255, 255); --logo-border-color: rebeccapurple; --header-height: 68px; --content-padding: 10px 20px; --base-line-height: 1.428571429; --transition-duration: .35s; --external-link: "external link"; --margin-top: calc(2vh + 20px);&#125; 二、var() 函数var()函数用于读取变量。 1234a &#123; color: var(--foo); text-decoration-color: var(--bar);&#125; var()函数还可以使用第二个参数，表示变量的默认值。如果该变量不存在，就会使用这个默认值。 1color: var(--foo, #7F583F); 第二个参数不处理内部的逗号或空格，都视作参数的一部分。 12var(--font-stack, "Roboto", "Helvetica");var(--pad, 10px 15px 20px); var()函数还可以用在变量的声明。 1234:root &#123; --primary-color: red; --logo-text: var(--primary-color);&#125; 注意，变量值只能用作属性值，不能用作属性名。 12345.foo &#123; --side: margin-top; /* 无效 */ var(--side): 20px;&#125; 上面代码中，变量–side用作属性名，这是无效的。 三、变量值的类型如果变量值是一个字符串，可以与其他字符串拼接。 12--bar: 'hello';--foo: var(--bar)' world'; ​ 利用这一点，可以 debug（例子）。 123body:after &#123; content: '--screen-category : 'var(--screen-category);&#125; 如果变量值是数值，不能与数值单位直接连用。 12345.foo &#123; --gap: 20; /* 无效 */ margin-top: var(--gap)px;&#125; 上面代码中，数值与单位直接写在一起，这是无效的。必须使用calc()函数，将它们连接。 1234.foo &#123; --gap: 20; margin-top: calc(var(--gap) * 1px);&#125; 如果变量值带有单位，就不能写成字符串。 1234567891011121314/* 无效 */.foo &#123; --foo: '20px'; font-size: var(--foo);&#125;/* 有效 */.foo &#123; --foo: 20px; font-size: var(--foo);&#125; 四、作用域同一个 CSS 变量，可以在多个选择器内声明。读取的时候，优先级最高的声明生效。这与 CSS 的”层叠”（cascade）规则是一致的。下面是一个例子。 123&lt;p&gt;蓝色&lt;/p&gt;&lt;div&gt;绿色&lt;/div&gt;&lt;div id="alert"&gt;红色&lt;/div&gt; 123456789101112131415:root &#123; --color: blue;&#125;div &#123; --color: green;&#125;#alert &#123; --color: red;&#125;* &#123; color: var(--color);&#125; 上面代码中，三个选择器都声明了--color变量。不同元素读取这个变量的时候，会采用优先级最高的规则，因此三段文字的颜色是不一样的。这就是说，变量的作用域就是它所在的选择器的有效范围。 1234567body &#123; --foo: #7F583F;&#125;.content &#123; --bar: #F7EFD2;&#125; 上面代码中，变量–foo的作用域是body选择器的生效范围，–bar的作用域是.content选择器的生效范围。由于这个原因，全局的变量通常放在根元素:root里面，确保任何选择器都可以读取它们。 123:root &#123; --main-color: #06c;&#125; 五、响应式布局CSS 是动态的，页面的任何变化，都会导致采用的规则变化。 利用这个特点，可以在响应式布局的media命令里面声明变量，使得不同的屏幕宽度有不同的变量值。 12345678910111213141516body &#123; --primary: #7F583F; --secondary: #F7EFD2;&#125;a &#123; color: var(--primary); text-decoration-color: var(--secondary);&#125;@media screen and (min-width: 768px) &#123; body &#123; --primary: #F7EFD2; --secondary: #7F583F; &#125;&#125; 六、设置CSS变量1、HTML标签中设置CSS变量123&lt;div style="--color: #cd0000;"&gt; &lt;img src="mm.jpg" style="border: 10px solid var(--color);"&gt;&lt;/div&gt; 2、JS中设置CSS变量123&lt;div id="box"&gt; &lt;img src="mm.jpg" style="border: 10px solid var(--color);"&gt;&lt;/div&gt; 1box.style.setProperty('--color', '#cd0000'); 3、JS中获取CSS变量123456// 获取 --color CSS 变量值var cssVarColor = getComputedStyle(box).getPropertyValue('--color'); // 输出cssVarColor// 输出变量值是：#cd0000 console.log(cssVarColor); 注：由此可见，CSS变量与自定义的 CSS 属性其实是一回事]]></content>
      <tags>
        <tag>css</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-盒子垂直水平居中]]></title>
    <url>%2F2018%2F03%2F05%2Fcss-%E7%9B%92%E5%AD%90%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1、定位+盒子宽高已知 12position: absolute; left: 50%; top: 50%; margin-left:-自身一半宽度; margin-top: -自身一半高度; 2、table-cell布局 1234/*父级*/display: table-cell; vertical-align: middle; /*子级*/margin: 0 auto; 3、定位 + transform ; 适用于 子盒子 宽高不定时 123456position: absolute; /*top和left偏移各为50%*/top: 50%;left: 50%; /*translate(-50%,-50%) 偏移自身的宽和高的-50%*/transform: translate(-50%, -50%); 4、flex 布局 1234567/*父级：*//*flex 布局*/display: flex;/*实现垂直居中*/align-items: center;/*实现水平居中*/justify-content: center; 5、水平方向上居中 12margin-left : 50% ;transform: translateX(-50%);]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[触发点击事件]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%A7%A6%E5%8F%91%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1document.getElementById("target").onclick() btnObj.onclick()只是简单地调用了btnObj的onclick所指向的方法，只是调用方法而已，并未触发事件 1document.getElementById("target").click() btnObj.click()是真正地用程序去点击按钮，触发了按钮的onclick（）事件]]></content>
      <tags>
        <tag>触发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[placeholder的字体颜色大小]]></title>
    <url>%2F2018%2F03%2F05%2Fplaceholder%E7%9A%84%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617input::-webkit-input-placeholder &#123; /* WebKit browsers */ font-size: 14px; color: #333;&#125;input::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ font-size: 14px; color: #333;&#125;input:-ms-input-placeholder &#123; /* Internet Explorer 10+ */ font-size: 14px; color: #333;&#125;]]></content>
      <tags>
        <tag>placeholder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击copy]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%82%B9%E5%87%BBcopy%2F</url>
    <content type="text"><![CDATA[123&lt;input type="text" id="inputText" value="测试文本" /&gt;&lt;input type="button" id="btn" value="复制" /&gt;&lt;textarea rows="4"&gt;&lt;/textarea&gt; 1234567891011var btn = document.getElementById('btn');btn.addEventListener('click', function() &#123; var inputText = document.getElementById('inputText'); var currentFocus = document.activeElement; inputText.focus(); inputText.setSelectionRange(0, inputText.value.length); document.execCommand('copy', true); currentFocus.focus();&#125;); 123456789document.addEventListener('copy', function(e) &#123; e.clipboardData.setData('text/plain', 'Hello, world!'); e.clipboardData.setData('text/html', '&lt;b&gt;Hello, world!&lt;/b&gt;'); e.preventDefault();&#125;); 12345678910111213141516const btn = document.querySelector('#btn');btn.addEventListener('click', () =&gt; &#123; const input = document.createElement('input'); input.setAttribute('readonly', 'readonly'); input.setAttribute('value', 'hello world'); document.body.appendChild(input); input.setSelectionRange(0, 9999); if (document.execCommand('copy')) &#123; document.execCommand('copy'); &#125; document.body.removeChild(input);&#125;);]]></content>
      <tags>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调试webview]]></title>
    <url>%2F2018%2F03%2F02%2F%E8%B0%83%E8%AF%95webview%2F</url>
    <content type="text"><![CDATA[1、打开开发者选项，勾上调试模式 2、chrome浏览器中输入chrome://inspect/#devices 微信：查看log 1、微信内打开：http://debugx5.qq.com 2、【信息】-&gt;【TBS settings】，勾选 【是否打开 TBS 内核 Inspector 调试功能】]]></content>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emoji-表情]]></title>
    <url>%2F2018%2F02%2F28%2FEmoji-%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[一、码点和含义Unicode 只是规定了 Emoji 的码点和含义，并没有规定它的样式，由各个系统自己实现 二、使用方式Emoji 虽然是文字，但是无法书写，必须使用其他方法插入文档。 （1）最简单的方法当然是复制/粘贴，你可以到 getEmoji.com 选中一个 Emoji 贴在自己的文档即可。 （2）另一种方法是通过码点输入 Emoji。以 HTML 网页为例，将码点U+1F600写成 HTML 实体的形式&#128512;（十进制）或&#x1F600;（十六进制），就可以插入网页。码点到这个页面查询。 （3）JavaScript 输入 Emoji，可以使用 node-emoji 这个库。 123456789101112131415161718var emoji = require('node-emoji');// 返回 coffee 的 Emojiemoji.get('coffee');// 返回文字标签对应的 Emoji// https://www.webpagefx.com/tools/emoji-cheat-sheet/emoji.get(':fast_forward:');// 将文字替换成 Emojiemoji.emojify('I :heart: :coffee:!');// 随机返回一个 Emoji emoji.random();// 查询 Emoji// 返回结果是一个数组 emoji.search('cof'); （4）还可以通过 CSS 插入 Emoji。 12&lt;link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet"&gt;&lt;i class="em em-baby"&gt;&lt;/i&gt;]]></content>
      <tags>
        <tag>Emoji</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http-form-data]]></title>
    <url>%2F2018%2F01%2F30%2FHttp-form-data%2F</url>
    <content type="text"><![CDATA[一、演变http协议本身的原始方法不支持multipart/form-data请求，是由一些原始的方法演变而来的 1、multipart/form-data的基础方法是post，也就是说是由post方法来组合实现的 2、multipart/form-data与post方法的不同之处：请求头，请求体。 3、multipart/form-data的请求头必须包含一个特殊的头信息：Content-Type，且其值也必须规定为multipart/form-data 4、规定一个内容分割符用于分割请求体中的多个post的内容 具体的头信息如下：Content-Type: multipart/form-data; boundary=${bound}，其中${bound} 是一个占位符，代表我们规定的分割符，可以自己任意规定，但为了避免和正常文本重复了，尽量要使用复杂一点的内容。 二、请求体multipart/form-data的请求体也是一个字符串，不过和post的请求体不同的是它的构造方式，post是简单的name=value值连接，而multipart/form-data则是添加了分隔符等内容的构造体。具体格式如下: 123456789101112131415161718--$&#123;bound&#125;Content-Disposition: form-data; name="Filename"HTTP.pdf --$&#123;bound&#125;Content-Disposition: form-data; name="file000"; filename="HTTP协议详解.pdf"Content-Type: application/octet-stream %PDF-1.5file content%%EOF --$&#123;bound&#125;Content-Disposition: form-data; name="Upload" Submit Query--$&#123;bound&#125;--]]></content>
      <tags>
        <tag>form-data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Api-RESTful]]></title>
    <url>%2F2018%2F01%2F30%2FApi-RESTful%2F</url>
    <content type="text"><![CDATA[一、资源REST，即Representational State Transfer的缩写，资源表现层状态转化 所谓”资源”，就是网络上的一个具体信息。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI，因此URI就成了每一个资源的地址或独一无二的识别符。 “资源”表示一种实体，所以应该是名词，URI不应该有动词 数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 二、表现层“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 三、状态转化HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 四、RESTful架构：（1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化” 五、状态码 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 六、返回结果 GET /collection：返回资源对象的列表（数组） GET /collection/resource：返回单个资源对象 POST /collection：返回新生成的资源对象 PUT /collection/resource：返回完整的资源对象 PATCH /collection/resource：返回完整的资源对象 DELETE /collection/resource：返回一个空文档]]></content>
      <tags>
        <tag>Api</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-层叠上下文]]></title>
    <url>%2F2018%2F01%2F21%2Fcss-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[一、定义层叠上下文是HTML元素的三维概念，这些HTML元素在z轴上延伸。HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。层叠上下文是可以相互嵌套的，一个层叠上下文中包含了普通元素以及子层叠上下文。 二、形成文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 (HTML) z-index 值不为 “auto”的 绝对/相对定位 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素 transform 属性值不为 “none”的元素 mix-blend-mode 属性值不为 “normal”的元素 filter值不为“none”的元素 perspective值不为“none”的元素 isolation 属性被设置为 “isolate”的元素 position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值 -webkit-overflow-scrolling 属性被设置 “touch”的元素 注： 在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠 其子元素的 z-index 值只在父级层叠上下文中有意义 子级层叠上下文被自动视为父级层叠上下文的一个独立单元 没有创建自己的层叠上下文的元素 将被父层叠上下文包含 三、层叠顺序一个层叠上下文中，元素发生层叠时有着特定的垂直显示顺序，这种顺序按照一定的规则生成 四、层叠准则 谁大谁上：当具有明显层叠水平标示的时候，如z-index值，在同一层叠上下文领域，层叠水平值大的覆盖小的那个；（层叠水平小的先被绘制） 后来居上：当元素水平一致、层叠顺序相同时，在DOM流中处于后面的元素覆盖前面的元素。 五、例子 Root DIV #1 DIV #2 DIV #3 DIV #4 DIV #5 DIV #6]]></content>
      <tags>
        <tag>css</tag>
        <tag>层叠上下文</tag>
        <tag>stacking-context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-getter和setter]]></title>
    <url>%2F2018%2F01%2F20%2FJS-getter%E5%92%8Csetter%2F</url>
    <content type="text"><![CDATA[一、getter123&#123;get prop() &#123; ... &#125; &#125; &#123;get [expression]() &#123; ... &#125; &#125; 1234567var obj = &#123; log: ['example','test'], get latest() &#123; return this.log[this.log.length - 1]; &#125;&#125;console.log(obj.latest); // "test" 二、setter123&#123;set prop(val) &#123; . . . &#125;&#125;&#123;set [expression](val) &#123; . . . &#125;&#125; 12345678var language = &#123; set current(name) &#123; this.log.push(name); &#125;, log: []&#125;language.current = 'EN';console.log(language.log); // ['EN'] 三、注意1、不能将一个 getter或setter 绑定到一个具有真实值的属性上 2、使用delete操作符可以删除getter和setter]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>getter</tag>
        <tag>setter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-属性描述符]]></title>
    <url>%2F2018%2F01%2F20%2FJS-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[一、属性描述符ECMAScript对象中目前存在的属性描述符主要有两种，数据描述符(数据属性)和存取描述符(访问器属性)。 数据描述符是一个拥有可写或不可写值的属性。 存取描述符是由一对 getter-setter 函数功能来描述的属性。 二、数据描述符属性当修改或定义对象的某个属性的时候，给这个属性添加一些特性： 123456Object.defineProperty(obj, "newKey", &#123; configurable: true | false, enumerable: true | false, value: 任意类型的值, writable: true | false&#125;); Value：属性对应的值,可以使任意类型的值，默认为undefined Writable：属性的值是否可以被重写，默认为false。 Enumerable：此属性是否可以被枚举，默认为false。 Configurable：设置为true可以被删除或可以重新设置特性，默认为false。 提示：一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false 1234Object.defineProperty(person, 'name', &#123; configurable: false, value: 'John'&#125;); 三、存取描述符属性当使用存取器描述属性的特性的时候，允许设置以下特性属性： 1234567var obj = &#123;&#125;;Object.defineProperty(obj, "newKey", &#123; get: function() &#123;&#125; | undefined, set: function(value) &#123;&#125; | undefined configurable: true | false enumerable: true | false&#125;); 注： 当使用了getter或setter方法，不允许使用writable和value这两个属性 get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined 1234567891011Object.defineProperty(obj, 'a', &#123; configurable: true, enumerable: true, get: function() &#123; return aValue &#125;, set: function(newValue) &#123; aValue = newValue; b = newValue + 1 &#125;&#125;) 四、Object.defineProperties1234567891011121314var obj = new Object();Object.defineProperties(obj, &#123; name: &#123; value: '张三', configurable: false, writable: true, enumerable: true &#125;, age: &#123; value: 18, configurable: true &#125;&#125;)console.log(obj.name, obj.age) // 张三, 18]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>属性描述符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-简单数据绑定-MVC]]></title>
    <url>%2F2018%2F01%2F20%2FJS-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[一、视图层V1234&lt;div&gt; &lt;p&gt;你好，&lt;span id='nickName'&gt;&lt;/span&gt;&lt;/p&gt; &lt;div id="introduce"&gt;&lt;/div&gt;&lt;/div&gt; 二、视图控制器C123456789101112131415161718192021var userInfo = &#123;&#125;;Object.defineProperty(userInfo, "nickName", &#123; get: function() &#123; return document.getElementById('nickName').innerHTML; &#125;, set: function(nick) &#123; document.getElementById('nickName').innerHTML = nick; &#125;&#125;);Object.defineProperty(userInfo, "introduce", &#123; get: function() &#123; return document.getElementById('introduce').innerHTML; &#125;, set: function(introduce) &#123; document.getElementById('introduce').innerHTML = introduce; &#125;&#125;) 三、数据M12userInfo.nickName = "xxx";userInfo.introduce = "我是xxx，我来自云南，..."]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖动与节流]]></title>
    <url>%2F2018%2F01%2F10%2F%E9%98%B2%E6%8A%96%E5%8A%A8%E4%B8%8E%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[一、防抖动12345678910111213141516171819/** * 防抖动 * @method debounce * @param &#123;function&#125; callback 回调函数 * @param &#123;number&#125; delay 时间间隔 * */export const debounce = function(callback, delay) &#123; let timer = null; return function() &#123; let context = this; let args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; callback.apply(context, args); &#125;, delay); &#125;&#125;; 二、节流123456789101112131415161718/** * 节流 * @method throttle * @param &#123;function&#125; callback 回调函数 * @param &#123;number&#125; delay 时间间隔 * */export const throttle = function(callback, delay) &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let now = Date.now(); if (now - prev &gt;= delay) &#123; callback.apply(context, args); prev = Date.now(); &#125; &#125;&#125;;]]></content>
      <tags>
        <tag>抖动</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[height-100%问题]]></title>
    <url>%2F2018%2F01%2F04%2Fheight-100-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、height:auto 因为页面没有缺省的高度值，当设置百分百的高度时，无法根据父元素获取高度 父元素的高度只是一个缺省值height：auto，只有子元素撑开父元素 只要给父元素设置一个缺省值 123456html,body&#123; margin: 0; padding: 0; height: 100%; width: 100%; &#125; 二、line-height和heightCSS中对高度起作用的是height和line-height。如果一个标签没有定义height属性(包括百分比高度)，那么其最终表现的高度一定是由line-height起作用 。 在inline box模型中，有个line boxes，这玩意是看不见的，这个玩意的工作就是包裹每行文字。一行文字一个line boxes。line boxes什么特性也没有，就高度。所以一个没有设置height属性的div的高度就是由一个一个line boxes的高度堆积而成的。 其实line boxes不是直接的生产者，属于中层干部，真正的活儿都是它的手下 – inline boxes干的。line boxes只是个考察汇报人员，考察它的手下谁的实际line-height值最高，谁最高，它就要谁的值，然后向上汇报，形成高度。 三、垂直居中 line-height值设置为height一样大小的值可以实现单行文字的垂直居中 (height是多余的) 把line-height设置为您需要的box的大小可以实现单行文字的垂直居中]]></content>
      <tags>
        <tag>100%</tag>
        <tag>height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less进阶]]></title>
    <url>%2F2017%2F12%2F28%2Fless%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一、变量 变量定义方式是 @变量名:值 变量使用方式是 @{变量名} || @变量名 1234567891011121314@kuandu:width;@green: #801f77;@imgurl:"https://www.baidu.com/img/";.@&#123;kuandu&#125;&#123; @&#123;kuandu&#125;:150px; //使用""将变量的值括起来 background: @green url("@&#123;imgurl&#125;bdlogo.png");&#125; /*编译后*/.width &#123; width: 150px; background: #801f77 url("https://www.baidu.com/img/bdlogo.png");&#125; 注： 变量作为 属性名时 @{变量名} 变量作为 属性值时 @变量名 || “@{变量名}” 二、多参数混合1、命名参数：引用mixin时可以通过参数名称而不是参数的位置来为mixin提供参数值 12345678910111213141516.mixin(@color: black; @margin: 10px; @padding: 20px) &#123; color: @color; margin: @margin; padding: @padding;&#125;.class3&#123; .mixin(@padding: 80px;)&#125;/*编译后*/.class3 &#123; color: black; margin: 10px; padding: 80px;&#125; 2、匹配模式：传值的时候定义一个字符，在使用的时候使用哪个字符，就调用那天规则 123456789101112131415161718.border(b-l, @w: 5px) &#123; border-bottom-left-radius: @w;&#125;.border(b-r, @w: 5px) &#123; border-bottom-right-radius: @w;&#125;footer &#123; .border(b-r, 10px); background: #33acfe;&#125;/*编译后*/footer &#123; border-bottom-right-radius: 10px; background: #33acfe;&#125; 3、返回值 123456789101112131415161718.average(@x, @y) &#123; @average: ((@x + @y) / 2); @he: (@x + @y);&#125;div &#123; //执行混合 .average(16px, 50px); //使用返回变量 padding: @average; margin: @he;&#125;/*编译后*/div &#123; padding: 33px; margin: 66px;&#125; 三、嵌套1、父类选择器符号： &amp; 12345678910111213141516.logo &#123; width: 300px; &amp;:hover &#123; background: forestgreen; &#125;&#125;.logo &#123; width: 300px;&#125;/*编译后*/.logo:hover &#123; background: forestgreen;&#125; 2、改变选择器顺序：将&amp;放到当前选择器之后，就会将当前选择器插入到所有的父选择器之前 123456789101112.a &#123; .b &#123; .c&amp; &#123; color: 123; &#125; &#125;&#125;/*编译后*/.c.a .b &#123; color: 123;&#125; 3、组合 &amp; &amp;：组合使用生成所有可能的选择器列表 123456789101112131415161718192021222324p,a,ul &#123; border-top: 2px dotted #366; &amp; &amp; &#123; border-top: 0; &#125;&#125;p,a,ul &#123; border-top: 2px dotted #366;&#125;/*编译后*/p p,p a,p ul,a p,a a,a ul,ul p,ul a,ul ul &#123; border-top: 0;&#125;]]></content>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灰度化与二值化]]></title>
    <url>%2F2017%2F12%2F24%2F%E7%81%B0%E5%BA%A6%E5%8C%96%E4%B8%8E%E4%BA%8C%E5%80%BC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[灰度化在RGB模型中，当R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值（又称强度值、亮度值），灰度范围为0-255。获取每个像素点的灰度值有以下几种方式： 1. 分量法将图像中的三分量的亮度作为三个灰度值，可根据应用需要选取一种灰度值。 2. 最大值法将图像中的三分量亮度的最大值作为灰度值。 3. 平均值法将图像中的三分量亮度求平均得到一个灰度值。 4. 加权平均法根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对红色敏感较低，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度值。 二值化对RGB彩色图像灰度化以后，扫描图像的每个像素值，将值小于阈值的将像素值设为0(黑色)，将值大于等于阈值的像素值设为255(白色)。**阈值可以根据灰度直方图按照特定的数学方法获取。可参考大神Imageshop的算法。 灰度直方图灰度图像由不同灰度值的像素组成，灰度图像中灰度值的分布是该图像的一个重要特征。 图像的灰度直方图就描述了图像中灰度值分布情况，能够很直观的展示出图像中各个灰度值所占的多少。图像的灰度直方图是灰度值的函数，描述的是图像中具有该灰度值的像素的个数：其中，横坐标是灰度级，纵坐标是该灰度级出现的频率。 计算阈值1、灰度平局值值法 描述 即使用整幅图像的灰度平均值作为二值化的阈值，一般该方法可作为其他方法的初始猜想值。 原理 ​ 实现代码 12345678public static int GetMeanThreshold(int[] HistGram) &#123; int Sum = 0, Amount = 0; for (int Y = 0; Y &lt; 256; Y++) &#123; Amount += HistGram[Y]; Sum += Y * HistGram[Y]; &#125; return Sum / Amount;&#125; 2、百分比阈值（P-Tile法） 描述 Doyle于1962年提出的P-Tile (即P分位数法)可以说是最古老的一种阈值选取方法。该方法根据先验概率来设定阈值，使得二值化后的目标或背景像素比例等于先验概率，该方法简单高效，但是对于先验概率难于估计的图像却无能为力。 实现代码 123456789101112131415/// &lt;summary&gt;/// 百分比阈值/// &lt;/summary&gt;/// &lt;param name="HistGram"&gt;灰度图像的直方图&lt;/param&gt;/// &lt;param name="Tile"&gt;背景在图像中所占的面积百分比&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static int GetPTileThreshold(int[] HistGram, int Tile = 50) &#123; int Y, Amount = 0, Sum = 0; for (Y = 0; Y &lt; 256; Y++) Amount += HistGram[Y]; // 像素总数 for (Y = 0; Y &lt; 256; Y++) &#123; Sum = Sum + HistGram[Y]; if (Sum &gt;= Amount * Tile / 100) return Y; &#125; return -1;&#125; 3、基于谷底最小值的阈值 描述 此方法实用于具有明显双峰直方图的图像，其寻找双峰的谷底作为阈值，但是该方法不一定能获得阈值，对于那些具有平坦的直方图或单峰图像，该方法不合适。 实现代码 123456789101112131415161718192021222324252627282930313233343536public static int GetMinimumThreshold(int[] HistGram) &#123; int Y, Iter = 0; // 基于精度问题，一定要用浮点数来处理，否则得不到正确的结果 double[] HistGramC = new double[256]; // 求均值的过程会破坏前面的数据，因此需要两份数据 double[] HistGramCC = new double[256]; for (Y = 0; Y &lt; 256; Y++) &#123; HistGramC[Y] = HistGram[Y]; HistGramCC[Y] = HistGram[Y]; &#125; // 通过三点求均值来平滑直方图 // 判断是否已经是双峰的图像了 while (IsDimodal(HistGramCC) == false) &#123; // 第一点 HistGramCC[0] = (HistGramC[0] + HistGramC[0] + HistGramC[1]) / 3; for (Y = 1; Y &lt; 255; Y++) // 中间的点 HistGramCC[Y] = (HistGramC[Y - 1] + HistGramC[Y] + HistGramC[Y + 1]) / 3; // 最后一点 HistGramCC[255] = (HistGramC[254] + HistGramC[255] + HistGramC[255]) / 3; System.Buffer.BlockCopy(HistGramCC, 0, HistGramC, 0, 256 * sizeof(double)); Iter++; // 直方图无法平滑为双峰的，返回错误代码 if (Iter &gt;= 1000) return -1; &#125; // 阈值极为两峰之间的最小值 bool Peakfound = false; for (Y = 1; Y &lt; 255; Y++) &#123; if (HistGramCC[Y - 1] &lt; HistGramCC[Y] &amp;&amp; HistGramCC[Y + 1] &lt; HistGramCC[Y]) Peakfound = true; if (Peakfound == true &amp;&amp; HistGramCC[Y - 1] &gt;= HistGramCC[Y] &amp;&amp; HistGramCC[Y + 1] &gt;= HistGramCC[Y]) return Y - 1; &#125; return -1;&#125; 其中IsDimodal函数为判断直方图是否是双峰的函数，代码如下： 123456789101112131415private static bool IsDimodal(double[] HistGram) // 检测直方图是否为双峰的&#123; // 对直方图的峰进行计数，只有峰数位2才为双峰 int Count = 0; for (int Y = 1; Y &lt; 255; Y++) &#123; if (HistGram[Y - 1] &lt; HistGram[Y] &amp;&amp; HistGram[Y + 1] &lt; HistGram[Y]) &#123; Count++; if (Count &gt; 2) return false; &#125; &#125; if (Count == 2) return true; else return false;&#125; 4、基于双峰平均值的阈值 描述 该算法和基于谷底最小值的阈值方法类似，只是最后一步不是取得双峰之间的谷底值，而是取双峰的平均值作为阈值。 参考代码 123456789101112131415161718192021222324252627282930313233public static int GetIntermodesThreshold(int[] HistGram) &#123; int Y, Iter = 0, Index; // 基于精度问题，一定要用浮点数来处理，否则得不到正确的结果 double[] HistGramC = new double[256]; // 求均值的过程会破坏前面的数据，因此需要两份数据 double[] HistGramCC = new double[256]; for (Y = 0; Y &lt; 256; Y++) &#123; HistGramC[Y] = HistGram[Y]; HistGramCC[Y] = HistGram[Y]; &#125; // 通过三点求均值来平滑直方图 // 判断是否已经是双峰的图像了 while (IsDimodal(HistGramCC) == false) &#123; // 第一点 HistGramCC[0] = (HistGramC[0] + HistGramC[0] + HistGramC[1]) / 3; for (Y = 1; Y &lt; 255; Y++) // 中间的点 HistGramCC[Y] = (HistGramC[Y - 1] + HistGramC[Y] + HistGramC[Y + 1]) / 3; // 最后一点 HistGramCC[255] = (HistGramC[254] + HistGramC[255] + HistGramC[255]) / 3; // 备份数据，为下一次迭代做准备 System.Buffer.BlockCopy(HistGramCC, 0, HistGramC, 0, 256 * sizeof(double)); Iter++; // 似乎直方图无法平滑为双峰的，返回错误代码 if (Iter &gt;= 10000) return -1; &#125; // 阈值为两峰值的平均值 int[] Peak = new int[2]; for (Y = 1, Index = 0; Y &lt; 255; Y++) if (HistGramCC[Y - 1] &lt; HistGramCC[Y] &amp;&amp; HistGramCC[Y + 1] &lt; HistGramCC[Y]) Peak[Index++] = Y - 1; return ((Peak[0] + Peak[1]) / 2);&#125; 5、迭代最佳阈值 描述 该算法先假定一个阈值，然后计算在该阈值下的前景和背景的中心值，当前景和背景中心值得平均值和假定的阈值相同时，则迭代中止，并以此值为阈值进行二值化。 实现过程 （1）求出图象的最大灰度值和最小灰度值，分别记为gi和gu，令初始阈值为： ​ ​ (2) 根据阈值T0将图象分割为前景和背景，分别求出两者的平均灰度值Ab和Af: ​ (3) 令 ​ 如果Tk=Tk+1,则取Tk为所求得的阈值，否则，转2继续迭代。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940public static int GetIterativeBestThreshold(int[] HistGram) &#123; int X, Iter = 0; int MeanValueOne, MeanValueTwo, SumOne, SumTwo, SumIntegralOne, SumIntegralTwo; int MinValue, MaxValue; int Threshold, NewThreshold; for (MinValue = 0; MinValue &lt; 256 &amp;&amp; HistGram[MinValue] == 0; MinValue++); for (MaxValue = 255; MaxValue &gt; MinValue &amp;&amp; HistGram[MinValue] == 0; MaxValue--); // 图像中只有一个颜色 if (MaxValue == MinValue) return MaxValue; // 图像中只有二个颜色 if (MinValue + 1 == MaxValue) return MinValue; Threshold = MinValue; NewThreshold = (MaxValue + MinValue) &gt;&gt; 1; // 当前后两次迭代的获得阈值相同时，结束迭代 while (Threshold != NewThreshold) &#123; SumOne = 0; SumIntegralOne = 0; SumTwo = 0; SumIntegralTwo = 0; Threshold = NewThreshold; //根据阈值将图像分割成目标和背景两部分，求出两部分的平均灰度值 for (X = MinValue; X &lt;= Threshold; X++) &#123; SumIntegralOne += HistGram[X] * X; SumOne += HistGram[X]; &#125; MeanValueOne = SumIntegralOne / SumOne; for (X = Threshold + 1; X &lt;= MaxValue; X++) &#123; SumIntegralTwo += HistGram[X] * X; SumTwo += HistGram[X]; &#125; MeanValueTwo = SumIntegralTwo / SumTwo; //求出新的阈值 NewThreshold = (MeanValueOne + MeanValueTwo) &gt;&gt; 1; Iter++; if (Iter &gt;= 1000) return -1; &#125; return Threshold;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input onchange="f(this)" type="file"&gt; &lt;img width="250" height="250" id="scream"&gt; &lt;canvas id="myCanvas" width="250" height="250" style="border:1px solid #d3d3d3;"&gt; 您的浏览器不支持 HTML5 canvas 标签。 &lt;/canvas&gt; &lt;script&gt; function f(inputBtn) &#123; let url = URL.createObjectURL(inputBtn.files[0]); var c = document.getElementById("myCanvas"); var ctx = c.getContext("2d"); var img = document.getElementById("scream"); img.onload = function() &#123; ctx.drawImage(img, 0, 0, img.width, img.height); var imgData = ctx.getImageData(0, 0, c.width, c.height); let list = []; for (var i = 0; i &lt; imgData.data.length; i += 4) &#123; let r = imgData.data[i]; let g = imgData.data[i + 1]; let b = imgData.data[i + 2]; let v = parseInt(0.299 * r + 0.578 * g + 0.114 * b); !list[v] &amp;&amp; (list[v] = 0); list[v]++; imgData.data[i] = imgData.data[i + 1] = imgData.data[i + 2] = v; imgData.data[i + 3] = 255; &#125; let sum = 0; let account = 0; for (let i = 0; i &lt; 255; i++) &#123; !list[i] &amp;&amp; (list[i] = 0); sum += i * list[i]; account += list[i]; &#125; let binaryV = sum / account; console.log(sum, account, binaryV) for (var i = 0; i &lt; imgData.data.length; i += 4) &#123; let v = imgData.data[i] &gt;= binaryV ? 255 : 0; imgData.data[i] = imgData.data[i + 1] = imgData.data[i + 2] = v; imgData.data[i + 3] = 255; &#125; ctx.putImageData(imgData, 0, 0, 0, 0, 125, 125); ctx.putImageData(imgData, 0, 0, 125, 125, 125, 125); &#125; img.src = url; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>图像</tag>
        <tag>灰度化</tag>
        <tag>二值化</tag>
        <tag>灰度直方图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格模式this]]></title>
    <url>%2F2017%2F12%2F23%2F%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8Fthis%2F</url>
    <content type="text"><![CDATA[正常模式this的指向只有函数执行的时候才能确定，指向调用它的对象 全局作用域中的this在严格模式下，在全局作用域中，this指向window对象 全局作用域中函数中的this在严格模式下，这种函数中的this等于undefined 对象的函数（方法）中的this在严格模式下，对象的函数中的this指向调用函数的对象实例 构造函数的this在严格模式下，构造函数中的this指向构造函数创建的对象实例。 事件处理函数中的this在严格模式下，在事件处理函数中，this指向触发事件的目标对象。 内联事件处理函数中的this在严格模式下，在内联事件处理函数中，有以下两种情况： 12345678910&lt;button onclick="alert((function()&#123;'use strict'; return this&#125;)());"&gt; 内联事件处理1&lt;/button&gt;&lt;!-- 警告窗口中的字符为undefined --&gt; &lt;button onclick="'use strict'; alert(this.tagName.toLowerCase());"&gt; 内联事件处理2&lt;/button&gt;&lt;!-- 警告窗口中的字符为button --&gt;]]></content>
      <tags>
        <tag>this</tag>
        <tag>严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL-createObjectURL]]></title>
    <url>%2F2017%2F12%2F11%2FURL-createObjectURL%2F</url>
    <content type="text"><![CDATA[createObjectURLURL.createObjectURL()方法会根据传入的参数创建一个指向该参数对象的URL。这个URL的生命仅存在于它被创建的这个文档里。新的对象URL指向执行的File对象或者是Blob对象。 1objectURL = URL.createObjectURL(blob || file); File对象，就是一个文件。比如我用input type=&quot;file&quot;标签来上传文件,那么里面的每个文件都是一个File对象。 Blob对象，就是二进制数据。比如通过new Blob()创建的对象就是Blob对象。又比如，在XMLHttpRequest里,如果指定responseType为blob，那么得到的返回值也是一个blob对象。 注意：每次调用createObjectURL的时候，一个新的URL对象就被创建了。即使你已经为同一个文件创建过一个URL。 如果你不再需要这个对象，要释放它，需要使用URL.revokeObjectURL()方法。**当页面被关闭，浏览器会自动释放它**，但是为了最佳性能和内存使用，当确保不再用得到它的时候,就应该释放它。]]></content>
      <tags>
        <tag>url</tag>
        <tag>createObjectURL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三个视口]]></title>
    <url>%2F2017%2F12%2F09%2F%E4%B8%89%E4%B8%AA%E8%A7%86%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[一、像素 设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。（物理像素） CSS像素：这是一个抽象的像素概念，它是为web开发者创造的。（逻辑像素） 一个width:200px 的元素跨越了 200 个CSS像素。CSS像素相当于多少个设备像素取决于屏幕的特性（是否高密度）和用户进行的缩放。 当缩放程度为100%时: 在旧的屏幕上，1个CSS像素等于1个设备像素。 在高密度屏幕上（iphone6），1个CSS像素跨越了2（dpr）个设备像素。 当缩放程度为200%时： 在旧的屏幕上，1个css像素等于2个设备像素 在高密度屏幕上，1个css像素跨越了2*dpr个设备像素 当缩放程度为50%时： 在旧的屏幕上，2个css像素等于1个设备像素 在高密度屏幕上，1个css像素跨越了dpr/2个设备像素 下图是在旧屏幕手机上css像素（红色）和设备像素（蓝色）的具体情况： 二、设备像素比 设备像素比（DPR）= 设备像素个数 / 理想视口像素个数（device-width） 注：理想视口（device-width）和设备像素比（dpr）一般不改变 三、三个视口1.布局视口如果移动端设备的布局视口宽度和浏览器窗口宽度一样会导致很丑陋的结果。所以，移动端浏览器厂商必须保证即使在窄屏幕下我们的页面可以展示的很好，他们将布局视口宽度设计得比浏览器窗口宽度大出很多。看下面的图例，体会一下布局视口： 2.视觉视口 虽然独立的布局视口很大程度上帮助桌面网站过渡到手机上。但我们不能完全忽视移动设备上的屏幕尺寸。所以该说明一下视觉视口了。 视觉视口是用户正在看到的网站的区域。用户可以通过缩放来操作视觉视口，同时不会影响布局视口。布局视口还是保持在原来的宽度。看下图说明一下视觉视口区域 : 如上图，红色箭头之间的区域就是视觉视口的区域。它和设备的屏幕一样宽，并且它的CSS像素的数量会随着用户缩放而改变。 缩放只改变视觉视口的css像素大小，也就是一个css像素等于几个设备像素的问题。 3.理想视口理想视口就是device-width，定义理想视口是浏览器的工作，是固定不变的。 布局视口的默认宽度并不是一个理想的宽度，只有手动添加meta视口标签才生效。如果没有meta视口标签，那么布局将会维持它的默认宽度。 123&lt;meta name="device" content="width=device-width"&gt;&lt;!--width指的是布局视口-&gt;&lt;!--device-width指的是理解视口-&gt;]]></content>
      <tags>
        <tag>css</tag>
        <tag>视口</tag>
        <tag>css像素</tag>
        <tag>设备像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retina-高清图]]></title>
    <url>%2F2017%2F12%2F09%2FRetina-%E9%AB%98%E6%B8%85%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、高清图问题1、理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。在普通屏幕下是没有问题的，但是在retina屏幕下就会出现位图像素点不够，从而导致图片模糊的情况。用一张图来表示： 如上图：对于dpr=2的retina屏幕而言，1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊(注意上述的几个颜色值)。 2、如果用了两倍图片，会怎样呢？很明显，在普通屏幕下，200×300(css pixel)img标签，所对应的物理像素个数就是200×300个，而两倍图片的位图像素个数则是200×300*4，所以就出现一个物理像素点对应4个位图像素点，所以它的取色也只能通过一定的算法(显示结果就是一张只有原图像素总数四分之一，我们称这个过程叫做downsampling)，肉眼看上去虽然图片不会模糊，但是会觉得图片缺少一些锐利度，或者是有点色差(但还是可以接受的)。 二、 1px border问题一张图来解释： 上图中，对于一条1px宽的直线，它们在屏幕上的物理尺寸(灰色区域)的确是相同的，不同的其实是屏幕上最小的物理显示单元，即物理像素，所以对于一条直线，iphone5它能显示的最小宽度其实是图中的红线圈出来的灰色区域，用css来表示，理论上说是0.5px。设计师想要的retina下border: 1px;，其实就是1物理像素宽，对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。 注：在不同的屏幕上(普通屏幕 vs retina屏幕)，css像素所呈现的大小(物理尺寸)是一致的，不同的是1个css像素所对应的物理像素个数是不一致的。 三、字体问题对于字体缩放问题，设计师原本的要求是这样的：任何手机屏幕上字体大小都要统一，所以我们针对不同的分辨率(dpr不同)，会做如下处理： 1&lt;meta name="viewport" content="width=device-width*dpr,initial-scale=1/dpr,maximum-scale=1/dpr, minimum-scale=1/dpr,user-scalable=no"&gt; 12345font-size: 16px;[data-dpr="2"] input &#123; // font-size: calc(attr(data-dpr)*16px); 不支持 font-size: 32px;&#125; 注意，字体不可以用rem，误差太大了，且不能满足任何屏幕下字体大小相同。为了方便，我们也会用less写一个mixin： 1234567891011121314151617181920212223242526.px2px(@name, @px) &#123; @&#123;name&#125;: round(@px / 2) * 1px; [data-dpr="2"] &amp; &#123; @&#123;name&#125;: @px * 1px; &#125; // for mx3 [data-dpr="2.5"] &amp; &#123; @&#123;name&#125;: round(@px * 2.5 / 2) * 1px; &#125; // for 小米note [data-dpr="2.75"] &amp; &#123; @&#123;name&#125;: round(@px * 2.75 / 2) * 1px; &#125; [data-dpr="3"] &amp; &#123; @&#123;name&#125;: round(@px / 2 * 3) * 1px &#125; // for 三星note4 [data-dpr="4"] &amp; &#123; @&#123;name&#125;: @px * 2px; &#125;&#125;]]></content>
      <tags>
        <tag>retina</tag>
        <tag>视网膜图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注释格式]]></title>
    <url>%2F2017%2F11%2F28%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[@module声明模块1234/*** 模块说明* @module 模块名*/ @class声明类12345/*** 类说明* @class 类名* @constructor*/ @method声明函数或类方法1234567/*** 方法说明* @method 方法名* @for 所属类名* @param &#123;参数类型&#125; 参数名 参数说明* @return &#123;返回值类型&#125; 返回值说明*/ @property声明类属性1234/*** 属性说明* @property &#123;属性类型&#125; 属性名*/ 注： ​ 需要花费几分钟来理解的代码块，都应该有注释 处理特殊情况的语句，应该有注释 12345678910111213/** * 推荐 * 用来说明代码块 */function initSku(params) &#123; params = params || &#123;&#125;; //用来说明单语句，并且放在语句后面&#125;// 还行// 用来说明代码块，并且放在代码块上面function initSku(params) &#123; params = params || &#123;&#125;; //用来说明单语句，并且放在语句后面&#125;]]></content>
      <tags>
        <tag>注释格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html-雪碧图或精灵图]]></title>
    <url>%2F2017%2F11%2F27%2Fhtml-%E9%9B%AA%E7%A2%A7%E5%9B%BE%E6%88%96%E7%B2%BE%E7%81%B5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[​ 网站为了减少http请求数，会将大量的图片图片合成一张雪碧图（Sprite）来使用。雪碧图的使用就是通过控制background-position属性值来确定图片呈现的位置。 123456&lt;style&gt; .icon1&#123;background-position: 0 0;&#125; .icon2&#123;background-position: -40px 0;&#125; .icon3&#123;background-position: 0 -25px;&#125; .icon4&#123;background-position: -40px -25px;&#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>雪碧图</tag>
        <tag>精灵图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem与vw布局]]></title>
    <url>%2F2017%2F11%2F26%2Frem%E4%B8%8Evw%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、rem布局rem布局解决了一个问题，让设计稿在不同设备上进行等比缩放。 1234567891011121314151617181920212223242526272829303132333435//媒体查询@media screen and (max-width:359px) and (min-width:320px) &#123; html, body &#123; font-size: 50px !important; &#125;&#125;@media screen and (max-width:374px) and (min-width:360px) &#123; html, body &#123; font-size: 56.25px !important; &#125;&#125;@media screen and (max-width:413px) and (min-width:375px) &#123; html, body &#123; font-size: 58.5px !important; &#125;&#125;@media screen and (max-width:639px) and (min-width:414px) &#123; html, body &#123; font-size: 64.6px !important; &#125;&#125;@media screen and (min-width:640px) &#123; html, body &#123; font-size: 100px !important; &#125;&#125; 12345678// onload事件、onresize事件监听function refreshRem() &#123; let docEl = window.document.documentElement; let width = docEl.getBoundingClientRect().width; if (width &gt; 640) &#123; width = 640 &#125; let rem = 100 * (width / 640); docEl.style.fontSize = rem + "px";&#125; 如果页面的宽度超过了640px，那么页面中html的font-size恒为100px，否则，页面中html的font-size的大小为： 100 \* (当前页面宽度 / 640) 注：如果字体大小也等比缩放，在大屏手机上会有一种老人机的视觉 二、vw布局方案一最简单的方案就是所有的布局元素及属性都用VW来做单位，对应关系是： 设计稿 750px——&gt;100vw 那我们书写时计算：(x/750)*100vw 1234$vw_base: 750; @function vw($px) &#123; @return ($px / 750) * 100vw;&#125; 方案二沿用rem布局方案，所有的布局元素及属性都用rem做单位，用vw单位给html设置font-size形成“流单位”，这样就不再需要JS来动态计算根元素字体大小。 如果以前你习惯了约定750px设计稿的根元素字体大小为100px的话，你可以直接设置： 123html&#123; font-size: 13.3333vw;&#125;]]></content>
      <tags>
        <tag>vw</tag>
        <tag>rem</tag>
        <tag>自适应</tag>
        <tag>自配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-3D旋转效果]]></title>
    <url>%2F2017%2F11%2F26%2Fcss-3D%E6%97%8B%E8%BD%AC%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[一、XYZ轴以屏幕为平面，X轴的方向为宽的方向，Y轴的方向为高的方向，Z轴的方向垂直于屏幕 二、css变换函数 rotateX(angle)：绕着X轴旋转 rotateY(angle)：绕着Y轴旋转 rotateZ(angle)：绕着Z轴旋转 translateX(n)：沿着X轴位移 translateY(n)：沿着Y轴位移 translateZ(n)：沿着Z轴位移 三、属性1、transform-style属性123transform-style: flat | preserve-3d/*flat值为默认值，表示所有子元素在2D平面呈现。*//*preserve-3d表示所有子元素在3D空间中呈现。*/ 如果对一个元素设置了transform-style的值为flat，则该元素的所有子元素都将被平展到该元素的2D平面中进行呈现。沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。 如果你的元素设置了transform-style值为preserve-3d，就不能为了防止子元素溢出容器而设置overflow值为hidden。 2、perspective属性1perspective：none | &lt;length&gt; 简单的理解为视距，用来设置用户和元素3D空间Z平面之间的距离。 perspective属性的默认值为none，表示无限的角度来看3D物体，但看上去是平的。 另一个值&lt;length&gt;接受一个长度单位大于0的值。而且其单位不能为百分比值。 &lt;length&gt;值越大，角度出现的越远，从而创建一个相当低的强度和非常小的3D空间变化。 反之，此值越小，角度出现的越近，从而创建一个高强度的角度和一个大型3D变化。 为了使用原始圆（轮廓）看起来出现在Z轴上（虚线圆），画布上的实体圆将扩大两部，如浅蓝色的圆。在底部图中显示，圆按比例缩小，致使虚线圆出现在画布后面，并且z的大小是距原始位置三分之一。 perspective用在舞台元素上（变形元素们的共同父元素）；perspective()就是用在当前变形元素上，并且可以与其他的transform函数一起使用。 3、perspective-origin属性主要用来决定perspective属性的源点角度。它实际上设置了X轴和Y轴位置，在该位置观看者好像在观看该元素的子元素。 4、backface-visibility属性12backface-visibility: visible | hidden/**决定元素旋转背面是否可见 */]]></content>
      <tags>
        <tag>css</tag>
        <tag>3D</tag>
        <tag>变换</tag>
        <tag>旋转</tag>
        <tag>transform</tag>
        <tag>perspective</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-proxy_pass]]></title>
    <url>%2F2017%2F11%2F16%2Fnginx-proxy-pass%2F</url>
    <content type="text"><![CDATA[一、路径问题 当proxy_pass后有url时，则nginx不会把location中匹配的路径部分代理走 当proxy_pass后没有url时，则会把匹配的路径部分也给代理走 123456location ^~ /static_js/ &#123; proxy_cache js_cache; proxy_set_header Host js.test.com; proxy_pass http://js.test.com/; &#125; 如上面的配置，如果请求的url是 /static_js/test.html ，会被代理成 test.html。 123456location ^~ /static_js/ &#123; proxy_cache js_cache; proxy_set_header Host js.test.com; proxy_pass http://js.test.com; &#125; 则会被代理到 /static_js/test.htm 。 二、proxy_set_header1、原理介绍1proxy_set_header field value; 语法: proxy_set_header field value; 默认值: proxy_set_header Connection close; proxy_set_header Host $proxy_host; 上下文: http, server, location 允许重新定义或者添加发往后端服务器的请求头。value可以包含文本、变量或者它们的组合。 当且仅当当前配置级别中没有定义proxy_set_header指令时，会从上面的级别继承配置。 默认情况下，只有两个请求头会被重新定义： 12proxy_set_header Host $proxy_host;proxy_set_header Connection close; proxy_set_header也可以自定义参数，如： 1proxy_set_header test paroxy_test; 如果想要支持下划线的话，需要在http或者server中 增加如下配置： 1underscores_in_headers on|off 2、获取用户ip在实际应用中，我们可能需要获取用户的ip地址。通常情况下我们使用request.getRemoteAddr()就可以获取到客户端ip，但是当我们使用了nginx作为反向代理后，使用request.getRemoteAddr()获取到的就一直是nginx服务器的ip的地址。 方案1：X-real-ip nginx是可以获得用户的真实ip的，也就是说nginx使用$remote_addr变量时获得的是用户的真实ip，如果我们想要在服务器端获得用户的真实ip，就必须在nginx这里作一个赋值操作，如下： 12345# X-real-ip是一个自定义的变量名proxy_set_header X-real-ip $remote_addr;# 在服务器端可以这样获取# request.getAttribute("X-real-ip") 方案2：X-Forwarded-For 一般来说，X-Forwarded-For是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加在X-Forwarded-For中 。 1234567891011121314151617181920212223# 192.168.107.107 nginx.conflocation /test &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.107.112:8080;&#125;#192.168.107.112 nginx.conflocation /test &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.107.114:8080;&#125;#192.168.107.114 nginx.conflocation /test &#123; default_type text/html; charset gbk; echo "$remote_addr ||$http_x_real_ip ||$http_x_forwarded_for";&#125;# 192.168.107.112 || 192.168.162.16 || 192.168.162.16, 192.168.107.107 3、实战应用从微信小程序跳到H5页面，需要在后台配置相关的业务域名。当我们需要跳到其他网站的页面时，可以使用Nginx来做反代理配置。如：在微信后台配置 es.yf-gz.cn，反代理到 shop.mallparking.cn 1234567891011121314151617181920server &#123; listen 443 ssl; server_name es.yf-gz.cn; ssl on; ssl_certificate /etc/nginx/cer/1_es.yf-gz.cn.pem; ssl_certificate_key /etc/nginx/cer/2_es.yf-gz.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://www.mallparking.cn; proxy_redirect off; proxy_set_header Host www.mallparking.cn; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; &#125;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>proxy_pass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-事件循环-promise和setTimeOut]]></title>
    <url>%2F2017%2F11%2F09%2FJS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-promise%E5%92%8CsetTimeOut%2F</url>
    <content type="text"><![CDATA[一、事件循环 mocrotasks 队列的第一个任务取出,放到执行栈中，开始执行 执行直到当前 stack 为空，于是去检查 microtasks队列 依次执行microtasks 队列的所有任务，直到 microtasks 队列为空，转 1 注： 如上循环中，注意到第 2 步中执行时可以向 microtasks 队列压入 microtask 一个事件循环里，任务队列分为mocrotasks队列和microtasks队列 microtasks队列只有一个，mocrotasks队列可以有多个 二、Macrotask setImmediate setTimeout setInterval 三、Microtask process.nextTick Promise Object.observe MutaionObserver 四、例子12345678910111213141516171819202122232425262728293031323334353637383940414243// demo01(function test() &#123; // 1 task A 执行中 // 2 tasks 队列压入新的 task B setTimeout(() =&gt; &#123; // 9 microtasks 队列为空，于是检查 tasks 队列，取出 B并执行了 console.log(4) &#125;, 0) new Promise(resolve =&gt; &#123; console.log(1) for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve() &#125; // 3 task A 继续执行 console.log(2) &#125;) // 4 microtasks 队列压入 microtask a .then(() =&gt; &#123; // 6 microtask a 执行中 console.log(5) Promise.resolve(7) // 7 microtasks 队列压入 microtask b .then(v =&gt; console.log(v)) // microtask a 执行完毕 &#125;) // 8 microtasks 队列压入 microtask c // 这个 then 执行完后继续检查 microtasks 队列，并一次执行 b，c .then(() =&gt; &#123; console.log(6) &#125;) // 5 task A 执行完毕，检查 microtasks 队列，发现非空，执行 microtasks 队列的第一个 microtask a console.log(3)&#125;)();/**1235764*/ 原文 123456789101112131415161718// demo02// 为了方便理解，我以打印出来的字符作为当前的任务名称// setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。setTimeout(function() &#123; console.log('timeout1');&#125;) new Promise(function(resolve) &#123; console.log('promise1'); for(var i = 0; i &lt; 1000; i++) &#123; i == 99 &amp;&amp; resolve(); &#125; console.log('promise2');&#125;).then(function() &#123; console.log('then1');&#125;) console.log('global1'); 首先，事件循环从宏任务队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务。每一个任务的执行顺序，都依靠函数调用栈来搞定，而当遇到任务源时，则会先分发任务到对应的队列中去。 首先script任务开始执行，全局上下文入栈 第二步：script任务执行时首先遇到了setTimeout，setTimeout为一个宏任务源，那么他的作用就是将任务分发到它对应的队列中。 宏任务timeout1进入setTimeout队列 第三步：script执行时遇到Promise实例。Promise构造函数中的第一个参数，是在new的时候执行，因此不会进入任何其他的队列，而是直接在当前任务直接执行了，而后续的.then则会被分发到micro-task的Promise队列中去。因此，构造函数执行时，里面的参数进入函数调用栈执行。for循环不会进入任何队列，因此代码会依次执行。 promise1入栈执行，这时promise1被最先输出 resolve在for循环中入栈执行 构造函数执行完毕的过程中，resolve执行完毕出栈，promise2输出，promise1页出栈，then执行时，Promise任务then1进入对应队列 script任务继续往下执行，最后只有一句输出了globa1，然后，全局任务就执行完毕了。 第四步：第一个宏任务script执行完毕之后，就开始执行所有的可执行的微任务。这个时候，微任务中，只有Promise队列中的一个任务then1，因此直接执行就行了，执行结果输出then1，当然，他的执行，也是进入函数调用栈中执行的。 执行所有的微任务 第五步：当所有的micro-tast执行完毕之后，表示第一轮的循环就结束了。这个时候就得开始第二轮的循环。第二轮循环仍然从宏任务macro-task开始。 微任务被清空 这个时候，我们发现宏任务中，只有在setTimeout队列中还要一个timeout1的任务等待执行。因此就直接执行即可。 timeout1入栈执行 这个时候宏任务队列与微任务队列中都没有任务了，所以代码就不会再输出其他东西了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// demo03console.log('golb1'); setTimeout(function() &#123; console.log('timeout1'); process.nextTick(function() &#123; console.log('timeout1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout1_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout1_then') &#125;)&#125;) setImmediate(function() &#123; console.log('immediate1'); process.nextTick(function() &#123; console.log('immediate1_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate1_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate1_then') &#125;)&#125;) process.nextTick(function() &#123; console.log('glob1_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob1_promise'); resolve();&#125;).then(function() &#123; console.log('glob1_then')&#125;) setTimeout(function() &#123; console.log('timeout2'); process.nextTick(function() &#123; console.log('timeout2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('timeout2_promise'); resolve(); &#125;).then(function() &#123; console.log('timeout2_then') &#125;)&#125;) process.nextTick(function() &#123; console.log('glob2_nextTick');&#125;)new Promise(function(resolve) &#123; console.log('glob2_promise'); resolve();&#125;).then(function() &#123; console.log('glob2_then')&#125;) setImmediate(function() &#123; console.log('immediate2'); process.nextTick(function() &#123; console.log('immediate2_nextTick'); &#125;) new Promise(function(resolve) &#123; console.log('immediate2_promise'); resolve(); &#125;).then(function() &#123; console.log('immediate2_then') &#125;)&#125;) 第一步：宏任务script首先执行。全局入栈。glob1输出。 script首先执行 第二步，执行过程遇到setTimeout。setTimeout作为任务分发器，将任务分发到对应的宏任务队列中。 timeout1进入对应队列 第三步：执行过程遇到setImmediate。setImmediate也是一个宏任务分发器，将任务分发到对应的任务队列中。setImmediate的任务队列会在setTimeout队列的后面执行。 进入setImmediate队列 第四步：执行遇到nextTick，process.nextTick是一个微任务分发器，它会将任务分发到对应的微任务队列中去。 nextTick 第五步：执行遇到Promise。Promise的then方法会将任务分发到对应的微任务队列中，但是它构造函数中的方法会直接执行。因此，glob1_promise会第二个输出。 先是函数调用栈的变化 然后glob1_then任务进入队列 第六步：执行遇到第二个setTimeout。 timeout2进入对应队列 第七步：先后遇到nextTick与Promise glob2_nextTick与Promise任务分别进入各自的队列 第八步：再次遇到setImmediate。 nextTick 这个时候，script中的代码就执行完毕了，执行过程中，遇到不同的任务分发器，就将任务分发到各自对应的队列中去。接下来，将会执行所有的微任务队列中的任务。 其中，nextTick队列会比Promie先执行。nextTick中的可执行任务执行完毕之后，才会开始执行Promise队列中的任务。 当所有可执行的微任务执行完毕之后，这一轮循环就表示结束了。下一轮循环继续从宏任务队列开始执行。 这个时候，script已经执行完毕，所以就从setTimeout队列开始执行。]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>promise</tag>
        <tag>事件循环</tag>
        <tag>event-loop</tag>
        <tag>setTimeOut</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-base64图片转formData]]></title>
    <url>%2F2017%2F11%2F08%2FJS-base64%E5%9B%BE%E7%89%87%E8%BD%ACformData%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839/** * @param base64Codes * 图片的base64编码 */function sumitImageFile(base64Codes) &#123; var form = document.forms[0]; //这里连带form里的其他参数也一起提交了,如果不需要提交其他参数可以直接FormData无参数的构造函数 var formData = new FormData(form); //convertBase64UrlToBlob函数是将base64编码转换为Blob //append函数的第一个参数是后台获取数据的参数名,和html标签的input的name属性功能相同 formData.append("imageName", convertBase64UrlToBlob(base64Codes)); //ajax 提交form $.ajax(&#123; url: form.action, type: "POST", data: formData, dataType: "text", processData: false, // 告诉jQuery不要去处理发送的数据 contentType: false, // 告诉jQuery不要去设置Content-Type请求头 success: function(data) &#123; window.location.href = "$&#123;ctx&#125;" + data; &#125;, xhr: function() &#123; //在jquery函数中直接使用ajax的XMLHttpRequest对象 var xhr = new XMLHttpRequest(); xhr.upload.addEventListener("progress", function(evt) &#123; if (evt.lengthComputable) &#123; var percentComplete = Math.round(evt.loaded * 100 / evt.total); console.log("正在提交." + percentComplete.toString() + '%'); &#125; &#125;, false); return xhr; &#125; &#125;);&#125; 123456789101112131415/** * 将以base64的图片url数据转换为Blob * @param urlData * 用url方式表示的base64图片数据 */function convertBase64UrlToBlob(dataUrl) &#123; //去掉url的头，并转换为byte var bytes = window.atob(dataUrl.split(',')[1]); //处理异常,将ascii码小于0的转换为大于0 var ab = new Uint8Array(bytes.length); for (var i = 0; i &lt; bytes.length; i++) &#123; ab[i] = bytes.charCodeAt(i); &#125; return new Blob([ab], &#123; type: 'image/png' &#125;);&#125;]]></content>
      <tags>
        <tag>base64</tag>
        <tag>formDate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-valueOf与toString]]></title>
    <url>%2F2017%2F10%2F29%2FJS-valueOf%E4%B8%8EtoString%2F</url>
    <content type="text"><![CDATA[一、抛题实现一个函数，运算结果可以满足如下预期结果： 123add(1)(2) // 3add(1, 2, 3)(10) // 16add(1)(2)(3)(4)(5) // 15 二、破题难点：如何既返回一个值又返回一个函数以供后续继续调用？ 12345678910111213function add () &#123; var args = Array.prototype.slice.call(arguments); var fn = function () &#123; var arg_fn = Array.prototype.slice.call(arguments); return add.apply(null, args.concat(arg_fn)); &#125; fn.valueOf = function () &#123; return args.reduce(function(a, b) &#123; return a + b; &#125;) &#125; return fn;&#125; 三、解题1、Object.prototype.valueOf()JavaScript 调用 valueOf() 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，valueOf 方法一般都会被 JavaScript 自动调用。 2、Object.prototype.toString()每个对象都有一个 toString() 方法，当对象被表示为文本值时或者当以期望字符串的方式引用对象时，该方法被自动调用。 3、类型的转换规则(1)String 类型转换转换规则： 如果 toString 方法存在并且返回原始类型，返回 toString 的结果 如果 toString 方法不存在或者返回的不是原始类型，调用 valueOf 方法 如果 valueOf 方法存在，并且返回原始类型数据，返回 valueOf 的结果 其他情况，抛出错误 1234567891011121314var obj = &#123; toString: function() &#123; console.log('调用了 obj.toString'); return &#123;&#125;; &#125;, valueOf: function() &#123; console.log('调用了 obj.valueOf') return '110'; &#125;&#125;alert(obj);// 调用了 obj.toString// 调用了 obj.valueOf// 110 (2)Number 类型转换转换规则： 如果 valueOf 存在，且返回原始类型数据，返回 valueOf 的结果。 如果 toString 存在，且返回原始类型数据，返回 toString 的结果。 其他情况，抛出错误。 123456789101112131415var obj = &#123; valueOf: function() &#123; console.log('调用 valueOf'); return &#123;&#125;; &#125;, toString: function() &#123; console.log('调用 toString'); return 10; &#125;&#125;console.log(obj + 1);// 调用 valueOf// 调用 toString// 11 (3)Boolean 类型转换转换规则 除了下述 6 个值转换结果为 false，其他全部为 true： undefined null -0 0或+0 NaN ”（空字符串） (4)Function类型转换规则转换 如果 valueOf 存在，且返回原始类型数据，返回 valueOf 的结果。 如果 toString 存在，且返回原始类型数据，返回 toString 的结果。 其他情况，抛出错误。 123456789101112131415test.valueOf = function() &#123; console.log('调用 valueOf 方法'); return &#123;&#125;;&#125;test.toString= function() &#123; console.log('调用 toString 方法'); return 3;&#125; test;// 输出如下：// 调用 valueOf 方法// 调用 toString 方法// 3]]></content>
      <tags>
        <tag>valueOf</tag>
        <tag>toString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-addEventListener和on]]></title>
    <url>%2F2017%2F10%2F27%2FJS-addEventListener%E5%92%8Con%2F</url>
    <content type="text"><![CDATA[一、使用on方法绑定事件1234567891011window.onload = function()&#123; var box = document.getElementById("box") box.onclick = function()&#123; console.log("我是box1") &#125; box.onclick = function()&#123; box.style.fontSize = "18px" console.log("我是box2") &#125;&#125; 第一个onclick回调函数会被第二个回调函数覆盖 二、addEventListener绑定事件12345678910window.onload = function()&#123; var box = document.getElementById("box") box.addEventListener("click",function()&#123; console.log("我是box1") &#125;) box.addEventListener("click",function()&#123; console.log("我是box2") &#125;)&#125; addEventListener允许在同一个事件上，绑定多个函数 既不覆盖on方法绑定的函数，也不覆盖addEventListener绑定的函数]]></content>
      <tags>
        <tag>addEventListener</tag>
        <tag>on</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Notification通知]]></title>
    <url>%2F2017%2F10%2F25%2FJS-Notification%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;html5桌面通知&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="开启桌面通知" onclick="showDeskTopNotice('','HTML5桌面消息');"&gt; &lt;script&gt; function showDeskTopNotice(title, msg) &#123; var Notification = window.Notification || window.mozNotification || window.webkitNotification; if (Notification) &#123; Notification.requestPermission(function(status) &#123; // status默认值'default'等同于拒绝 // 'denied' 意味着用户不想要通知 // 'granted' 意味着用户同意启用通知 if ("granted" != status) &#123; return; &#125; else &#123; var tag = "sds" + Math.random(); var notify = new Notification( title, &#123; dir: 'auto', lang: 'zh-CN', //实例化的notification的id tag: tag, //通知的缩略图 icon: 'http://www.yinshuajun.com/static/img/favicon.ico', body: msg //通知的具体内容 &#125; ); notify.onclick = function() &#123; //如果通知消息被点击,通知窗口将被激活 window.focus(); &#125;, notify.onerror = function() &#123; console.log("HTML5桌面消息出错！！！"); &#125;; notify.onshow = function() &#123; setTimeout(function() &#123; notify.close(); &#125;, 2000) &#125;; notify.onclose = function() &#123; console.log("HTML5桌面消息关闭！！！"); &#125;; &#125; &#125;); &#125; else &#123; console.log("您的浏览器不支持桌面消息"); &#125; &#125;; showDeskTopNotice("", "HTML5桌面消息") &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js-webWorker多线程]]></title>
    <url>%2F2017%2F10%2F23%2FJs-webWorker%2F</url>
    <content type="text"><![CDATA[一、概念工作线程（webWorker）允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;script&gt; function init() &#123; //创建一个Worker对象，并向它传递将在新线程中执行的脚本url var worker = new Worker('worker.js') //接收worker传递过来的数据 worker.onmessage = function(event) &#123; document.getElementById('result').innerHTML += event.data + "&lt;br/&gt;" &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="init()"&gt; &lt;div id="result"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314// worker.jsvar i = 0function timedCount() &#123; for (var j = 0, sum = 0; j &lt; 100; j++) &#123; for (var i = 0; i &lt; 100000000; i++) &#123; sum += i &#125; &#125; //将得到的sum发送回主线程 postMessage(sum)&#125;postMessage('Before computing, ' + new Date())timedCount()postMessage('After computing, ' + new Date()) 二、api1、postMessage(data) 子线程与主线程之间互相通信使用方法，传递的data为任意值。 2、terminate() 主线程中终止worker，此后无法再利用其进行消息传递。 3、onmessage 当有消息发送时，触发该事件。消息发送是双向的，消息内容可通过data来获取。 4、onerror 出错处理。且错误消息可以通过e.message来获取。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;worker&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;script&gt; function init() &#123; var worker = new Worker('worker.js') setInterval(function() &#123; worker.postMessage(&#123; name: 'monkey' &#125;) &#125;, 100) worker.onmessage = function(event) &#123; document.getElementById('result').innerHTML += event.data + "&lt;br/&gt;" worker.terminate() &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload="init()"&gt; &lt;div id="result"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123onmessage = function(event)&#123; postMessage(event.data.name)&#125;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>webWorker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js-FullScreen全屏]]></title>
    <url>%2F2017%2F10%2F22%2FJs-FullScreen%E5%85%A8%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[零、禁止全屏12345678910111213&lt;html&gt;&lt;body onkeydown="noFullScreen(event)"&gt; &lt;script type="text/javascript"&gt; function noFullScreen(e) &#123; if (e.keyCode === 122) &#123; e.preventDefault() &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123document.addEventListener("webkitfullscreenchange", function () &#123; document.webkitCancelFullScreen()&#125;, false) 一、进入全屏123456789101112131415// 找到支持的方法, 使用需要全屏的 element 调用 function launchFullScreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen() &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen() &#125;&#125;launchFullScreen(document.documentElement) // 整个页面 launchFullScreen(document.getElementById("videoElement")) // 某个元素 二、退出全屏12345678910// 退出 fullscreen function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen() &#125; else if (document.mozExitFullScreen) &#123; document.mozExitFullScreen() &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen() &#125;&#125; 三、全屏事件1234document.addEventListener("fullscreenchange", function() &#123;&#125;, false) document.addEventListener("mozfullscreenchange", function() &#123;&#125;, false) document.addEventListener("webkitfullscreenchange", function() &#123;&#125;, false) document.addEventListener("msfullscreenchange", function() &#123;&#125;, false) 四、全屏样式12345678910111213html:-moz-full-screen &#123; background: red;&#125;html:-webkit-full-screen &#123; background: red;&#125;html:fullscreen &#123; background: red;&#125;]]></content>
      <tags>
        <tag>FullScreen</tag>
        <tag>全屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-try_files]]></title>
    <url>%2F2017%2F09%2F30%2Fnginx-try-files%2F</url>
    <content type="text"><![CDATA[一、try_files指令 语法：try_files file … uri 或 try_files file … = code 默认值：无 作用域：server location 按顺序检查文件是否存在，返回第一个找到的文件或文件夹(结尾加斜线表示为文件夹)，如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。 二、例子说明1try_files /app/cache/ $uri @fallback; 它将检测/app/cache/index.php、/app/cache/index.html、$uri是否存在，如果不存在着内部重定向到@fallback(＠表示配置文件中预定义标记点) 。你也可以使用一个文件或者状态码(=404)作为最后一个参数，如果是最后一个参数是文件，那么这个文件必须存在。]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>try_files</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx-alias]]></title>
    <url>%2F2017%2F09%2F27%2FNginx-alias%2F</url>
    <content type="text"><![CDATA[root&amp;alias文件路径配置root/alias 是指定文件路径的两种方式，主要区别就是怎么解析location后面的uri 1http://localhost/appImg/abc.jpg 1234location ^~ /appImg/ &#123; root /home/nginx;&#125;# 这个location相当于访问服务器上的文件路径：/home/nginx/appImg/abc.jpg 1234location ^~ /appImg/ &#123; alias /home/nginx/;&#125;# 这个location相当于访问服务器上的文件目录：/home/nginx/abc.jpg]]></content>
      <tags>
        <tag>Nginx</tag>
        <tag>alias</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-padding宽高比]]></title>
    <url>%2F2017%2F09%2F24%2Fcss-padding%E5%AE%BD%E9%AB%98%E6%AF%94%2F</url>
    <content type="text"><![CDATA[对于padding属性而言，任意方向的百分比padding都相对于宽度计算可以让我们轻松实现固定比例的块级容器。 12345678910111213141516div &#123; padding: 50%; &#125;div &#123; padding: 100% 0 0; &#125;div &#123; padding-bottom: 100%; &#125;.banner &#123; padding: 15.15% 0 0; position: relative;&#125; .banner &gt; img &#123; position: absolute; width: 100%; height: 100%; left: 0; top: 0;&#125; 注： 1、图片宽度是100%容器的，padding的15.5%其实就是图片的高宽比例。 2、图片宽度50%容器宽度，图片高宽比4:3，我们也可以这么写 123.img-box &#123; padding: 0 50% 66.66% 0;&#125; 3、如果没有text-align属性干扰，img的position，及left和top可以不用指定]]></content>
      <tags>
        <tag>css</tag>
        <tag>padding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-location]]></title>
    <url>%2F2017%2F09%2F11%2Fnginx-location%2F</url>
    <content type="text"><![CDATA[一、location匹配顺序 “=”前缀指令匹配，如果匹配成功，则停止其他匹配。 普通字符串指令匹配，顺序是从长到短，匹配成功的location如果使用^~，则停止其他匹配（正则匹配）。 正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配。 如果第三步中有匹配成功，则使用该结果，否则使用第二步结果。 匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的location顺序是无关紧要的，反正最后nginx会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个比配的正则表达式将停止搜索。 二、匹配模式及顺序1、模式 ~ 表示执行一个正则匹配，区分大小写 ~* 表示执行一个正则匹配，不区分大小写 ^~ 表示普通字符匹配。使用前缀匹配。如果匹配成功，则不再匹配其他location。 = 进行普通字符精确匹配。也就是完全匹配。 @ 它定义一个命名的 location，使用在内部定向时 2、例子 location = /uri =开头表示精确匹配，只有完全匹配上才能生效。 location ^~ /uri ^~ 开头对URL路径进行前缀匹配，并且在正则之前。 location ~ pattern ~开头表示区分大小写的正则匹配。 location ~* pattern ~*开头表示不区分大小写的正则匹配。 location /uri 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。 location / 通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default。 123456789101112131415161718192021222324upstream tornado &#123; server 127.0.0.1:8001;&#125;server &#123; server_name luokr.com; return 301 $scheme://www.luokr.com$request_uri;&#125;server &#123; listen 80; server_name www.luokr.com; root /var/www/www.luokr.com/V0.3/www; index index.html index.htm; try_files $uri @tornado; location @tornado &#123; proxy_pass_header Server; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://tornado; &#125;&#125;]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-忽略文件规则]]></title>
    <url>%2F2017%2F09%2F04%2FGit-%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[语法规则 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 123456# 这是注释行，将被忽略*.a # 忽略所有以.a为扩展名的文件 !lib.a # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略/TODO # 只忽略此目录下的TODO文件，子目录中的TODO文件不忽略build/ # 忽略所有build目录下的文件，但如果是名为build的文件则不忽略doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略]]></content>
      <tags>
        <tag>git</tag>
        <tag>忽略规则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-圆角半径值]]></title>
    <url>%2F2017%2F08%2F07%2FCSS-%E5%9C%86%E8%A7%92%E5%8D%8A%E5%BE%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[格式和类型 border-*-radius属性的值可分别设定水平半径和垂直半径；若省略垂直半径，则垂直半径默认采用水平半径的值。 而每个值，支持的单位有固定长度和百分比。若设置百分比格式，则水平半径的百分比是指边框的宽度，而垂直半径的百分比是指边框的高度。 1234567891011121314/*表示圆角的水平半径和垂直半径都为20px长度。*/border-radius:20px; /*表示圆角的水平半径的长度为20px，垂直半径的长度为40px。*/border-radius:20px/40px; /*表示圆角的水平半径和垂直半径都为各自边框长度的20%。*/border-radius:20%;/*表示圆角的水平半径为边框宽度的20%，垂直半径都为边框高度的30%。*/border-radius:20%/30%; /*表示圆角的水平半径长度200px，垂直半径都为边框高度的300px。*/border-radius: 200px 0px 0px 0px/300px 0px 0px 0px; 注： 大值特性：只会使用能够渲染的圆角大小渲染 等比例特性：水平半径和垂直半径的比例是恒定不变的]]></content>
      <tags>
        <tag>css</tag>
        <tag>border-radius，圆角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-http]]></title>
    <url>%2F2017%2F08%2F05%2Fnodejs-http%2F</url>
    <content type="text"><![CDATA[一、HTTP服务器request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js： 123456789101112131415161718'use strict';// 导入http模块:var http = require('http');// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + ': ' + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将HTTP响应的HTML内容写入response: response.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);// 让服务器监听8080端口:server.listen(8080); 二、文件服务器我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 12345678910111213141516171819202122232425262728293031323334'use strict';var fs = require('fs');var url = require('url');var path = require('path');var http = require('http');// 从命令行参数获取root目录，默认是当前目录:var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建服务器:var server = http.createServer(function (request, response) &#123; // 获得URL的path，类似 '/css/bootstrap.css': var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css': var filepath = path.join(root, pathname); // 获取文件状态: fs.stat(filepath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log('200 ' + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filepath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log('404 ' + request.url); // 发送404响应: response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-stream]]></title>
    <url>%2F2017%2F08%2F05%2Fnodejs-stream%2F</url>
    <content type="text"><![CDATA[一、读取在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：data事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。 下面是一个从文件流读取文本内容的示例： 1234567891011121314151617'use strict';var fs = require('fs');// 打开一个流:var rs = fs.createReadStream('sample.txt', 'utf-8');rs.on('data', function (chunk) &#123; console.log('DATA:') console.log(chunk);&#125;);rs.on('end', function () &#123; console.log('END');&#125;);rs.on('error', function (err) &#123; console.log('ERROR: ' + err);&#125;); 要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。 二、写入要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束： 123456789101112'use strict';var fs = require('fs');var ws1 = fs.createWriteStream('output1.txt', 'utf-8');ws1.write('使用Stream写入文本数据...\n');ws1.write('END.');ws1.end();var ws2 = fs.createWriteStream('output2.txt');ws2.write(new Buffer('使用Stream写入二进制数据...\n', 'utf-8'));ws2.write(new Buffer('END.', 'utf-8'));ws2.end(); 所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。 三、管道一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。 让我们用pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序： 12345'use strict';var fs = require('fs');var rs = fs.createReadStream('sample.txt');var ws = fs.createWriteStream('copied.txt');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1rs.pipe(ws, &#123; end: false &#125;);]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-fs模块]]></title>
    <url>%2F2017%2F08%2F05%2Fnodejs-fs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[一、异步读文件按照JavaScript的标准，异步读取一个文本文件的代码如下： 123456789'use strict';var fs = require('fs');fs.readFile('sample.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;); 下面的例子演示了如何读取一个图片文件： 12345678910'use strict';var fs = require('fs');fs.readFile('sample.png', function (err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); console.log(data.length + ' bytes'); &#125;&#125;); 二、同步读文件除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个Sync后缀，并且不接收回调函数，函数直接返回结果。 用fs模块同步读取一个文本文件的代码如下： 1234'use strict';var fs = require('fs');var data = fs.readFileSync('sample.txt', 'utf-8');console.log(data); 三、异步写文件将数据写入文件是通过fs.writeFile()实现的： 12345678910'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFile('output.txt', data, function (err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('ok.'); &#125;&#125;); 四、同步写文件1234'use strict';var fs = require('fs');var data = 'Hello, Node.js';fs.writeFileSync('output.txt', data); 五、stat如果我们要获取文件大小，创建时间等信息，可以使用fs.stat()，它返回一个Stat对象，能告诉我们文件或目录的详细信息： 1234567891011121314151617181920'use strict';var fs = require('fs');fs.stat('sample.txt', function (err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; // 是否是文件: console.log('isFile: ' + stat.isFile()); // 是否是目录: console.log('isDirectory: ' + stat.isDirectory()); if (stat.isFile()) &#123; // 文件大小: console.log('size: ' + stat.size); // 创建时间, Date对象: console.log('birth time: ' + stat.birthtime); // 修改时间, Date对象: console.log('modified time: ' + stat.mtime); &#125; &#125;&#125;); stat()也有一个对应的同步函数statSync()。]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>fs模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-process对象]]></title>
    <url>%2F2017%2F08%2F05%2Fnodejs-process%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[process是Node.js提供的一个对象，它代表当前Node.js进程。 12345678910111213process === global.process; //True process.version; //'v5.2.0' process.platform; //'darwin' process.arch; //'x64' process.cwd(); //返回当前工作目录: '/Users/michael' process.chdir('/private/tmp'); // 切换当前工作目录:Undefined process.cwd(); // '/private/tmp' JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。如果我们想要在下一次事件循环中执行代码，可以调用process.nextTick()： 12345678// test.js// process.nextTick()将在下一轮事件循环中调用:process.nextTick(function () &#123; console.log('nextTick callback!');&#125;);console.log('nextTick was set!'); 用Node执行上面的代码node test.js，你会看到，打印输出是： 12nextTick was set!nextTick callback! 这说明传入process.nextTick()的函数不是立刻执行，而是要等到下一次事件循环。 Node.js进程本身的事件就由process对象来处理。如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数： 1234// 程序即将退出时的回调函数:process.on('exit', function (code) &#123; console.log('about to exit with code: ' + code);&#125;);]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs-模块原理]]></title>
    <url>%2F2017%2F08%2F05%2Fnodejs-%E6%A8%A1%E5%9D%97%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[零、区别Node.js 模块遵循CommonJS规范，ES6 模块与CommonJS模块的差异有以下两点 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 一、Node.js 模块实现原理 实现“模块”功能的奥妙就在于JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。假如我们编写的hello.js代码是这样的： 123var s = 'Hello';var name = 'world';console.log(s + ' ' + name + '!'); Node.js加载了hello.js后，它可以把代码包装一下，变成这样执行： 1234567(function () &#123; // 读取的hello.js代码: var s = 'Hello'; var name = 'world'; console.log(s + ' ' + name + '!'); // hello.js代码结束&#125;)(); 所以，Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离。 但是，模块的输出module.exports怎么实现？这个也很容易实现，Node可以先准备一个对象module： 12345678910111213141516171819// 准备module对象:var module = &#123; id: 'hello', exports: &#123;&#125;&#125;; var load = function (module) &#123; // 读取的hello.js代码: function greet(name) &#123; console.log('Hello, ' + name + '!'); &#125; module.exports = greet; // hello.js代码结束 return module.exports;&#125;; var exported = load(module);// 保存module:save(module, exported); 可见，变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数，我们在hello.js中 可以直接使用变量module原因就在于它实际上是函数的一个参数： 1module.exports = greet; 通过把参数module传递给load()函数，hello.js就顺利地把一个变量传递给了Node执行环境，Node会把module变量保存到某个地方。 由于Node保存了所有导入的module，当我们用require()获取module时，Node找到对应的module，把这个module的exports变量返回，这样，另一个模块就顺利拿到了模块的输出： 1var greet = require('./hello'); 以上是Node实现JavaScript模块的一个简单的原理介绍。]]></content>
      <tags>
        <tag>nodejs</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html空节点（3px空隙问题）]]></title>
    <url>%2F2017%2F07%2F31%2Fhtml%E7%A9%BA%E8%8A%82%E7%82%B9%EF%BC%883px%E7%A9%BA%E9%9A%99%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[换行与空隙html换行被解析为空格。也是常说的3像素空隙的问题，根据测试不同浏览器产生的空隙大小会不一样。 Chrome，Firefox，IE8+都存在这样的问题，浏览器把换行或空格解析成了“空白节点”，就是javascript中nodeType等于3的节点，IE6,7是忽略这个节点的。 1234span &#123; border: 1px solid red; padding: .5em 1em;&#125; 123&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 处理方法1、不换行1&lt;span&gt;1&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 2、设置margin-left为负值12345span &#123; border: 1px solid red; padding: .5em 1em; margin-left: -3px;&#125; 3、设置父元素字体大小为0123456789div &#123; font-size: 0px;&#125;span &#123; border: 1px solid red; padding: .5em 1em; font-size: 12px;&#125; 12345&lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>3px</tag>
        <tag>空隙</tag>
        <tag>空节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5-FileReader]]></title>
    <url>%2F2017%2F07%2F25%2FH5-FileReader%2F</url>
    <content type="text"><![CDATA[一、FileListFileList 对象针对表单的 file 控件。当用户通过 file 控件选取文件后，这个控件的 files 属性值就是 FileList 对象。它在结构上类似于数组，数组里每一个元素都是File对象，包含用户选取的多个文件。如果 file 控件没有设置 multiple 属性，那么用户只能选择一个文件，FileList 对象也就只有一个元素了。 二、File我们看到一个 FileList 对象包含了我们选中的 File 对象 三、FileReader用来把文件读入内存，并且读取文件中的数据。FileReader接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。 1、FileReader接口的方法FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。 方法名 参数 描述 readAsBinaryString file 将文件读取为二进制编码 readAsText file,[encoding] 将文件读取为文本 readAsDataURL file 将文件读取为DataURL abort (none) 终端读取操作 2、FileReader接口事件FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。 事件 描述 onabort 中断 onerror 出错 onloadstart 开始 onprogress 正在读取 onload 成功读取 onloadend 读取完成，无论成功失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var result = document.getElementById("result"); var file = document.getElementById("file"); //判断浏览器是否支持FileReader接口 if (typeof FileReader == 'undefined') &#123; result.InnerHTML = "&lt;p&gt;你的浏览器不支持FileReader接口！&lt;/p&gt;"; //使选择控件不可操作 file.setAttribute("disabled", "disabled"); &#125;//检验是否为图像文件 function readAsDataURL() &#123; var file = document.getElementById("file").files[0]; if (!/image\/\w+/.test(file.type)) &#123; alert("看清楚，这个需要图片！"); return false; &#125; var reader = new FileReader(); //将文件以Data URL形式读入页面 reader.readAsDataURL(file); reader.onload = function(e) &#123; //显示文件 var result = document.getElementById("result"); result.innerHTML = '&lt;img src="' + this.result + '" alt="" /&gt;'; &#125;&#125; function readAsBinaryString() &#123; var file = document.getElementById("file").files[0]; var reader = new FileReader(); //将文件以二进制形式读入页面 reader.readAsBinaryString(file); reader.onload = function(f) &#123; //显示文件 var result = document.getElementById("result"); result.innerHTML = this.result; &#125;&#125; function readAsText() &#123; var file = document.getElementById("file").files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload = function(f) &#123; //显示文件 var result = document.getElementById("result"); result.innerHTML = this.result; &#125;&#125; 12345678&lt;p&gt; &lt;label&gt;请选择一个文件：&lt;/label&gt; &lt;input type="file" id="file" /&gt; &lt;input type="button" value="读取图像" onclick="readAsDataURL()" /&gt; &lt;input type="button" value="读取二进制数据" onclick="readAsBinaryString()" /&gt; &lt;input type="button" value="读取文本文件" onclick="readAsText()" /&gt;&lt;/p&gt;&lt;div id="result" name="result"&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>FileReader</tag>
        <tag>FileList</tag>
        <tag>File</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-三种对话框]]></title>
    <url>%2F2017%2F07%2F25%2FJS-%E4%B8%89%E7%A7%8D%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728//弹出对话框并输出一段提示信息 function ale() &#123; //弹出一个对话框 alert("提示信息！"); &#125;//弹出一个询问框，有确定和取消按钮 function firm() &#123; //利用对话框返回的值 （true 或者 false） if (confirm("你确定提交吗？")) &#123; alert("点击了确定"); &#125; else &#123; alert("点击了取消"); &#125; &#125;//弹出一个输入框，输入一段文字，可以提交 function prom() &#123; //将输入的内容赋给变量 name ， var name = prompt("请输入您的名字", ""); //这里需要注意的是，prompt有两个参数，前面是提示的话，后面是当对话框出来后，在对话框里的默认值 //如果返回的有内容 if (name) &#123; alert("欢迎您：" + name) &#125; &#125;]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>对话框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-正则表达式]]></title>
    <url>%2F2017%2F07%2F14%2FJS-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[语法 \d可以匹配一个数字，等价于[0-9] \w可以匹配一个单字字符 （字母、数字或者下划线） ，等价于[A-Za-z0-9_] \W匹配一个非单字字符，等价于[^A-Za-z0-9_] .可以匹配一个任意字符 ，换行符除外 \s匹配一个空白字符，包括空格、制表符、换页符和换行符 \S匹配一个非空白字符 *表示任意个字符，等价于 {0,} +表示至少一个字符，等价于 {1,} ?表示0个或1个字符，等价于 {0,1} {n}表示n个字符 {n,m}表示n-m个字符 \转义 (x)匹配 &#39;x&#39;并且记住匹配项 [xyz]一个字符集合 [^xyz]一个反向字符集 A|B可以匹配A或B ^表示行的开头或非的意思 $表示行的结束]]></content>
      <tags>
        <tag>javaScript</tag>
        <tag>正则表达式</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
</search>
