<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaMail]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F27%2FJavaMail%2F</url>
    <content type="text"><![CDATA[一、RFC882文档简单说明RFC882文档规定了如何编写一封简单的邮件(纯文本邮件)，一封简单的邮件包含邮件头和邮件体两个部分，邮件头和邮件体之间使用空行分隔。 邮件头包含的内容有： from字段：用于指明发件人 to字段：用于指明收件人 subject字段：用于说明邮件主题 cc字段：抄送，将邮件发送给收件人的同时抄送给另一个收件人，收件人可以看到邮件抄送给了谁 bcc字段：密送，将邮件发送给收件人的同时将邮件秘密发送给另一个收件人，收件人无法看到邮件密送给了谁 邮件体指的就是邮件的具体内容 二、MIME协议简单介绍MIME协议是对RFC822文档的升级和补充，它描述了如何生产一封复杂的邮件。通常我们把MIME协议描述的邮件称之为MIME邮件。MIME协议描述的数据称之为MIME消息。对于一封复杂邮件，如果包含了多个不同的数据，MIME协议规定了要使用分隔线对多段数据进行分隔，并使用Content-Type头字段对数据的类型、以及多个数据之间的关系进行描述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.io.FileOutputStream;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Message;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;public class Sendmail &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Properties prop = new Properties(); prop.setProperty("mail.host", "smtp.sohu.com"); prop.setProperty("mail.transport.protocol", "smtp"); prop.setProperty("mail.smtp.auth", "true"); //1、创建session Session session = Session.getInstance(prop); //开启Session的debug模式，这样就可以查看到程序发送Email的运行状态 session.setDebug(true); //2、通过session得到transport对象 Transport ts = session.getTransport(); //3、连上邮件服务器 ts.connect("smtp.sohu.com", "gacl", "邮箱密码"); //4、创建邮件 Message message = createMixedMail(session); //5、发送邮件 ts.sendMessage(message, message.getAllRecipients()); ts.close(); &#125; /** * @param session * @return * @throws Exception */ public static MimeMessage createMixedMail(Session session) throws Exception &#123; //创建邮件 MimeMessage message = new MimeMessage(session); //设置邮件的基本信息 message.setFrom(new InternetAddress("gacl@sohu.com")); message.setRecipient( Message.RecipientType.TO, new InternetAddress("xdp_gacl@sina.cn") ); message.setSubject("带附件和带图片的的邮件"); //正文 MimeBodyPart text = new MimeBodyPart(); text.setContent("图片&lt;img src='cid:aaa.jpg'&gt;","text/html;charset=UTF-8"); //图片 MimeBodyPart image = new MimeBodyPart(); image.setDataHandler(new DataHandler(new FileDataSource("src\\3.jpg"))); image.setContentID("aaa.jpg"); //附件1 MimeBodyPart attach = new MimeBodyPart(); DataHandler dh = new DataHandler(new FileDataSource("src\\4.zip")); attach.setDataHandler(dh); attach.setFileName(dh.getName()); //附件2 MimeBodyPart attach2 = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource("src\\波子.zip")); attach2.setDataHandler(dh2); attach2.setFileName(MimeUtility.encodeText(dh2.getName())); // 中文乱码 //描述关系:正文和图片 MimeMultipart mp1 = new MimeMultipart(); mp1.addBodyPart(text); mp1.addBodyPart(image); mp1.setSubType("related"); //描述关系:正文和附件 MimeMultipart mp2 = new MimeMultipart(); mp2.addBodyPart(attach); mp2.addBodyPart(attach2); //代表正文的bodypart MimeBodyPart content = new MimeBodyPart(); content.setContent(mp1); mp2.addBodyPart(content); mp2.setSubType("mixed"); message.setContent(mp2); message.saveChanges(); message.writeTo(new FileOutputStream("E:\\MixedMail.eml")); //返回创建好的的邮件 return message; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch聚合]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E8%81%9A%E5%90%88%2F</url>
    <content type="text"><![CDATA[Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。 普通嵌套 123456789101112131415161718192021222324GET /cars/transactions/_search&#123; "aggs": &#123; "colors": &#123; "terms": &#123; "field": "color" &#125;, "aggs": &#123; // avg_price桶 "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, // 与avg_price桶并列 "make": &#123; "terms": &#123; "field": "make" &#125; &#125; &#125; &#125; &#125;&#125; nested嵌套 1234567891011121314151617181920212223242526272829POST ds-epsm-all/post/_search&#123; "aggs": &#123; // 情感 "sentiment": &#123; "nested": &#123; "path": "obj_info" &#125;, "aggs": &#123; // 情感-对象（专题） "name": &#123; "terms": &#123; "field": "obj_info.obj_name", "size": 1 &#125;, "aggs": &#123; // 情感-类型（正中负） "sentiment": &#123; "terms": &#123; "field": "obj_info.obj_sentiment", "size": 10 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 过滤功能 123456789101112131415161718192021GET /cars/transactions/_search&#123; "aggs":&#123; "recent_sales": &#123; "filter": &#123; "range": &#123; "sold": &#123; "from": "now-1M" &#125; &#125; &#125;, "aggs": &#123; "average_price":&#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; 指定聚合值 1234567891011121314GET ds-epsm-all/post/_search&#123; "aggs": &#123; "subject": &#123; "terms": &#123; "field": "category_tags", // 包括 "include": ["母品牌", "伊利股份"], // 排除 "exclude": ["蒙牛"], &#125; &#125; &#125;&#125; top_hits 1234567891011121314151617GET ds - epsm - all / post / _search &#123; "aggs": &#123; "similar": &#123; "top_hits": &#123; "size": 3, "sort": [ &#123; "similar_doc_count": &#123; "order": "desc" &#125; &#125; ] &#125; &#125; &#125;&#125; 按时间统计 123456789101112GET /cars/transactions/_search&#123; "aggs": &#123; "sales": &#123; "date_histogram": &#123; "field": "sold", "interval": "month", "format": "yyyy-MM-dd" &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch排序]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在 Elasticsearch 中， 相关性得分 由一个浮点数进行表示，并在搜索结果中通过 _score 参数返回， 默认排序是 _score 降序。 简单指定字段排序 1&quot;sort&quot;: &quot;number_of_children&quot; 字段将会默认升序排序 ，而按照 _score 的值进行降序排序 按照字段的值排序 123456789GET /_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 1 &#125;&#125; &#125; &#125;, &quot;sort&quot;: &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;&#125; 多级排序 12345678910111213GET /_search&#123; &quot;query&quot; : &#123; &quot;bool&quot; : &#123; &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;manage text search&quot; &#125;&#125;, &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 2 &#125;&#125; &#125; &#125;, &quot;sort&quot;: [ &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;, &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125; ]&#125; 排序条件的顺序是很重要的。结果首先按第一个条件排序，仅当结果集的第一个 sort 值完全相同时才会按照第二个条件进行排序，以此类推。 多值（数组）字段排序 123456&quot;sort&quot;: &#123; &quot;dates&quot;: &#123; &quot;order&quot;: &quot;asc&quot;, &quot;mode&quot;: &quot;min&quot; &#125;&#125; 字段有多个值的排序，这些值并没有固有的顺序。对于数字或日期，你可以将多值字段减为单值，这可以通过使用 min 、 max 、 avg 或是 sum 排序模式。]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch字段类型]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F14%2FElasticsearch%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[字段类型 简单域类型： 字符串: string 整数 : byte, short, integer, long 浮点数: float, double 布尔型: boolean 日期: date 对象类型 12345678910111213&#123; &quot;tweet&quot;: &quot;Elasticsearch is very flexible&quot;, &quot;user&quot;: &#123; &quot;id&quot;: &quot;@johnsmith&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;age&quot;: 26, &quot;name&quot;: &#123; &quot;full&quot;: &quot;John Smith&quot;, &quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Smith&quot; &#125; &#125;&#125; 12345678910111213141516171819202122232425&#123; &quot;gb&quot;: &#123; &quot;tweet&quot;: &#123; &quot;properties&quot;: &#123; &quot;tweet&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;user&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;gender&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;full&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;first&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &quot;last&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 数组类型 在ElasticSearch中，没有专门的数组（Array）数据类型。但是，在默认情况下，任意一个字段都可以包含0或多个值，这意味着每个字段默认都是数组类型。不过，数组类型的各个元素值的数据类型必须相同。 在ElasticSearch中，数组是开箱即用的（out of box），不需要进行任何配置，就可以直接使用。 详细类型]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>字段类型</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-FastJson]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F13%2Fjava-FastJson%2F</url>
    <content type="text"><![CDATA[####简单说明 FastJson对于json格式字符串的解析主要用到了下面三个类： JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换 JSONObject：fastJson提供的json对象 JSONArray：fastJson提供json数组对象 用法首先定义三个json格式的字符串 12345678//json字符串-简单对象型private static final String JSON_OBJ_STR = "&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;";//json字符串-数组类型private static final String JSON_ARRAY_STR = "[&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;,&#123;\"studentName\":\"lucy\",\"studentAge\":15&#125;]";//复杂格式json字符串private static final String COMPLEX_JSON_STR = "&#123;\"teacherName\":\"crystall\",\"teacherAge\":27,\"course\":&#123;\"courseName\":\"english\",\"code\":1270&#125;,\"students\":[&#123;\"studentName\":\"lily\",\"studentAge\":12&#125;,&#123;\"studentName\":\"lucy\",\"studentAge\":15&#125;]&#125;"; json字符串-简单对象型与JSONObject之间的转换123456789101112131415161718192021222324252627282930/** * json字符串-简单对象型到JSONObject的转换 */@Testpublic void testJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") );&#125;/** * JSONObject到json字符串-简单对象型的转换 */@Testpublic void testJSONObjectToJSONStr() &#123; //已知JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); // 第一种方式 String jsonString = JSONObject.toJSONString(jsonObject); // 第二种方式 //String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; json字符串(数组类型)与JSONArray之间的转换1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * json字符串-数组类型到JSONArray的转换 */@Testpublic void testJSONStrToJSONArray() &#123; JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历方式1 int size = jsonArray.size(); for (int i = 0; i &lt; size; i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") ); &#125; //遍历方式2 for (Object obj: jsonArray) &#123; JSONObject jsonObject = (JSONObject) obj; System.out.println( "studentName: " + jsonObject.getString("studentName") + ":" + " studentAge: " + jsonObject.getInteger("studentAge") ); &#125;&#125;/** * JSONArray到json字符串-数组类型的转换 */@Testpublic void testJSONArrayToJSONStr() &#123; //已知JSONArray,目标要转换为json字符串 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式 String jsonString = JSONArray.toJSONString(jsonArray); // 第二种方式 //String jsonString = jsonArray.toJSONString(jsonArray); System.out.println(jsonString);&#125; 复杂json格式字符串与JSONObject之间的转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 复杂json格式字符串到JSONObject的转换 */@Testpublic void testComplexJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); String teacherName = jsonObject.getString("teacherName"); Integer teacherAge = jsonObject.getInteger("teacherAge"); System.out.println( "teacherName: " + teacherName + " teacherAge: " + teacherAge ); JSONObject jsonObjectcourse = jsonObject.getJSONObject("course"); //获取JSONObject中的数据 String courseName = jsonObjectcourse.getString("courseName"); Integer code = jsonObjectcourse.getInteger("code"); System.out.println("courseName: " + courseName + " code: " + code); JSONArray jsonArraystudents = jsonObject.getJSONArray("students"); //遍历JSONArray for (Object object: jsonArraystudents) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString("studentName"); Integer studentAge = jsonObjectone.getInteger("studentAge"); System.out.println( "studentName: " + studentName + " studentAge: " + studentAge ); &#125;&#125;/** * 复杂JSONObject到json格式字符串的转换 */@Testpublic void testJSONObjectToComplexJSONStr() &#123; //复杂JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式 //String jsonString = JSONObject.toJSONString(jsonObject); //第二种方式 String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125;]]></content>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Scheduled]]></title>
    <url>%2FendBlogs%2F2019%2F05%2F12%2FSpring-Scheduled%2F</url>
    <content type="text"><![CDATA[@Scheduled注解参数fixedDelay上一次执行完毕时间点之后多长时间再执行 12 //上一次执行完毕时间点之后5秒再执行@Scheduled(fixedDelay = 5000) fixedRate上一次开始执行时间点之后多长时间再执行 12//上一次开始执行时间点之后5秒再执行@Scheduled(fixedRate = 5000) initialDelay第一次延迟多长时间后再执行 12//第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次@Scheduled(initialDelay=1000, fixedRate=5000) cron该参数接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。cron表达式语法： 1[秒] [分] [时] [日] [月] [周] [年] 注：[年]不是必须的域，可以省略[年] 序号 说明 必填 允许填写的值 允许的通配符 1 秒 是 0-59 , - * / 2 分 是 0-59 , - * / 3 时 是 0-23 , - * / 4 日 是 1-31 , - * ? / L W 5 月 是 1-12 / JAN-DEC , - * / 6 周 是 1-7 or SUN-SAT , - * ? / L # 7 年 否 1970-2099 , - * / 通配符说明: * 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。 ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ? - 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。 , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份， 如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。 如果在”L”前加上数字，则表示该数据的最后一个。 例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五” W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。 如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。 # 序号，表示每月的第几个周几。 例如在周字段上设置”6#3”表示在每月的第三个周六 注意如果指定”#5”，正好第五周没有周六，则不会触发该配置 如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发 1234567891011121314151617181920212223242526// 每隔5秒执行一次*/5 * * * * ?// 每隔1分钟执行一次0 */1 * * * ?// 每天23点执行一次0 0 23 * * ?// 每天凌晨1点执行一次0 0 1 * * ?// 每月1号凌晨1点执行一次0 0 1 1 * ?// 每月最后一天23点执行一次0 0 23 L * ?// 每周星期天凌晨1点实行一次0 0 1 ? * L// 在26分、29分、33分执行一次0 26,29,33 * * * ?// 每天的0点、13点、18点、21点都执行一次0 0 0,13,18,21 * * ?]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Scheduled</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遍历]]></title>
    <url>%2FendBlogs%2F2019%2F04%2F10%2Fjava%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Collection对象-遍历器1234567/* 建立一个Collection */String[] strings = &#123; "A"， "B"， "C"， "D" &#125;;Collection stringList = java.util.Arrays.asList(strings);for (Iterator itr = stringList.iterator(); itr.hasNext();) &#123; Object str = itr.next(); System.out.println(str);&#125; for(:)循环1234String[] strings = &#123; "A"， "B"， "C"， "D" &#125;;Collection list = java.util.Arrays.asList(strings);for (String str: list) &#123; System.out.println(str);&#125;// for (String str: strings) &#123; System.out.println(str);&#125; 遍历Map1234567891011Map &lt; Integer, Integer &gt; map = new HashMap &lt; Integer, Integer &gt; ();//遍历map中的键 for (Integer key: map.keySet()) &#123; System.out.println("Key = " + key);&#125;//遍历map中的值 for (Integer value: map.values()) &#123; System.out.println("Value = " + value);&#125; 数组转Set或List123456789101112// CollectionUtils.addAll()import org.apache.commons.collections.CollectionUtils; String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = new ArrayList();Set strSet = new HashSet();CollectionUtils.addAll(strList, strArray); CollectionUtils.addAll(strSet, strArray);// Arrays.asList()import java.util.Arrays;String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = Arrays.asList(strArray); Set和List转数组12345678910// Collection的toArray()方法// Object[] toArray();String[] strArray = &#123;"aaa", "bbb", "ccc"&#125;;List strList = Arrays.asList(strArray);Object[] obj = strList.toArray();for (int i = 0; i &lt; obj.length; i++) &#123; String str = (String) obj[i]; System.out.println(str);&#125;]]></content>
      <tags>
        <tag>for</tag>
        <tag>Collection</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F29%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[12Runnable noArguments = () -&gt; System.out.println("Hello World");// Runnable 12ActionListener oneArgument = event -&gt; System.out.println("button clicked");// ActionListener 12345Runnable multiStatement = () -&gt; &#123; System.out.print("Hello"); System.out.println(" World");&#125;;// Runnable 12BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;// BinaryOperator 12BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;// BinaryOperator 注：Lambda 表达式都可以扩写为原始的匿名类形式]]></content>
      <tags>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java匿名内部类]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F29%2Fjava%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[匿名内部类123new 父类构造器（参数列表）| 实现接口（）&#123; //匿名内部类的类体部分 &#125; 12345button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("button clicked"); &#125;&#125;); 使用匿名内部类时，我们必须且只能继承一个类或者实现一个接口 匿名内部类中是不能定义构造函数的 匿名内部类中不能存在任何的静态成员变量和静态方法 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 匿名内部类初始化利用构造代码块能够达到为匿名内部类创建一个构造器的效果 123456789101112131415161718return new InnerClass() &#123; int age_; String name_; //构造代码块完成初始化工作 &#123; if (0 &lt; age &amp;&amp; age &lt; 200) &#123; age_ = age; name_ = name; &#125; &#125; public String getName() &#123; return name_; &#125; public int getAge() &#123; return age_; &#125;&#125;; 注：内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。]]></content>
      <tags>
        <tag>java</tag>
        <tag>内部类</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch搜索]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F28%2FElasticsearch%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[有两种形式的 搜索 API：一种是轻量的查询字符串版本，要求在查询字符串中传递所有的参数，另一种是更完整的请求体版本，要求使用 JSON 格式和更丰富的查询表达式作为搜索语言。 查询字符串12GET /_all/tweet/_search?q=+name:john+tweet:mary# 查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档 + 前缀表示必须与查询条件匹配 - 前缀表示一定不与查询条件匹配 没有 + 或者 - 的所有其他条件都是可选的 匹配的越多，文档就越相关 取所有字段的值拼接成一个大的字符串，作为 _all 字段进行索引 1234+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)# name 字段中包含 mary 或者 john# date 值大于 2014-09-10# _all 字段包含 aggregations 或者 geo 注：查询字符串搜索允许任何用户在索引的任意字段上执行可能较慢且重量级的查询，这可能会暴露隐私信息，甚至将集群拖垮。 请求体查询请求体查询，不仅可以处理自身的查询请求，还允许你对结果进行片段强调（高亮）、对所有或部分结果进行聚合分析，同时还可以给出 你是不是想找的建议。 match_all 查询match_all 查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询： 1&#123; "match_all": &#123;&#125;&#125; match 查询无论你在任何字段上进行的是全文搜索还是精确查询，match 查询是你可用的标准查询。 如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串： 1234&#123; "match": &#123; "tweet": "About Search" &#125;&#125;// 如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串// 如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段// 那么它将会精确匹配给定的值 multi_match 查询multi_match 查询可以在多个字段上执行相同的 match 查询： 123456&#123; "multi_match": &#123; "query": "full text search", "fields": [ "title", "body" ] &#125;&#125; range 查询range 查询找出那些落在指定区间内的数字或者时间： 123456789101112&#123; "range": &#123; "age": &#123; "gte": 20, "lt": 30 &#125; &#125;&#125;// gt 大于// gte 大于等于// lt 小于// lte 小于等于 term 查询term 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串： 1234&#123; "term": &#123; "age": 26 &#125;&#125;&#123; "term": &#123; "date": "2014-09-01" &#125;&#125;&#123; "term": &#123; "public": true &#125;&#125;&#123; "term": &#123; "tag": "full_text" &#125;&#125; terms 查询terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 1&#123; "terms": &#123; "tag": [ "search", "full_text", "nosql" ] &#125;&#125; exists 查询和 missing 查询exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性： 12345&#123; "exists": &#123; "field": "title" &#125;&#125; 组合多查询 bool bool 查询将多个查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数： must：文档 必须 匹配这些条件才能被包含进来 must_not：文档 必须不匹配这些条件才能被包含进来 should：如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响 filter：必须匹配，但它以不评分、过滤模式来进行 一条复合语句可以合并 任何 其它查询语句，包括复合语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;:&#123; &quot;about&quot;:&quot;rock climbing&quot; &#125;, &quot;match&quot;:&#123; &quot;last_name&quot;:&quot;Smith&quot; &#125;, &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;tweet&quot;:&quot;elasticsearch&quot; &#125; &#125;, &quot;must_not&quot;:&#123; &quot;match&quot;:&#123; &quot;name&quot;:&quot;mary&quot; &#125; &#125;, &quot;should&quot;:[ &#123; &quot;match&quot;:&#123; &quot;starred&quot;:true &#125; &#125;, &#123; &quot;bool&quot;:&#123; &quot;must&quot;:&#123; &quot;match&quot;:&#123; &quot;folder&quot;:&quot;inbox&quot; &#125; &#125;, &quot;must_not&quot;:&#123; &quot;match&quot;:&#123; &quot;spam&quot;:true &#125; &#125; &#125; &#125; ], &quot;filter&quot;:&#123; &quot;range&quot;:&#123; &quot;age&quot;:&#123; &quot;gt&quot;:30 &#125; &#125; &#125; &#125;, &quot;minimum_should_match&quot;:1 &#125;, &quot;highlight&quot;:&#123; &quot;fields&quot;:&#123; &quot;about&quot;:&#123; &#125; &#125; &#125;, &quot;aggs&quot;:&#123; &quot;all_interests&quot;:&#123; &quot;terms&quot;:&#123; &quot;field&quot;:&quot;interests&quot; &#125;, &quot;aggs&quot;:&#123; &quot;avg_age&quot;:&#123; &quot;avg&quot;:&#123; &quot;field&quot;:&quot;age&quot; &#125; &#125; &#125; &#125; &#125;&#125; 多索引、多类型 /_search：在所有的索引中搜索所有的类型 /gb/_search：在 gb 索引中搜索所有的类型 /gb,us/_search：在 gb 和 us 索引中搜索所有的文档 /g*,u*/_search：在任何以 g 或者 u 开头的索引中搜索所有的类型 /gb/user/_search：在 gb 索引中搜索 user 类型 /gb,us/user,tweet/_search：在 gb 和 us 索引中搜索 user 和 tweet 类型 /_all/user,tweet/_search：在所有的索引中搜索 user 和 tweet 类型]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-static块]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F26%2Fjava-static%E5%9D%97%2F</url>
    <content type="text"><![CDATA[static块static{}，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法 1234567891011121314151617public class TestStatic &#123; static &#123; System.out.println(1); &#125; static &#123; System.out.println(2); &#125; public static void main(String args[]) &#123; System.out.println(4); &#125; static &#123; System.out.println(3); &#125;&#125; 类加载特性 在虚拟机的生命周期中一个类只被加载一次 类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的 类加载的时机 第一次创建对象要加载类 调用静态方法时要加载类,访问静态属性时会加载类 加载子类时必定会先加载父类 创建对象引用不加载类 子类调用父类的静态方法时 当子类没有覆盖父类的静态方法时，只加载父类，不加载子类 当子类有覆盖父类的静态方法时，既加载父类，又加载子类 访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。]]></content>
      <tags>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis入门]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F22%2Fredis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redis 配置服务端：redis-server 客户端：redis-cli 通过 CONFIG命令查看或设置配置项 123# 查看：CONFIG GET CONFIG_SETTING_NAMECONFIG GET loglevelCONFIG GET * # 使用 * 号获取所有配置项 12# 配置：CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUECONFIG SET loglevel "notice" Redis 数据类型123456789101112131415161718192021222324# String（字符串）# string 类型是二进制安全的，可以包含jpg图片或者序列化的对象# 一个键最大能存储512MBSET name "runoob" # SET key valueGET name # GET key# Hash（哈希）HMSET myhash field1 "Hello" field2 "World"HGET myhash field1HGET myhash field2# List（列表）lpush runoob redislpush runoob mongodblpush runoob rabitmqlrange runoob 0 10# Set（集合）# 成功返回1，如果元素已经在集合中返回 0sadd runoob redissadd runoob mongodbsadd runoob rabitmqsadd runoob rabitmq # 重复smembers runoob Java 使用 RedisRedis Java String(字符串) 实例123456789101112131415import redis.clients.jedis.Jedis; public class RedisStringJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); //设置 redis 字符串数据 jedis.set("runoobkey", "www.runoob.com"); // 获取存储的数据并输出 System.out.println("redis 存储的字符串为: "+ jedis.get("runoobkey")); &#125;&#125; Redis Java List(列表) 实例123456789101112131415161718192021import java.util.List;import redis.clients.jedis.Jedis; public class RedisListJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); //存储数据到列表中 jedis.lpush("site-list", "Runoob"); jedis.lpush("site-list", "Google"); jedis.lpush("site-list", "Taobao"); // 获取存储的数据并输出 List&lt;String&gt; list = jedis.lrange("site-list", 0 ,2); for(int i=0; i&lt;list.size(); i++) &#123; System.out.println("列表项为: "+list.get(i)); &#125; &#125;&#125; Redis Java Keys 实例12345678910111213141516171819import java.util.Iterator;import java.util.Set;import redis.clients.jedis.Jedis; public class RedisKeyJava &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis("localhost"); System.out.println("连接成功"); // 获取数据并输出 Set&lt;String&gt; keys = jedis.keys("*"); Iterator&lt;String&gt; it=keys.iterator() ; while(it.hasNext())&#123; String key = it.next(); System.out.println(key); &#125; &#125;&#125; 参数说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379 port 63794. 绑定的主机地址 bind 127.0.0.15. 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折中，默认值） appendfsync everysec21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库表格设计与范式]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%A0%BC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、表设计 数据库实体间是一对多、多对多关系时，如何进行表设计： 一对多：添加外键 多对多 ：建立关系表 注： 添加外键时，尽量只记录外键，不创建外键约束 推荐业务层级的约束，慎重使用数据库层级的约束，为表结构的重构提供可能性 12# 慎重foreign key(member_id) references member (id); 业务层级约束 物理删除 删除数据时，手动查看当前数据主键被引用的情况 存在引用，不能删除 不存在引用，可以删除 注：主键可能会被新增的表引用，因此每新增一个引用，都需要添加一种查看引用情况的逻辑 非物理删除 123456# 使用status字段，表示数据的可用状态# 被其他表引用时，不添加外键约束# 删除数据时，不用考虑被其他表引用，从而导致数据不一致的情况status = 1： 可用。可执行操作包括，删、查、改status = 0： 不可用。可执行操作包括，删、查、改status = -1： 已删除。执行操作包括，查、改(只允许修改status字段) 二、范式第一范式：如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式 1地址：可以拆分为省、市、区、详细地址 第二范式：第二范式在第一范式的基础之上更进一层。 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关，主要针对联合主键而言。 也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 第三范式：第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 12# 通过a不能直接获取ca--&gt; b --&gt; c]]></content>
      <tags>
        <tag>范式</tag>
        <tag>多对多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA-JpaRepository方法]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2FSpringDataJPA-JpaRepository%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[解析方法名创建查询12find + 全局修饰 + By + 实体的属性名称 + 限定词 + 连接词 + …(其它实体属性) + OrderBy + 排序属性 + 排序方向 12// 分页查询出符合姓名的记录,同理Sort也可以直接加上public List&lt;User&gt; findByName(String name, Pageable pageable); 12345678910111213141516171819202122232425262728293031323334353637全局修饰： Distinct， Top， First关键词： IsNull， IsNotNull， Like， NotLike， Containing， In， NotIn，IgnoreCase， Between， Equals， LessThan， GreaterThan， After， Before…排序方向： Asc， Desc连接词： And， OrAnd — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；NotNull — 与 IsNotNull 等价；Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>JPA</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA-Query注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2FSpringDataJPA-Query%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Query注解查询适用于所查询的数据无法通过关键字查询得到结果的查询。这种查询可以摆脱像关键字查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是Spring Data的特有实现。 一、索引参数索引参数：索引值从1开始，查询中?X个数需要与方法定义的参数个数相一致，并且顺序也要一致。 12@Query("SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2")List&lt;Person&gt; testQueryAnnotationParams1(String lastName, String email); 注释：上面代码中的?1 、?2表示参数的占位符，需要和方法中所传递的参数顺序一致。X是从1开始。 二、命名参数命名参数：可以定义好参数名，赋值时使用@Param(&quot;参数名&quot;)，而不用管顺序-推荐使用 12345// 为@Query注解传递参数的方式1：命名参数@Query("SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email")List&lt;Person&gt; testQueryAnnotationParams2( @Param("email") String email, @Param("lastName") String lastName); 注释：:lastName 、:email表示为参数命名，方法中所传递的参数使用@Param注解标识命名参数。这种方式不用管参数的顺序。 三、原生SQL进行查询12@Query(value = "SELECT count(id) FROM jpa_persons", nativeQuery = true)long getTotalCount(); 123 @Query(nativeQuery = true, value = "select * from user where name LIKE CONCAT('%', :file_name, '%')")List&lt;User&gt; findByFileName(@Param("file_name") String file_name); 12 @Query(nativeQuery = true, value = "select * from user where name LIKE %:file_name%")List&lt;User&gt; findByFileName(@Param("file_name") String file_name); 注释： 当设置nativeQuery=true即可以使用原生SQL进行查询 like查询：LIKE CONCAT(&#39;%&#39;, :file_name, &#39;%&#39;) 四、@Modifying注解 在@Query注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上@modifying注解，以通知Spring Data这是一个DELETE或UPDATE操作。 UPDATE或者DELETE操作需要使用事务，此时需要定义Service层，在Service层的方法上添加@Transactional。 注意JPQL不支持INSERT操作。 1234@Transactional@Modifying@Query("UPDATE Person p SET p.email = :email WHERE p.id = :id")void updatePersonEmail(@Param("id") Integer id, @Param("email") String email); 五、EntityManager1234567891011121314151617181920212223242526272829303132333435363738394041424344public class EpsmSubjectRepositoryImpl &#123; @PersistenceContext EntityManager entityManager; public List &lt; EpsmSubject &gt; findEpsmSubjectList( Long catalogId, String subjectName, Long start, Long pageSize) &#123; // 构造sql语句 StringBuffer sql = new StringBuffer("SELECT * FROM t_epsm_subject where 1 = 1 "); if (catalogId != null) &#123; sql.append(" and catalog_id = :catalogId "); &#125; if (StringUtils.isNotBlank(subjectName)) &#123; sql.append(" and subject_name like CONCAT('%', :subjectName, '%')"); &#125; sql.append(" order by created_time DESC"); if (start != null &amp;&amp; pageSize != null) &#123; sql.append(" limit :start , :pageSize"); &#125; Query query = entityManager.createNativeQuery(sql.toString(), EpsmSubject.class); // 填充查询参数 if (catalogId != null) &#123; query.setParameter("catalogId", catalogId); &#125; if (StringUtils.isNotBlank(subjectName)) &#123; query.setParameter("subjectName", subjectName); &#125; if (start != null &amp;&amp; pageSize != null) &#123; query.setParameter("start", start); query.setParameter("pageSize", pageSize); &#125; return query.getResultList(); &#125;&#125;]]></content>
      <tags>
        <tag>Query</tag>
        <tag>Modifying</tag>
        <tag>Transactional</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[beans标签与属性]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F19%2Fbeans%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[####&lt;beans&gt;标签 12345&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; xmls xmlns是XMLnameSpace的缩写，xml的标签名称是自定义的，可能会和其他人的标签重名，而功能却不一样，所以需要加一个namespace来区分，类似Java中package 。 xmlns:xsi 是指xml文件遵守xml规范，xsi全名：xml schema instance ，是指具体用到schema资源文件里定义的规范所遵守的规范。即/spring-beans-2.0.xsd这个文件里定义的元素遵守什么标准 xsi:schemaLaction schemalLaction属性来引用（schema）模式文档，解析器可以在需要的情况下使用这个文档对xml实例文档进行校验。它的值（URL）是成对出现的，第一个值表示命名空间，第二个值则表示描述该命名空间的模式文档的具体位置，两个值之间以空格分隔。 &lt;bean&gt;标签12345678910111213141516171819202122232425262728&lt;!-- 空参构造创建 --&gt;&lt;bean id="logDao" name="logDaoName" class="com.sjtu.bean.LogDao" /&gt;&lt;bean id="dataSource" class="com.sjtu.bean.dataSource"&gt; &lt;!-- 值类型注入：为dataSource对象中名为user的属性注入root作为值 --&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean class="com.sjtu.bean..LogonService"&gt; &lt;!-- 引用类型注入：为logDao属性注入logDao对象 --&gt; &lt;property name="logDao" ref="logDao"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 准备带有参数的构造 --&gt;&lt;bean name="user" class="com.sjtu.bean.User"&gt; &lt;!-- name属性：构造函数参数名 --&gt; &lt;!-- index属性：构造函数参数索引 --&gt; &lt;!-- type属性：构造函数参数类型 --&gt; &lt;!-- 上述三个属性不必全部出现，根据情况选择即可 --&gt; &lt;constructor-arg name="name" value="Jerry" index="0" type="java.lang.String"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="car" ref="car"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; id是bean的标识符，必须唯一。如果没有配置id，name默认为标识符 如果配置了id和name，那么name为别名。 name可以设置多个别名，分隔符可以是空格、逗号、分号 class是bean的全限定名，即包名+类名。如果不配置id和name，那么可以根据applicationContext.getbean(Class)获取对象 autowire 自动装配 用于简化spring的配置 123byname: 根据名称去查找相应的bean,发现了则装载上bytype: 根据类型自动装配,不用去管id,但同一种类型的bean只能有一个,否则报错constructor：当通过构造器注入实例化bean时,装配构造方法 scope作用域 12345singleton: 单例的,整个容器只产生一个对象,默认是单例prototype: 原型,每次获取bean都创建一个新对象request: 每次请求时创建一个新的对象session: 在一个会话范围内只产生一个对象application: 在应用范围内是一个对象 分层次程序严格来讲分为四个层次： 显示层：VO类 控制层：Controller类 业务层：Service类 数据层： 表：Entity类 || PO类 CURD：DAO类）]]></content>
      <tags>
        <tag>spring</tag>
        <tag>beans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[一、java 的反射机制Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。 注：反射机制很重要的一点就是“运行时”，其使得我们可以在程序运行时加载、探索以及使用编译期间完全未知的 .class 文件。 二、获取类的信息123456public class FatherClass &#123; public String mFatherName; public int mFatherAge; public void printFatherMsg()&#123;&#125;&#125; 123456789101112131415161718192021222324252627public class SonClass extends FatherClass&#123; private String mSonName; protected int mSonAge; public String mSonBirthday; public void printSonMsg()&#123; System.out.println("Son Msg - name : " + mSonName + "; age : " + mSonAge); &#125; private void setSonName(String name)&#123; mSonName = name; &#125; private void setSonAge(int age)&#123; mSonAge = age; &#125; private int getSonAge()&#123; return mSonAge; &#125; private String getSonName()&#123; return mSonName; &#125;&#125; 123456789101112131415161718192021222324private static void printFields()&#123; //1.获取并输出类的名称 Class mClass = SonClass.class; System.out.println("类的名称：" + mClass.getName()); //2.1 获取所有 public 访问权限的变量 // 包括本类声明的和从父类继承的 Field[] fields = mClass.getFields(); //2.2 获取所有本类声明的变量（不问访问权限） //Field[] fields = mClass.getDeclaredFields(); //3. 遍历变量并输出变量信息 for (Field field : fields) &#123; //获取访问权限(修饰符)并输出 int modifiers = field.getModifiers(); System.out.print(Modifier.toString(modifiers) + " "); //输出变量的类型及变量名 System.out.println(field.getType().getName() + " " + field.getName()); &#125;&#125; 调用 getFields() 方法，输出 SonClass 类以及其所继承的父类1234类的名称：obj.SonClasspublic java.lang.String mSonBirthdaypublic java.lang.String mFatherNamepublic int mFatherAge 调用getDeclaredFields()， 输出 SonClass 类的所有成员变量，不问访问权限 1234类的名称：obj.SonClassprivate java.lang.String mSonNameprotected int mSonAgepublic java.lang.String mSonBirthday 注： 获取变量信息：getFields() 、getDeclaredFields()、getField() 、getDeclaredField() 获取方法信息：getMethods()、getDeclaredMethods()、getMethod()、getDeclaredMethod() 三、私有变量和方法123456789101112public class TestClass &#123; private String MSG = "Original"; private void privateMethod(String head , int tail)&#123; System.out.print(head + tail); &#125; public String getMsg()&#123; return MSG; &#125;&#125; 12345678910111213141516171819202122232425private static void getPrivateMethod() throws Exception&#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有方法 //第一个参数为要获取的私有方法的名称 //第二个为要获取方法的参数的类型，参数为 Class...，没有参数就是null //方法参数也可这么写 ：new Class[]&#123;String.class , int.class&#125; Method privateMethod = mClass.getDeclaredMethod("privateMethod", String.class, int.class); //3. 开始操作方法 if (privateMethod != null) &#123; //获取私有方法的访问权 //只是获取访问权，并不是修改实际权限 privateMethod.setAccessible(true); //使用 invoke 反射调用私有方法 //privateMethod 是获取到的私有方法 //testClass 要操作的对象 //后面两个参数传实参 privateMethod.invoke(testClass, "Java Reflect ", 666); &#125;&#125; 123456789101112131415161718192021222324private static void modifyPrivateFiled() throws Exception &#123; //1. 获取 Class 类实例 TestClass testClass = new TestClass(); Class mClass = testClass.getClass(); //2. 获取私有变量 Field privateField = mClass.getDeclaredField("MSG"); //3. 操作私有变量 if (privateField != null) &#123; //获取私有变量的访问权 privateField.setAccessible(true); //修改私有变量，并输出以测试 System.out.println("Before Modify：MSG = " + testClass.getMsg()); //调用 set(object , value) 修改变量的值 //privateField 是获取到的私有变量 //testClass 要操作的对象 //"Modified" 为要修改成的值 privateField.set(testClass, "Modified"); System.out.println("After Modify：MSG = " + testClass.getMsg()); &#125;&#125; 注： setAccessible(true) 方法，是获取私有方法或变量的访问权限 用 invoke() 方法来调用方法 四、获得 Class 对象1、使用 Class 类的 forName 静态方法1Class&lt;?&gt; cls = Class.forName("java.lang.String"); 2、直接获取某一个类的 class1Class&lt;?&gt; klass = int.class; 3、调用某个对象的 getClass() 方法12StringBuilder str = new StringBuilder("123");Class&lt;?&gt; klass = str.getClass(); 注： Class&lt;T&gt;在实例化的时候，T要替换成具体类 Class&lt;?&gt;它是个通配泛型，?可以代表任何类型 五、创建实例 使用Class对象的newInstance()方法来创建Class对象对应类的实例 12Class&lt;?&gt; c = String.class;Object str = c.newInstance(); 先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法 123456789//获取String所对应的Class对象Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance("23333");System.out.println(obj); 注：getConstructor() 获取构造器对象]]></content>
      <tags>
        <tag>java</tag>
        <tag>Reflection</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F18%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、认识注解JDK1.5之后内部提供的三个注解 @Deprecated 意思是废弃的，过时的 @Override 意思是重写、覆盖 @SuppressWarnings 意思是“压缩警告 12345678910111213141516171819202122public class AnnotationTest &#123; // 这里就是注解，称为压缩警告，这是JDK内部自带的一个注解 // 一个注解就是一个类，在这里使用了这个注解就是创建了SuppressWarnings类的一个实例对象 @SuppressWarnings(":deprecation") public static void main(String[] args) &#123; System.runFinalizersOnExit(true); //这里的runFinalizersOnExit()方法画了一条横线表示此方法已经过时了，不建议使用了 &#125; //这也是JDK内部自带的一个注解，意思就是说这个方法已经废弃了，不建议使用了 @Deprecated public static void sayHello()&#123; System.out.println("hello world"); &#125; //这也是JDK1.5之后内部提供的一个注解，意思就是要重写(覆盖)JDK内部的toString()方法 @Override public String toString()&#123; return "hello world"; &#125;&#125; 注：注解就相当于一个你的源程序要调用一个类，在源程序中应用某个注解，得事先准备好这个注解类 二、自定义注解及其应用1234567891011121314151617181920212223242526272829303132import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;/** * 这是一个自定义的注解(Annotation)类，在定义注解(Annotation)类时使用了另一个注解类Retention * 在注解类上使用另一个注解类，那么被使用的注解类就称为元注解 */@Retention(RetentionPolicy.RUNTIME)//Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)//Target注解决定MyAnnotation注解可以加在哪些成分上，如加在类、属性、方法身上等成分/* * @Retention(RetentionPolicy.SOURCE) * 这个注解的意思是让MyAnnotation注解只在java源文件中存在，编译成.class文件后注解就不存在了 * @Retention(RetentionPolicy.CLASS) * 这个注解的意思是让MyAnnotation注解在java源文件(.java文件)中存在， * 编译成.class文件后注解也还存在，被MyAnnotation注解类标识的类被类加载器加载到内存中后 * MyAnnotation注解就不存在了 *//* * 这里是在注解类MyAnnotation上使用另一个注解类，这里的Retention称为元注解。 * Retention注解括号中的"RetentionPolicy.RUNTIME"意思是让MyAnnotation这个注解的 * 生命周期一直程序运行时都存在 */public @interface MyAnnotation &#123;&#125; 把自定义的注解加到某个类上：12@ MyAnnotation public class AnnotationUse&#123;&#125; 用反射测试进行测试AnnotationUse的定义上是否有@MyAnnotation12345678910111213141516171819202122// 这里是将新创建好的注解类MyAnnotation标记到AnnotaionTest类上@MyAnnotationpublic class AnnotationUse &#123; public static void main(String[] args) &#123; // 这里是检查Annotation类是否有注解，这里需要使用反射才能完成对Annotation类的检查 if (AnnotationUse.class.isAnnotationPresent(MyAnnotation.class)) &#123; /* * MyAnnotation是一个类，这个类的实例对象annotation是通过反射得到的 * 一旦在某个类上使用了@MyAnnotation，那么 * 这个MyAnnotation类的实例对象annotation就会被创建出来了 */ MyAnnotation annotation = (MyAnnotation) AnnotationUse.class .getAnnotation(MyAnnotation.class); // 打印MyAnnotation对象，这里输出的结果为：@cn.itcast.day2.MyAnnotation() System.out.println(annotation); &#125; &#125;&#125; 三、元注解（meta-annotation）Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 @Target @Retention @Documented @Inherited 1、@Target@Target说明了Annotation所修饰的对象范围（被描述的注解可以用在什么地方） CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 12@Target( &#123; ElementType.METHOD, ElementType.TYPE &#125;)// @Target(ElementType.FIELD) 2、@Retention@Retention定义了该Annotation被保留的时间长短。 SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 1@Retention(RetentionPolicy.RUNTIME) 2.1 声明周期一个注解的生命周期有三个阶段：java源文件是一个阶段，class文件是一个阶段，内存中的字节码是一个阶段。javac把源文件编译成.class文件时，有可能去掉里面的注解，类加载器把.class文件加载到内存时也有可能去掉里面的注解。 2.2 Java API中是这样定义的@Deprecated的123@Documented@Retention(value=RUNTIME)public @interface Deprecated 2.3 Java API中是这样定义的@Override的123@Target(value=METHOD)@Retention(value=SOURCE)public @interface Override @Override是给javac看的，编译完以后就@Override注解就没有价值了 2.4 Java API中是这样定义的@SuppressWarnings的123@Target(value=&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)@Retention(value=SOURCE)public @interface SuppressWarnings @SuppressWarnings也是给javac看的 3、@Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default "fieldName"; public String setFuncName() default "setField"; public String getFuncName() default "getField"; public boolean defaultDBValue() default false;&#125; 4、@Inherited@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 四、为注解增加属性注解可以看成是一种特殊的类，既然是类，那自然可以为类添加属性 1、添加属性语法：类型 属性名() default 默认值; || 类型 属性名(); 1234567891011121314import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)// Retention注解决定MyAnnotation注解的生命周期@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)public @interface MyAnnotation &#123; // String color(); String color() default "blue"; // 为属性指定缺省值 String value(); // 定义一个名称为value的属性&#125; 2、应用属性123456789@MyAnnotation(color = "red") //应用MyAnnotation注解的color属性public class MyAnnotationTest &#123; public static void main(String[] args) &#123; // 用反射方式获得注解对应的实例对象后，在通过该对象调用属性对应的方法 MyAnnotation annotation = (MyAnnotation) MyAnnotationTest.class .getAnnotation(MyAnnotation.class); System.out.println(annotation.color()); //输出red &#125;&#125; 3、value属性如果一个注解中有一个名称为value的属性，且你只想设置value属性，那么可以省略掉“value=”部分 12@SuppressWarnings("deprecation")@MyAnnotation("hello world")]]></content>
      <tags>
        <tag>java</tag>
        <tag>Annotation</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC注解]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F17%2FSpring%20MVC%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解类型handler method参数绑定常用的注解，根据处理的Request内容部分不同分为四类： 处理requet uri 部分的注解：@PathVariable 注：指uri template中variable，不含queryString部分 处理request header部分的注解： @RequestHeader、@CookieValue 处理request body部分的注解：@RequestParam、@RequestBody 处理attribute类型是注解： @SessionAttributes、 @ModelAttribute @PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定传过来的值到方法的参数上。 12345678@RequestMapping("/owners/&#123;ownerId&#125;")public class RelativePathUriTemplateController &#123; // @RequestMapping("/pets/&#123;petId&#125;") @RequestMapping(value = "/pets/&#123;petId&#125;", method = RequestMethod.POST) public void findPet(@PathVariable String ownerId, @PathVariable String petId) &#123; // implementation omitted &#125;&#125; 注：若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(&quot;name&quot;)指定uri template中的名称。 1@PathVariable("ownerId") String owner_id @RequestHeader@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上 123456Host localhost:8080Accept text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language fr,en-gb;q=0.7,en;q=0.3Accept-Encoding gzip,deflateAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive 300 123456@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo( @RequestHeader("Accept-Encoding") String encoding, @RequestHeader("Keep-Alive") long keepAlive) &#123; //...&#125; @CookieValue@CookieValue可以把Request header中关于cookie的值绑定到方法的参数上 1JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 1234@RequestMapping("/displayHeaderInfo.do")public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; //...&#125; @RequestParam 常用来处理简单类型的绑定，通过Request.getParameter()获取的String可直接转换为简单类型的情况 可以处理get 方式中queryString的值 可以处理post方式中body data的值 用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST 该注解有两个属性： value、required value用来指定要传入值的id名称 required用来指示参数是否必须绑定 12345678@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm( @RequestParam(value = "petId", required = false) int petId) &#123; // ... &#125;&#125; 注：可以不使用@RequestParam，直接接收。此时要求controller方法中的参数名称要一致 1234567@RequestMapping("/pets")public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm(int petId) &#123; // ... &#125;&#125; @RequestBody常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容 application/json application/xml 使用HandlerAdapter配置的HttpMessageConverters来解析post data body，然后绑定到bean上 字符串解析： 123456789$.ajax(&#123; url: "/login", type: "POST", data: '&#123;"userName":"admin","pwd","admin123"&#125;', content - type: "application/json charset=utf-8", success: function(data) &#123; alert("request success ! "); &#125;&#125;); 12345@requestMapping("/login")public void login(@requestBody String userName, @requestBody String pwd) &#123; System.out.println(userName + " ：" + pwd);&#125;// 将JSON字符串中的两个变量的值分别赋予了两个字符串 对象解析： 12345@RequestMapping(value = "/something", method = RequestMethod.PUT)public void handle(@RequestBody User user) &#123; System.out.println(user.userName + " ：" + user.pwd);&#125;// 将JSON字符串中的值赋予user中对应的属性上 注： JSON字符串中的key必须对应user中的属性名，否则是请求不过去的 @RequestBody最多只能有一个，而@RequestParam()可以有多个 @SessionAttributes用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象。 123456@RequestMapping("/editPet.do")// @SessionAttributes("pet")@SessionAttributes(value = &#123; "pet" &#125;, types = &#123; Integer.class &#125;)public class EditPetForm &#123; // ...&#125; 注：@SessionAttributes注解只能在类上使用，不能在方法上使用 @ModelAttribute、@RequestAttribute123456789@ModelAttributevoid beforeInvokingHandlerMethod(HttpServletRequest request) &#123; request.setAttribute("foo", "hello world");&#125;@RequestMapping(value = "/data/custom", method = RequestMethod.GET)public @ResponseBody String custom(@RequestAttribute("foo") String foo) &#123; return "Got 'foo' request attribute value '" + foo + "'";&#125; 1234&lt;div id="customArgs"&gt; &lt;h3&gt;Custom Resolvable Web Arguments&lt;/h3&gt; &lt;a id="customArg" class="textLink" href="/data/custom"&gt;Custom&lt;/a&gt;&lt;/div&gt; 12345678910$("a.textLink").click(function() &#123; var link = $(this); $.ajax(&#123; url: link.attr("href"), dataType: "text", success: function(text) &#123; alert(text) &#125; &#125;);&#125;); 1Got &apos;foo&apos; request attribute value &apos;hello world&apos;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar-MANIFEST.MF文件]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar-MANIFEST-MF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容： 1234567891011Manifest-Version: 1.0Created-By: Apache Ant 1.5.1Extension-Name: Struts FrameworkSpecification-Title: Struts FrameworkSpecification-Vendor: Apache Software FoundationSpecification-Version: 1.1Implementation-Title: Struts FrameworkImplementation-Vendor: Apache Software FoundationImplementation-Vendor-Id: org.apacheImplementation-Version: 1.1Class-Path: commons-beanutils.jar commons-collections.jar commons-digester.jar 一般属性 Manifest-Version 用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version ：定义jar文件的签名版本 Class-Path ：应用程序或者类装载器使用该值来构建内部的类搜索路径 应用程序相关属性 Main-Class 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过java -jar x.jar来运行该jar文件。]]></content>
      <tags>
        <tag>jar</tag>
        <tag>MANIFEST.MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 修改默认的本地仓库Maven 本地仓库默认被创建在 %USER_HOME%目录下。要修改默认位置，在 %M2_HOME%\conf目录中的 Maven 的 settings.xml文件中定义另一个路径 123456&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;localRepository&gt;C:/MyLocalRepository&lt;/localRepository&gt;&lt;/settings&gt;]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven-pom配置]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fmaven-pom%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[POM是项目对象模型(Project Object Model)的简称,它是Maven项目中的文件。 maven的协作相关属性一个pom.xml的定义必须包含modelVersion、groupId、artifactId和version这四个元素，当然这其中的元素也是可以从它的父项目中继承的。使用groupdId:artifactId:version`的形式来唯一确定一个项目。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 含义：组织标识，定义了项目属于哪个组 用途：此名称则是本地仓库中的路径 例如：otowa.user.dao，在M2_REPO目录下，将是: otowa/user/dao目录 命名规范:项目名称，模块，子模块 --&gt; &lt;groupId&gt;otowa.user.dao&lt;/groupId&gt; &lt;!-- 含义：项目名称，定义当前Maven项目在组中唯一的ID 用途：例如：user-dao，在M2_REPO目录下，将是：otowa/user/dao/user-dao目录 命名规范:唯一就好 --&gt; &lt;artifactId&gt;user-dao&lt;/artifactId&gt; &lt;!-- 含义：项目当前的版本号 用途：例如：0.0.1-SNAPSHOT 在M2_REPO目录下，将是：otowa/user/dao/user-dao/0.0.1-SNAPSHOT目录 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt; &lt;name&gt;maven&lt;/name&gt;&lt;/project&gt; 引入依赖12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化 所以maven中的依赖关系有作用域(scope)的限制。 --&gt; &lt;!-- scope包含如下的取值：compile（编译范围）、provided（已提供范围） runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true 则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版， libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 定义常量123456&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt;&lt;/properties&gt;]]></content>
      <tags>
        <tag>maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jar包]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一、制作只含有字节码文件的jar包我们先来看只含有字节码文件，即只含有.class文件的jar包怎么制作，这是最简单的形式 1、最简单的jar包——直接输出hello最终生成的jar包结构 META-INF Hello.class 方法步骤 （1）用记事本写一个Hello.java的文件 12345class Hello&#123; public static void main(String[] agrs)&#123; System.out.println("hello"); &#125;&#125; （2）用命令行进入到该目录下，编译这个文件 1javac Hello.java （3）将编译后的Hello.class文件打成jar包 1jar -cvf hello.jar Hello.class c 表示要创建一个新的jar包 v 表示创建的过程中在控制台输出创建过程的一些信息 f 表示给生成的jar包命名 （4）运行jar包 12java -jar hello.jar# 这时会报如下错误 hello.jar中没有主清单属性 （5）添加Main-Class属性 用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件 12Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation) 添加Main-Class: Hello ，再次运行java -jar hello.jar ，此时成功在控制台看到 hello 2、含有两个类的jar包——通过调用输出hello最终生成的jar包结构 META-INF Tom.class Hello.class （1）用记事本写一个Hello.java和一个Tom.java的文件 12345class Hello &#123; public static void main(String[] agrs) &#123; System.out.println("hello"); &#125;&#125; 12345class Tom &#123; public static void speak() &#123; System.out.println("hello"); &#125;&#125; （2）编译 1javac Hello.java 此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom （3）打jar包，这次我们换一种方式直接定义Main-Class 123Manifest-Version: 1.0Created-By: 1.8.0_121 (Oracle Corporation)Main-Class: Hello 事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下 1jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class Tom.class 该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件 （4）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 3、有目录结构的jar包——通过引包并调用输出hello最终生成的jar包结构 META-INF com ​ Tom.class Hello.class 我们将上一个稍稍变化一下，将Tom类放在com包下。 12package com;# Tom.java需要在第一行声明自己的包名 12import com.Tom;# Hello.java需要引入Tom这个类 （1）编译Hello.java （2）打jar包，同样准备好MENIFEST文件 12jar -cvfm hello.jar META-INF\MENIFEST.MF Hello.class com # 最后一个com表示把文件夹下的所有文件都打进jar包 （3）运行 java -jar hello.jar ，此时成功在控制台看到 hello ，成功 （4）优化过程 我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。 在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令 12javac Hello.java -d target# 将所有编译后的文件，都放到target文件夹下 将META-INF文件夹也复制到target目录下，进入这个目录，输入如下命令 12jar -cvfm hello.jar META-INF\MENIFEST.MF * # 最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里 原文]]></content>
      <tags>
        <tag>jar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类加载器]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F15%2Fjava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器类加载器负责将.class文件加载到内存中，并为类生成一个java.lang.Class实例。 一旦一个类被加载入JVM中，同一个类就不会被再次加入了。在JVM中用来判断类的唯一性标识是：类名、类所在的包名和类加载器。 当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构： BootStrap ClassLoader：根类加载器 Extension ClassLoader：扩展类加载器 System ClassLoader：系统类加载器 根类加载器 （bootstrap class loader）：它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，并不继承自java.lang.ClassLoader。没有父加载器 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 父加载器为根类加载器 扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。父加载器为扩展类加载器 系统类加载器是纯Java类，是java.lang.ClassLoader类的子类 自定义类加载器（custom class loader）：除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 类加载的父委托机制从JDK 1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。 在父委托机制中，除了Java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器，各个加载器按照父子关系形成了树形结构。 当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由loader1本身加载Sample类。 注： 这里的父加载器概念并不是指类的继承关系，子加载器不一定继承了父加载器（其实是组合的关系） 每个加载器都优先尝试用父类加载，若父类不能加载则自己尝试加载；若成功则返回Class对象给子类，若失败则告诉子类让子类自己加载。所有都失败则抛出ClassNotFoundException异常]]></content>
      <tags>
        <tag>java</tag>
        <tag>ClassLoader</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch使用]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F11%2FElasticsearch%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文档 面向文档通常，应用程序中的对象拥有复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。如果要把这些对象存储在关系型数据库中，相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将对象扁平化来适应表结构，而且又不得不在每次查询时重新构造对象： 一个简单字段对应一列 一个对象字段需要新建表、引用主键 一个数组字段需要新建表、引用主键、每个数组元素对应一行 Elasticsearch使用JavaScript Object Notation或者JSON作为文档的序列化格式。JSON序列化被大多数编程语言所支持，并且已经成为 NoSQL领域的标准格式。 注：文档 =》对象 请求格式一个Elasticsearch请求和任何HTTP请求一样由若干相同的部件组成： 1curl -X &lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos; 被 &lt; &gt; 标记的部件： 参数 说明 VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE PROTOCOL http 或者 https HOST Elasticsearch 集群中任意节点的主机名 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径，由index、type、id 等组成 QUERY_STRING 任意可选的查询字符串参数，?pretty 将格式化地输出 JSON 返回值 BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个： 123456curl -X GET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 搜索格式 搜索所有type 1GET /megacorp/employee/_search 注：使用 _search代替具体的id 参数搜索 12# 查询字符串GET /megacorp/employee/_search?q=last_name:Smith 123456789# match 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;Smith&quot; &#125; &#125;&#125; 123456789101112131415161718# filter 过滤器GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match&quot; : &#123; &quot;last_name&quot; : &quot;smith&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot; : &#123; &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &#125; &#125; &#125; &#125;&#125; 123456789# match_phrase 查询GET /megacorp/employee/_search&#123; &quot;query&quot; : &#123; &quot;match_phrase&quot; : &#123; &quot;about&quot; : &quot;rock climbing&quot; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java知识]]></title>
    <url>%2FendBlogs%2F2019%2F03%2F07%2Fjava%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类名与文件名 一个Java文件中只能有一个public类 如果文件中存在public类，文件名必须与public类名一致 如果文件中没有public类，文件名与类名可以不一致 注：一个源文件中，用class关键字定义了几个类，编译的时候就会产生几个字节码文件 包名与文件名.java文件中的包名必须与物理文件夹对应 123// Something.java 文件package net.java.util;public class Something&#123;&#125; 物理存储位置应该是：net/java/util/Something.java 注： 同一个包中的类名字不能相同 同级包下的类引用不需要import，可以直接调用 Java编译器默认导入java.lang包 主入口方法1public static void main(String[] args) &#123;&#125; 该java类由java虚拟机调用，所以java类应把该方法暴露，故用public 既然由JVM调用该方法，肯定不能new 一个对象再由对象调用该方法，应直接由JVM调用故用static 给JVM返回东西是无意义的 ，故用void 括号里的参数是由JVM传给该方法的，具体可为： 从cmd控制台传入 从开发环境IDE配置参数传入 装箱与拆箱所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型 。 12345678910public class Test &#123; public static void main(String args[]) &#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱// 然后，为了使x能进行加运算，所以要对x进行拆箱 创建数组1dataType[] arrayRefVar = new dataType[arraySize]; 1dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;; 重写与重载重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变 重载(overloading) 是在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
